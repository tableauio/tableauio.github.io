var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/api/checker/guide/",title:"Guide",description:"Go checker guide.",content:`Generate scaffolding code # For example, the generated *.check.go of protobuf message ItemConf is:
type ItemConf struct { tableau.ItemConf } func (x *ItemConf) Check(hub *tableau.Hub) error { // TODO: implement here. return nil } func (x *ItemConf) CheckCompatibility(hub, newHub *tableau.Hub) error { // TODO: implement here. return nil } func init() { // NOTE: This func is auto-generated. DO NOT EDIT. register(func() tableau.Messager { return new(ItemConf) }) } Plugin: protoc-gen-go-tableau-checker # An example to use this protoc plugin: checker/test/gen.sh.
Full example # See go-tableau-checker.
`}).add({id:1,href:"/docs/help/",title:"Help",description:"Help Tableau.",content:""}).add({id:2,href:"/docs/help/how-to-update/",title:"How to Update",description:"Regularly update the installed toolchain to keep your tableau stable, usable, and secure.",content:` 💡 Learn more about semantic versioning and advanced range syntax. tableauc # TODO &hellip;
`}).add({id:3,href:"/docs/help/troubleshooting/",title:"Troubleshooting",description:"Solutions to common problems.",content:`Problems updating tableauc config # TODO &hellip;
Problems with loader # TODO &hellip;
`}).add({id:4,href:"/docs/help/faq/",title:"FAQ",description:"Answers to frequently asked questions.",content:`Question 1 ? # TODO &hellip;
`}).add({id:5,href:"/docs/design/",title:"Design",description:"The Doks Blog.",content:""}).add({id:6,href:"/docs/api/",title:"API",description:"API guide.",content:""}).add({id:7,href:"/docs/design/overview/",title:"Overview",description:"Tableau is a powerful configuration converter powered by Protobuf (proto3).",content:`Features # Convert Excel/CSV/XML/YAML to JSON/Text/Bin. Use Protobuf to define the structure of Excel/CSV/XML/YAML. Use Golang to develop the conversion engine. Support multiple programming languages, thanks to Protobuf (proto3). Concepts # Importer: imports a Excel/CSV file to a in-memory book of Table sheets. imports a XML/YAML file to a in-memory book of Document sheets. Parsers: protogen: converts Excel/CSV/XML/YAML files to Protoconf files. confgen: converts Excel/CSV/XML/YAML with Protoconf files to JSON/Text/Bin files. Exporter: protogen: exports a tableau.Workbook to a proto file. confgen: exports a protobuf message to a JSON/Text/Bin file. Protoconf: a dialect of Protocol Buffers (proto3) extended with tableau options, aimed to define the structure of Excel/CSV/XML/YAML. Workflow # flowchart TD subgraph Input I1(Excel) click I1 href &quot;https://github.com/qax-os/excelize&quot; I2(CSV) click I2 href &quot;https://pkg.go.dev/encoding/csv&quot; I3(XML) click I3 href &quot;https://github.com/antchfx/xmlquery&quot; I4(YAML) click I4 href &quot;https://github.com/go-yaml/yaml&quot; end Input --&gt; I[importer] click I href &quot;https://github.com/tableauio/tableau/tree/master/internal/importer&quot; subgraph Protogen PGP[protogen.Parser] --&gt; E1[protogen.Exporter] click PGP href &quot;https://github.com/tableauio/tableau/tree/master/internal/protogen/parser.go&quot; click E1 href &quot;https://github.com/tableauio/tableau/tree/master/internal/protogen/exporter.go&quot; end I --&gt; Protogen:::orangeclass subgraph Confgen CGP[confgen.Parser] --&gt; CE[confgen.Exporter] click CGP href &quot;https://github.com/tableauio/tableau/tree/master/internal/confgen/parser.go&quot; click CE href &quot;https://github.com/tableauio/tableau/tree/master/internal/confgen/mexporter&quot; end I --&gt; Confgen:::orangeclass Protogen --&gt; B B{{Protoconf}}:::greenclass --&gt; | protobuf descriptor | Confgen subgraph Output O1(&quot;JSON&quot;) click O1 href &quot;https://developers.google.com/protocol-buffers/docs/proto3#json&quot; O2(&quot;Text&quot;) click O2 href &quot;https://developers.google.com/protocol-buffers/docs/text-format-spec&quot; O3(&quot;Bin&quot;) click O3 href &quot;https://developers.google.com/protocol-buffers/docs/encoding&quot; end Confgen --&gt; Output classDef orangeclass fill:#f96; classDef greenclass fill:#40E0D0; Types # Scalar Message(struct) List Map(unordered) Timestamp Duration TODO # protoc plugins # Golang C++ C#/.NET Python Lua Javascript/Typescript/Node Java Metadata # metatable: a message to describe the worksheet&rsquo;s metadata. metafield: a message to describe the caption&rsquo;s metadata. captrow: caption row, the exact row number of captions at worksheet. Newline in caption is allowed for more readability, and will be trimmed in conversion. descrow: description row, the exact row number of descriptions at worksheet. datarow: data row, the start row number of data. Newline(line break) in major operating systems:
OS Abbreviation Escape sequence Unix (linux, OS X) LF \\n Microsoft Windows CRLF \\r\\n classic Mac OS/OS X CR \\r LF: Line Feed, CR: Carriage Return.
Mac OS X
Generator # generate protoconf by Excel(header): Excel -&gt; protoconf generate Excel(header) by protoconf: protoconf -&gt; Excel Conversion # Excel -&gt; JSON(default format and human readable) Excel -&gt; protowire(small size) Excel -&gt; prototext(human debugging) JSON -&gt; Excel protowire -&gt; Excel prototext -&gt; Excel Pretty Print # Multiline: every textual element on a new line Indent: 4 space characters JSON support prototext support EmitUnpopulated # JSON: EmitUnpopulated specifies whether to emit unpopulated fields. Scalar Types # interger: int32, uint32, int64 and uint64 float: float and double bool string bytes datetime, date, time, duration Enumerations # enum: The Parser accepts three enum value forms: enum value number enum value name enum value alias name (with EnumValueOptions specified) enum: validate the enum value. Composite Types # message: horizontal(row direction) layout, fields located in cells. message: simple in-cell message, each field must be scalar type. It is a comma-separated list of fields. E.g.: 1,test,3.0. List&rsquo;s size need not to be equal to fields&rsquo; size, as fields will be filled in order. Fields not configured will be filled default values due to its scalar type. list: horizontal(row direction) layout, which is list&rsquo;s default layout, and each item can be message or scalar. list: vertical(column direction) layout. and each item should be message. list: simple in-cell list, element must be scalar type. It is a comma-separated list of elements. E.g.: 1,2,3. list: scalable or dynamic list size. list: smart recognition of empty element at any position. list In-cell struct list: no need to support Cross-cell horizontal scalar/enum list Cross-cell horizontal incell-struct list Cross-cell vertical scalar list: no need to support, use this: [Item]int32 Cross-cell vertical incell-struct list list size dynamic size: items should be present continuously, and report error if empty item is inserted. fixed size map: horizontal(row direction) layout. map: vertical(column direction) layout, and is map&rsquo;s default layout. map: unordered-map or hash-map. map: ordered-map supported by tableauio/loader. C++ Golang C# map: simple in-cell map, both key and value must be scalar type. It is a comma-separated list of key:value pairs. E.g.: 1:10,2:20,3:30. map: scalable or dynamic map size. map: smart recognition of empty value at any position. map Cross-cell horizontal scalar map: no need to support, use this: map&lt;int32, Item&gt; Cross-cell vertical scalar map: : no need to support, use this: map&lt;int32, Item&gt; map size dynamic size: items should be present continuously, and report error if empty item is inserted. fixed size nesting: unlimited nesting of message, list, and map. nesting: the composite type&rsquo;s first element can be composite type. Default Values # Each scalar type&rsquo;s default value is same as protobuf.
interger: 0 float: 0.0 bool: false string: &quot;&quot; bytes: &quot;&quot; in-cell message: each field&rsquo;s default value is same as protobuf in-cell list: element&rsquo;s default value is same as protobuf in-cell map: both key and value&rsquo;s default value are same as protobuf message: all fields have default values Empty # scalar: default value same as protobuf. message: empty message will not be spawned if all fields are empty. list: empty list will not be spawned if list&rsquo;s size is 0. list: empty message will not be appended if list&rsquo;s element(message type) is empty. map: empty map will not be spawned if map&rsquo;s size is 0. map: empty message will not be inserted if map&rsquo;s value(message type) is empty. nesting: recursively empty. Merge # merge multiple workbooks merge multiple worksheets Workbook meta # workbook meta sheet @TABLEAU:
specify which sheets to be parsed specify parser options for each sheet Sheet Alias Nameline Typeline Sheet1 ExchangeInfo 2 2 Datetime # Understanding about RFC 3339 for Datetime and Timezone Formatting in Software Engineering
2019-10-12T07:20:50.52Z # This is acceptable in ISO 8601 and RFC 3339 (with T) 2019-10-12 07:20:50.52Z # This is only accepted in RFC 3339 (without T)
&ldquo;Z&rdquo; stands for Zero timezone or Zulu timezone UTC+0, and equal to +08:00 in the RFC 3339. RFC 3339 follows the ISO 8601 DateTime format. The only difference is RFC allows us to replace &ldquo;T&rdquo; with &ldquo;space&rdquo;. Use RFC 3339 , which is following ISO 8601.
Timestamp: based on google.protobuf.Timestamp, see JSON mapping Timezone: see ParseInLocation DST: Daylight Savings Time. There is no plan to handle this boring stuff. Datetime: excel format: yyyy-MM-dd HH:mm:ss, e.g.: 2020-01-01 05:10:00 Date: excel format: yyyy-MM-dd or yyMMdd, e.g.: 2020-01-01 or 20200101 Time: excel format: HH:mm:ss or HHmmss, e.g.: 05:10:00 or 051000 Duration: based ongoogle.protobuf.Duration , see JSON mapping Duration: excel format: form &quot;72h3m0.5s&quot;, see golang duration string form Transpose # Interchange the rows and columns of a worksheet. Validation # unique: check map key uniqueness. range: [left, right]. refer: XXXConf.ID. To be supported by tableauio/loader. Error Message # Report clear and precise error messages when converter failed, please refer to the programming language compiler Use golang template to define error message template Multiple languages support, focused on English and Simplified Chinese Performace # Stress test Each goroutine process one worksheet Mutiple process model `}).add({id:8,href:"/docs/design/metadata/",title:"Metadata",description:"An IDL called Protoconf to describe config's structure (metadata), based on Protobuf.",content:`Notation # The syntax is specified using Extended Backus-Naur Form (EBNF).
Workbook -&gt; Protoconf # Basic # workbook: (AliasTest)DemoTest, worksheet: (AliasActivity)DemoActivity
protoconf file name is alias_test.proto. If with no (), name will be demo_test.proto configuration message name is AliasActivity. If with no (), name will be DemoActivity list: [ELEM-TYPE]COLUMN-TYPE, COLUMN-TYPE is column type, ELEM-TYPE is message name and list prefix (must not conflict with the protobuf keyword). map: map&lt;KEY-TYPE,VALUE-TYPE&gt;, KEY-TYPE must be scalar types, and VALUE-TYPE is message name and map prefix (must not conflict with build-in scalar type). import message types: .TYPE, e.g.: .Item represents the message Item already defined in the same protobuf package, and should not redefine it. well-known types Timestamp: google.protobuf.Timestamp Duration: google.protobuf.Duration Activity.xlsx&nbsp; Activity @TABLEAU ActivityID ActivityName ActivityBeginTime ActivityDuration ChapterID ChapterName SectionID SectionName SectionItem1Id SectionItem1Num SectionItem2Id SectionItem2Num map&lt;uint32,Activity&gt; string timestamp duration map&lt;uint32,Chapter&gt; string [Section]uint32 int32 [.Item]int32 int32 int32 int32 1 activity1 2020-01-01 05:00:00 72h 1 chapter1 1 section1 1001 1 1002 2 1 activity1 2020-01-01 05:00:00 72h 1 chapter1 2 section2 1001 1 1002 2 1 activity1 2020-01-01 05:00:00 72h 2 chapter2 1 section1 1001 1 1002 2 2 activity2 2020-01-01 05:00:00 72h3m0.5s 1 chapter1 1 section1 1001 1 1002 2 // common.proto message Item { int32 id = 1 [(tableau.field).name = &quot;Id&quot;]; int32 num= 2 [(tableau.field).name = &quot;Num&quot;]; } Output without prefix # // demo_test.proto import &quot;common.proto&quot; message DemoActivity{ map&lt;uint32, Activity&gt; activity_map = 1 [(key) = &quot;ActivityID&quot;]; message Activity { uint32 id= 1 [(tableau.field).name = &quot;ActivityID&quot;]; string name = 2 [(tableau.field).name = &quot;ActivityName&quot;]; map&lt;uint32, Chapter&gt; chapter_map = 3 [(tableau.field).key = &quot;ChapterID&quot;]; } message Chapter { uint32 id= 1 [(tableau.field).name = &quot;ChapterID&quot;]; string name = 2 [(tableau.field).name = &quot;ChapterName&quot;]; repeated Section section_list = 3 [(tableau.field).layout = LAYOUT_VERTICAL]; } message Section { uint32 id= 1 [(tableau.field).name = &quot;SectionID&quot;]; string name = 2 [(tableau.field).name = &quot;SectionName&quot;]; repeated Item item_list = 3 [(tableau.field).name = &quot;SectionItem&quot;]; } } Output with prefix # // demo_test.proto message DemoActivity{ map&lt;uint32, Activity&gt; activity_map = 1 [(key) = &quot;ActivityID&quot;]; message Activity { uint32 activity_id= 1 [(tableau.field).name = &quot;ActivityID&quot;]; string activity_name = 2 [(tableau.field).name = &quot;ActivityName&quot;]; map&lt;uint32, Chapter&gt; chapter_map = 3 [(tableau.field).key = &quot;ChapterID&quot;]; } message Chapter { uint32 chapter_id= 1 [(tableau.field).name = &quot;ChapterID&quot;]; string chapter_name = 2 [(tableau.field).name = &quot;ChapterName&quot;]; repeated Section section_list = 3 [(tableau.field).layout = LAYOUT_VERTICAL]; } message Section { uint32 section_id= 1 [(tableau.field).name = &quot;SectionID&quot;]; string section_name = 2 [(tableau.field).name = &quot;SectionName&quot;]; repeated Item section_item_list = 3 [(tableau.field).name = &quot;SectionItem&quot;]; } } Incell # workbook: (AliasTest)DemoTest, worksheet: (Env)Environment
ID Name IncellMessage IncellList IncellMap IncellMessageList IncellMessageMap uint32 string {int32 id,string desc,int32 value}Msg []int32 map&lt;int32,string&gt; []{int32 id,string desc}Elem map&lt;int32,Value{int32 id,string desc}&gt; 1 Earth 1,desc,100 1,2,3 1:hello,2:world {1,hello},{2,world} 1:{1,hello},2:{2,world} --break-me-here--
IncellMessage # Syntax: TODO: EBNF Type: message type Value: comma seperated field values, e.g.: 1,desc,100 Rules:
Default Type Value int32 can be parsed as number string cannot be parsed as number IncellList # Syntax: []Type Type: any scalar type Value: comma seperated list items, e.g.: 1,2,3
IncellMap # Syntax: map&lt;Type,Type&gt; Type: any scalar type Value: comma seperated key-value pairs, and key-value is seperated by colon. e.g.: 1:hello,2:world
IncellMessageList # TODO&hellip;
IncellMessageMap # TODO&hellip;
Output # // demo_test.proto message Env { uint32 ID = 1 [(tableau.field).name = &quot;ID&quot;]; string name = 2 [(tableau.field).name = &quot;Name&quot;]; Msg incell_message= 3 [(tableau.field).name = &quot;IncellMessage&quot;]; repeated int32 incell_list= 4 [(tableau.field).name = &quot;IncellList&quot;]; map&lt;int32, string&gt; incell_map = 5 [(tableau.field).name = &quot;IncellMap&quot;]; repeated Elem incell_message_list= 6 [(tableau.field).name = &quot;IncellMessageList&quot;]; map&lt;int32, Value&gt; incell_message_map = 7 [(tableau.field).name = &quot;IncellMessageMap&quot;]; // defaut name: field + &lt;tagid&gt; message Msg { int32 id = 1; string desc= 2; int32 value= 3; } message Elem { int32 id = 1; string desc= 2; } message Value { int32 id = 1; string desc= 2; } } Incell message: comma seperated sequence: {TYPE [NAME],TYPE [NAME]}, NAME is optional, and will be auto generated as field + &lt;tagid&gt; if not specified. Incell list: []TYPE, TYPE must be scalar type. Incell map: map[KEY]VALUE, KEY and VALUE must be scalar types. Incell message list: []TYPE, TYPE must be message type. Incell message map: map[KEY]VALUE, KEY is scalar, and VALUE must be message type. Protoconf -&gt; Workbook # TODO&hellip;
`}).add({id:9,href:"/docs/api/tableau/",title:"Tableau",description:"Tableau guide.",content:""}).add({id:10,href:"/docs/api/loader/",title:"Loader",description:"Loader guide.",content:""}).add({id:11,href:"/docs/api/loader/overview/",title:"Overview",description:"Overview of tableau loader API.",content:"Supported APIs # Lang Get (Map) GetOrderedMap Find (Index) C++ ✔️ ✔️ ✔️ Go ✔️ ✔️ ✔️ C# TypeScript Lua "}).add({id:12,href:"/docs/api/loader/cpp/",title:"C++",description:"C++ loader guide.",content:`API # Data # const ProtobufMessage&amp; Data()
Get the internal protobuf message data.
Map # const MapValueType* Get(k1 KEY1, k2 KEY2...) const
Get the Nth-level map value. Be aware that only applies to each level message&rsquo;s first map field.
OrderedMap # Prerequisite: You need to set metasheet option OrderedMap to true.
See metatsheet option: OrderedMap.
const OrderedMapValueType* GetOrderedMap(k1 KEY1, k2 KEY2...) const
Get the Nth-level ordered map value. Be aware that only applies to each level message&rsquo;s first map field.
Index # Prerequisite: You need to set metatsheet option Index appropriately.
See metatsheet option: Index.
If index name is Chapter, then the accessers are:
const vector&lt;ParentType&gt;* FindChapter(k1 KEY1, k2 KEY2...) const const ParentType* FindFirstChapter(k1 KEY1, k2 KEY2...) const Custom messager # If the built-in APIs are not sufficient for your business logic, then you can add a custom messager, where you can write preprocess logic based on loaded config objects.
Example: cpp-tableau-loader/hub/custom
custom_xxx_conf.h:
#pragma once #include &quot;protoconf/hub.pc.h&quot; #include &quot;protoconf/xxx_conf.pc.h&quot; class CustomXXXConf : public tableau::Messager { public: static const std::string&amp; Name() { return kCustomName; }; virtual bool Load(const std::string&amp; dir, tableau::Format fmt, const tableau::LoadOptions* options = nullptr) override { return true; } virtual bool ProcessAfterLoadAll(const tableau::Hub&amp; hub) override; private: static const std::string kCustomName; // TODO: add custom data fields. }; custom_xxx_conf.cpp:
#include &quot;hub/custom/xxx/custom_xxx_conf.h&quot; const std::string CustomXXXConf::kCustomName = &quot;CustomXXXConf&quot;; bool CustomItemConf::ProcessAfterLoadAll(const tableau::Hub&amp; hub) { // TODO: implement here. return true; } Plugin: protoc-gen-cpp-tableau-loader # An example to use this protoc plugin: cpp-tableau-loader/gen.sh.
Full example # See cpp-tableau-loader.
`}).add({id:13,href:"/docs/api/loader/go/",title:"Go",description:"Go loader guide.",content:`API # Data # func Data() *ProtobufMessage
Get the internal protobuf message data.
Map # func GetN(k1 KEY1, k2 KEY2...) (*MapValueType, error)
Get the Nth-level map value. Be aware that only applies to each level message&rsquo;s first map field.
OrderedMap # Prerequisite: You need to set metasheet option OrderedMap to true.
See metatsheet option: OrderedMap.
func GetOrderedMapN(k1 KEY1, k2 KEY2...) (*OrderedMapValueType, error)
Get the Nth-level ordered map value. Be aware that only applies to each level message&rsquo;s first map field.
Index # Prerequisite: You need to set metatsheet option Index appropriately.
See metatsheet option: Index.
If index name is Chapter, then the accessers are:
func FindChapter(k1 KEY1, k2 KEY2...) []*ParentType func FindFirstChapter(k1 KEY1, k2 KEY2...) *ParentType Custom messager # If the built-in APIs are not sufficient for your business logic, then you can add a custom messager, where you can write preprocess logic based on loaded config objects.
Example: go-tableau-loader/customconf
custom_xxx_conf.go:
type CustomXXXConf struct { tableau.UnimplementedMessager // TODO: add custom data fields. } func (x *CustomItemConf) Name() string { return &quot;CustomXXXConf&quot; } func (x *CustomItemConf) ProcessAfterLoadAll(hub *tableau.Hub) error { // TODO: implement here. return nil } func init() { tableau.Register(func() tableau.Messager { return new(CustomXXXConf) }) } Plugin: protoc-gen-go-tableau-loader # An example to use this protoc plugin: go-tableau-loader/gen.sh.
Full example # See go-tableau-loader.
`}).add({id:14,href:"/docs/api/loader/csharp/",title:"C#",description:"C# loader guide.",content:`Overview # TODO: refer Tableau loader.
`}).add({id:15,href:"/docs/api/loader/ts/",title:"TypeScript",description:"TypeScript loader guide.",content:`Overview # TODO: refer Tableau loader.
`}).add({id:16,href:"/docs/api/loader/lua/",title:"Lua",description:"Lua loader guide.",content:`Overview # TODO: refer Tableau loader.
`}).add({id:17,href:"/docs/api/checker/",title:"Checker",description:"Checker guide.",content:""}).add({id:18,href:"/docs/yaml/scalar/",title:"Scalar",description:"YAML scalar guide.",content:`Scalar # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; ID: uint32 Num: int32 Value: uint64 Weight: int64 Percentage: float Ratio: double Name: string Blob: bytes OK: bool --- &quot;@sheet&quot;: ItemConf ID: 1 Num: 10 Value: 20 Weight: 30 Percentage: 0.5 Ratio: 3.14159 Name: apple Blob: &quot;VGFibGVhdQ==&quot; # base64 of &quot;Tableau&quot; OK: true Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; uint64 value = 3 [(tableau.field) = {name:&quot;Value&quot;}]; int64 weight = 4 [(tableau.field) = {name:&quot;Weight&quot;}]; float percentage = 5 [(tableau.field) = {name:&quot;Percentage&quot;}]; double ratio = 6 [(tableau.field) = {name:&quot;Ratio&quot;}]; string name = 7 [(tableau.field) = {name:&quot;Name&quot;}]; bytes blob = 8 [(tableau.field) = {name:&quot;Blob&quot;}]; bool ok = 9 [(tableau.field) = {name:&quot;OK&quot;}]; } ItemConf.json { &quot;id&quot;: 1, &quot;num&quot;: 10, &quot;value&quot;: &quot;20&quot;, &quot;weight&quot;: &quot;30&quot;, &quot;percentage&quot;: 0.5, &quot;ratio&quot;: 3.14159, &quot;name&quot;: &quot;apple&quot;, &quot;blob&quot;: &quot;VkdGaWJHVmhkUT09&quot;, &quot;ok&quot;: true } `}).add({id:19,href:"/docs/yaml/",title:"YAML",description:"YAML guide.",content:""}).add({id:20,href:"/docs/yaml/enum/",title:"Enum",description:"YAML enum guide.",content:`Use predefined enum type # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; ID: uint32 Type: &quot;enum&lt;.FruitType&gt;&quot; Desc: string --- &quot;@sheet&quot;: ItemConf ID: 1 Type: FRUIT_TYPE_APPLE Desc: A kind of delicious fruit. Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.FruitType type = 2 [(tableau.field) = {name:&quot;Type&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } ItemConf.json { &quot;id&quot;: 1, &quot;type&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; } `}).add({id:21,href:"/docs/api/tableau/guide/",title:"Guide",description:"This guide gets you started with Tableau in Go with a simple working example.",content:`Prerequisites # Go, any one of the three latest major releases of Go. For installation instructions, see Go’s Getting Started guide. Protocol buffer compiler, protoc, version 3. For installation instructions, see Protocol Buffer Compiler Installation. Go plugins for the protocol compiler: Install the protocol compiler plugins for Go using the following commands:
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 Update your PATH so that the protoc compiler can find the plugins:
export PATH=&quot;$PATH:$(go env GOPATH)/bin&quot; Get the example code # The example code is part of the tableau/demo repo.
Download the repo as a zip file and unzip it, or clone the repo:
git clone https://github.com/tableauio/demo Change to the quick start example directory:
cd demo/examples/helloworld Run the example # From the examples/helloworld directory:
Change dir to excel2proto, compile and execute:
go run main.go Then proto files will be generated to examples/helloworld/proto.
Change dir to excel2conf, generate *.pb.go and then compile and execute:
bash gen.sh go run main.go Then *.pb.go files will be generated to examples/helloworld/protoconf, and JSON files will be generated to examples/helloworld/excel2conf/_out.
Congratulations! You’ve just run a modern configuration converter application with Tableau.
`}).add({id:22,href:"/docs/yaml/struct/",title:"Struct",description:"YAML struct guide.",content:`General struct # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Item: &quot;@type&quot;: &quot;{Item}&quot; ID: uint32 StartTime: datetime Expiry: duration --- &quot;@sheet&quot;: ItemConf Item: ID: 1 StartTime: 2024-10-01 10:10:10 Expiry: 1h Tips
Well-known type: datetime → Well-known type: duration → Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; google.protobuf.Timestamp start_time = 2 [(tableau.field) = {name:&quot;StartTime&quot;}]; google.protobuf.Duration expiry = 3 [(tableau.field) = {name:&quot;Expiry&quot;}]; } } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;startTime&quot;: &quot;2024-10-01T02:10:10Z&quot;, &quot;expiry&quot;: &quot;3600s&quot; } } Reuse same-level struct # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Item: &quot;@type&quot;: &quot;{Item}&quot; ID: uint32 StartTime: datetime Expiry: duration NewItem: &quot;{Item}&quot; # reuse predefined struct type Item above --- &quot;@sheet&quot;: ItemConf Item: ID: 1 StartTime: 2024-10-01 10:10:10 Expiry: 1h NewItem: ID: 2 StartTime: 2026-10-01 10:10:10 Expiry: 2h Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; google.protobuf.Timestamp start_time = 2 [(tableau.field) = {name:&quot;StartTime&quot;}]; google.protobuf.Duration expiry = 3 [(tableau.field) = {name:&quot;Expiry&quot;}]; } Item new_item = 2 [(tableau.field) = {name:&quot;NewItem&quot;}]; } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;startTime&quot;: &quot;2024-10-01T02:10:10Z&quot;, &quot;expiry&quot;: &quot;3600s&quot; }, &quot;newItem&quot;: { &quot;id&quot;: 2, &quot;startTime&quot;: &quot;2026-10-01T02:10:10Z&quot;, &quot;expiry&quot;: &quot;7200s&quot; } } Predefined struct # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Item: &quot;{.Item}&quot; --- &quot;@sheet&quot;: ItemConf Item: ID: 1 Num: 10 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } Incell struct # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Item: &quot;{uint32 ID, int32 Num}Item&quot; --- &quot;@sheet&quot;: ItemConf Item: &quot;1, 10&quot; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item item = 1 [(tableau.field) = {name:&quot;Item&quot; span:SPAN_INNER_CELL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } Incell general struct # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Item: &quot;@type&quot;: &quot;{Item}&quot; &quot;@incell&quot;: true ID: uint32 Num: int32 --- &quot;@sheet&quot;: ItemConf Item: &quot;1, 10&quot; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item item = 1 [(tableau.field) = {name:&quot;Item&quot; span:SPAN_INNER_CELL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } Incell predefined struct # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Item: &quot;@type&quot;: &quot;{.Item}&quot; &quot;@incell&quot;: true --- &quot;@sheet&quot;: ItemConf Item: &quot;1, 10&quot; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Item item = 1 [(tableau.field) = {name:&quot;Item&quot; span:SPAN_INNER_CELL}]; } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } `}).add({id:23,href:"/docs/yaml/union/",title:"Union",description:"YAML union guide.",content:`Union definition # For example, union type Target in common.proto is predefined as:
// Predefined union type. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: &quot;Type&quot; }]; oneof value { option (tableau.oneof) = { field: &quot;Field&quot; }; Pvp pvp = 1; // Binded to enum value 1: TYPE_PVP. Pve pve = 2; // Binded to enum value 2: TYPE_PVP. Story story = 3; // Binded to enum value 3: TYPE_STORY. Skill skill = 4; // Binded to enum value 4: TYPE_SKILL. } enum Type { TYPE_NIL = 0; TYPE_PVP = 1 [(tableau.evalue) = { name: &quot;PVP&quot; }]; TYPE_PVE = 2 [(tableau.evalue) = { name: &quot;PVE&quot; }]; TYPE_STORY = 3 [(tableau.evalue) = { name: &quot;Story&quot; }]; TYPE_SKILL = 4 [(tableau.evalue) = { name: &quot;Skill&quot; }]; } message Pvp { int32 type = 1; // scalar int64 damage = 2; // scalar repeated protoconf.FruitType types = 3; // incell enum list } message Pve { Mission mission = 1; // incell struct repeated int32 heros = 2; // incell list map&lt;int32, int64&gt; dungeons = 3; // incell map message Mission { int32 id = 1; uint32 level = 2; int64 damage = 3; } } message Story { protoconf.Item cost = 1; // incell predefined struct map&lt;int32, protoconf.FruitType&gt; fruits = 2; // incell map with value as enum type map&lt;int32, Flavor&gt; flavors = 3; // incell map with key as enum type message Flavor { protoconf.FruitFlavor key = 1 [(tableau.field) = { name: &quot;Key&quot; }]; int32 value = 2 [(tableau.field) = { name: &quot;Value&quot; }]; } } message Skill { int32 id = 1; // scalar int64 damage = 2; // scalar // no field tag 3 } } Predefined union # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Target: &quot;{.Target}&quot; --- &quot;@sheet&quot;: ItemConf Target: Type: PVP Field1: 1 Field2: 10 Field3: &quot;Apple,Orange,Banana&quot; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Target target = 1 [(tableau.field) = {name:&quot;Target&quot;}]; } ItemConf.json { &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVP&quot;, &quot;pvp&quot;: { &quot;type&quot;: 1, &quot;damage&quot;: &quot;10&quot;, &quot;types&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } } } Predefined incell union # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Target: &quot;@type&quot;: &quot;{.Target}|{form:FORM_TEXT}&quot; &quot;@incell&quot;: true --- &quot;@sheet&quot;: ItemConf Target: &quot;type:TYPE_PVE pve:{mission:{id:1 level:100 damage:999} heros:1 heros:2 heros:3 dungeons:{key:1 value:10} dungeons:{key:2 value:20} dungeons:{key:3 value:30}}&quot; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Target target = 1 [(tableau.field) = {name:&quot;Target&quot; span:SPAN_INNER_CELL prop:{form:FORM_TEXT}}]; } ItemConf.json { &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVE&quot;, &quot;pve&quot;: { &quot;mission&quot;: { &quot;id&quot;: 1, &quot;level&quot;: 100, &quot;damage&quot;: &quot;999&quot; }, &quot;heros&quot;: [ 1, 2, 3 ], &quot;dungeons&quot;: { &quot;1&quot;: &quot;10&quot;, &quot;2&quot;: &quot;20&quot;, &quot;3&quot;: &quot;30&quot; } } } } Predefined union list # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Targets: &quot;[.Target]&quot; --- &quot;@sheet&quot;: ItemConf Targets: - Type: Story Field1: &quot;1001,10&quot; Field2: &quot;1:Apple,2:Orange&quot; Field3: &quot;Fragrant:1,Sour:2&quot; - Type: Skill Field1: 1 Field2: 2 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Target targets = 1 [(tableau.field) = {name:&quot;Targets&quot;}]; } ItemConf.json { &quot;targets&quot;: [ { &quot;type&quot;: &quot;TYPE_STORY&quot;, &quot;story&quot;: { &quot;cost&quot;: { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, &quot;fruits&quot;: { &quot;1&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;2&quot;: &quot;FRUIT_TYPE_ORANGE&quot; }, &quot;flavors&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: 1 }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: 2 } } } }, { &quot;type&quot;: &quot;TYPE_SKILL&quot;, &quot;skill&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;2&quot; } } ] } `}).add({id:24,href:"/docs/yaml/list/",title:"List",description:"YAML list guide.",content:`Scalar list # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;[int32]&quot; --- &quot;@sheet&quot;: ItemConf Items: [1, 2, 3] Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated int32 items = 1 [(tableau.field) = {name:&quot;Items&quot;}]; } ItemConf.json { &quot;items&quot;: [ 1, 2, 3 ] } Enum list # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Fruits: &quot;[enum&lt;.FruitType&gt;]&quot; --- &quot;@sheet&quot;: ItemConf Fruits: [FRUIT_TYPE_APPLE, FRUIT_TYPE_ORANGE, FRUIT_TYPE_BANANA] Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType fruits = 1 [(tableau.field) = {name:&quot;Fruits&quot;}]; } ItemConf.json { &quot;fruits&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } Incell scalar list # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;[]int32&quot; --- &quot;@sheet&quot;: ItemConf Items: &quot;1, 2, 3&quot; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated int32 items = 1 [(tableau.field) = {name:&quot;Items&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;items&quot;: [ 1, 2, 3 ] } Incell enum list # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Fruits: &quot;[]enum&lt;.FruitType&gt;&quot; --- &quot;@sheet&quot;: ItemConf Fruits: &quot;FRUIT_TYPE_APPLE, FRUIT_TYPE_ORANGE, FRUIT_TYPE_BANANA&quot; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType fruits = 1 [(tableau.field) = {name:&quot;Fruits&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;fruits&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } Struct list # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;@type&quot;: &quot;[Item]&quot; &quot;@struct&quot;: ID: uint32 Num: int32 --- &quot;@sheet&quot;: ItemConf Items: - ID: 1 Num: 10 - ID: 2 Num: 20 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item items = 1 [(tableau.field) = {name:&quot;Items&quot;}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;items&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ] } Predefined struct list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;[.Item]&quot; --- &quot;@sheet&quot;: ItemConf Items: - ID: 1 Num: 10 - ID: 2 Num: 20 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Item items = 1 [(tableau.field) = {name:&quot;Items&quot;}]; } ItemConf.json { &quot;items&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ] } List in list # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Countries: &quot;@type&quot;: &quot;[Country]&quot; &quot;@struct&quot;: Country: string Desc: string Items: &quot;@type&quot;: &quot;[Item]&quot; &quot;@struct&quot;: Name: string Num: int32 --- &quot;@sheet&quot;: ItemConf Countries: - Country: USA Desc: A country in North America. Items: - Name: apple Num: 10 - Name: orange Num: 20 - Country: China Desc: A country in East Asia. Items: - Name: apple Num: 100 - Name: orange Num: 200 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Country countries = 1 [(tableau.field) = {name:&quot;Countries&quot;}]; message Country { string country = 1 [(tableau.field) = {name:&quot;Country&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; repeated Item items = 3 [(tableau.field) = {name:&quot;Items&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countries&quot;: [ { &quot;country&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;items&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } ] }, { &quot;country&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;items&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } ] } ] } Map in list # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Countries: &quot;@type&quot;: &quot;[Country]&quot; &quot;@struct&quot;: Country: string Desc: string Items: &quot;@type&quot;: &quot;map&lt;string, Item&gt;&quot; &quot;@struct&quot;: &quot;@key&quot;: Name Num: int32 --- &quot;@sheet&quot;: ItemConf Countries: - Country: USA Desc: A country in North America. Items: apple: Num: 10 orange: Num: 20 - Country: China Desc: A country in East Asia. Items: apple: Num: 100 orange: Num: 200 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Country countries = 1 [(tableau.field) = {name:&quot;Countries&quot;}]; message Country { string country = 1 [(tableau.field) = {name:&quot;Country&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; map&lt;string, Item&gt; items = 3 [(tableau.field) = {name:&quot;Items&quot; key:&quot;@key&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;@key&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countries&quot;: [ { &quot;country&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;items&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } } }, { &quot;country&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;items&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } } } ] } `}).add({id:25,href:"/docs/yaml/map/",title:"Map",description:"YAML map guide.",content:`Scalar map # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;map&lt;uint32, string&gt;&quot; --- &quot;@sheet&quot;: ItemConf Items: 1: dog 2: bird 3: cat Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, string&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot;}]; } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: &quot;dog&quot;, &quot;2&quot;: &quot;bird&quot;, &quot;3&quot;: &quot;cat&quot; } } Enum key map # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;map&lt;enum&lt;.FruitType&gt;, string&gt;&quot; --- &quot;@sheet&quot;: ItemConf Items: FRUIT_TYPE_APPLE: apple FRUIT_TYPE_ORANGE: orange FRUIT_TYPE_BANANA: banana Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, ItemsValue&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot; key:&quot;@key&quot; span:SPAN_INNER_CELL}]; message ItemsValue { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; string value = 2 [(tableau.field) = {name:&quot;@value&quot;}]; } } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;value&quot;: &quot;apple&quot; }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;value&quot;: &quot;orange&quot; }, &quot;4&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_BANANA&quot;, &quot;value&quot;: &quot;banana&quot; } } } Enum key-value map # Enum types Enum type FruitType and FruitFlavor in common.proto are predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } enum FruitFlavor { FRUIT_FLAVOR_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_FLAVOR_FRAGRANT = 1 [(tableau.evalue).name = &quot;Fragrant&quot;]; FRUIT_FLAVOR_SOUR = 2 [(tableau.evalue).name = &quot;Sour&quot;]; FRUIT_FLAVOR_SWEET = 3 [(tableau.evalue).name = &quot;Sweet&quot;]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;map&lt;enum&lt;.FruitType&gt;, enum&lt;.FruitFlavor&gt;&gt;&quot; --- &quot;@sheet&quot;: ItemConf Items: FRUIT_TYPE_APPLE: FRUIT_FLAVOR_FRAGRANT FRUIT_TYPE_ORANGE: FRUIT_FLAVOR_SOUR FRUIT_TYPE_BANANA: FRUIT_FLAVOR_SWEET Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, ItemsValue&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot; key:&quot;@key&quot; span:SPAN_INNER_CELL}]; message ItemsValue { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; protoconf.FruitFlavor value = 2 [(tableau.field) = {name:&quot;@value&quot;}]; } } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot; }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_SOUR&quot; }, &quot;4&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_BANANA&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_SWEET&quot; } } } Incell scalar map # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;@type&quot;: &quot;map&lt;uint32, string&gt;&quot; &quot;@incell&quot;: true --- &quot;@sheet&quot;: ItemConf Items: &quot;1:dog,2:bird,3:cat&quot; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, string&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: &quot;dog&quot;, &quot;2&quot;: &quot;bird&quot;, &quot;3&quot;: &quot;cat&quot; } } Incell enum map # Enum types Enum type FruitType and FruitFlavor in common.proto are predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } enum FruitFlavor { FRUIT_FLAVOR_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_FLAVOR_FRAGRANT = 1 [(tableau.evalue).name = &quot;Fragrant&quot;]; FRUIT_FLAVOR_SOUR = 2 [(tableau.evalue).name = &quot;Sour&quot;]; FRUIT_FLAVOR_SWEET = 3 [(tableau.evalue).name = &quot;Sweet&quot;]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;@type&quot;: &quot;map&lt;enum&lt;.FruitType&gt;, enum&lt;.FruitFlavor&gt;&gt;&quot; &quot;@struct&quot;: CustomMapValue &quot;@incell&quot;: true --- &quot;@sheet&quot;: ItemConf Items: &quot;FRUIT_TYPE_APPLE:FRUIT_FLAVOR_FRAGRANT, FRUIT_TYPE_ORANGE:FRUIT_FLAVOR_SOUR&quot; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, CustomMapValue&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot; key:&quot;@key&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; message CustomMapValue { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; protoconf.FruitFlavor value = 2 [(tableau.field) = {name:&quot;@value&quot;}]; } } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot; }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_SOUR&quot; } } } Struct map # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;@type&quot;: &quot;map&lt;uint32, Item&gt;&quot; &quot;@struct&quot;: Name: string Num: int32 --- &quot;@sheet&quot;: ItemConf Items: 1: Name: apple Num: 10 2: Name: orange Num: 20 3: Name: banana Num: 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot; key:&quot;@key&quot;}]; message Item { uint32 key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 3 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: { &quot;key&quot;: 1, &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;2&quot;: { &quot;key&quot;: 2, &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 }, &quot;3&quot;: { &quot;key&quot;: 3, &quot;name&quot;: &quot;banana&quot;, &quot;num&quot;: 30 } } } Enum key struct map # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;@type&quot;: &quot;map&lt;enum&lt;.FruitType&gt;, EnumItem&gt;&quot; &quot;@struct&quot;: Name: string Num: int32 --- &quot;@sheet&quot;: ItemConf Items: FRUIT_TYPE_APPLE: Name: apple Num: 10 FRUIT_TYPE_ORANGE: Name: orange Num: 20 FRUIT_TYPE_BANANA: Name: banana Num: 30 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, EnumItem&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot; key:&quot;@key&quot;}]; message EnumItem { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 3 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 }, &quot;4&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_BANANA&quot;, &quot;name&quot;: &quot;banana&quot;, &quot;num&quot;: 30 } } } Custom key struct map # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Items: &quot;@type&quot;: &quot;map&lt;uint32, Item&gt;&quot; &quot;@struct&quot;: &quot;@key&quot;: CustomKey Name: string Num: int32 --- &quot;@sheet&quot;: ItemConf Items: 1: Name: apple Num: 10 2: Name: orange Num: 20 3: Name: banana Num: 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; items = 1 [(tableau.field) = {name:&quot;Items&quot; key:&quot;CustomKey&quot;}]; message Item { uint32 custom_key = 1 [(tableau.field) = {name:&quot;CustomKey&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 3 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;items&quot;: { &quot;1&quot;: { &quot;key&quot;: 1, &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;2&quot;: { &quot;key&quot;: 2, &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 }, &quot;3&quot;: { &quot;key&quot;: 3, &quot;name&quot;: &quot;banana&quot;, &quot;num&quot;: 30 } } } List in map # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Countries: &quot;@type&quot;: &quot;map&lt;string, Country&gt;&quot; &quot;@struct&quot;: Desc: string Items: &quot;@type&quot;: &quot;[Item]&quot; &quot;@struct&quot;: Name: string Num: int32 --- &quot;@sheet&quot;: ItemConf Countries: USA: Desc: A country in North America. Items: - Name: apple Num: 10 - Name: orange Num: 20 China: Desc: A country in East Asia. Items: - Name: apple Num: 100 - Name: orange Num: 200 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Country&gt; countries = 1 [(tableau.field) = {name:&quot;Countries&quot; key:&quot;@key&quot;}]; message Country { string key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; repeated Item items = 3 [(tableau.field) = {name:&quot;Items&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countries&quot;: { &quot;China&quot;: { &quot;key&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;items&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } ] }, &quot;USA&quot;: { &quot;key&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;items&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } ] } } } Map in map # A worksheet ItemConf in HelloWorld.yaml:
# define metasheet: generate all sheets &quot;@sheet&quot;: &quot;@TABLEAU&quot; --- # define schema &quot;@sheet&quot;: &quot;@ItemConf&quot; Countries: &quot;@type&quot;: &quot;map&lt;string, Country&gt;&quot; &quot;@struct&quot;: Desc: string Items: &quot;@type&quot;: &quot;map&lt;string, Item&gt;&quot; &quot;@struct&quot;: &quot;@key&quot;: Name Num: int32 --- &quot;@sheet&quot;: ItemConf Countries: USA: Desc: A country in North America. Items: apple: Num: 10 orange: Num: 20 China: Desc: A country in East Asia. Items: apple: Num: 100 orange: Num: 200 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.yaml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;string, Country&gt; countries = 1 [(tableau.field) = {name:&quot;Countries&quot; key:&quot;@key&quot;}]; message Country { string key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; map&lt;string, Item&gt; items = 3 [(tableau.field) = {name:&quot;Items&quot; key:&quot;@key&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;@key&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countries&quot;: { &quot;China&quot;: { &quot;key&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;items&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } } }, &quot;USA&quot;: { &quot;key&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;items&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } } } } } `}).add({id:26,href:"/docs/yaml/metasheet/",title:"Metasheet",description:"YAML metasheet @TABLEAU guide.",content:`Overview # The metasheet named &ldquo;@TABLEAU&rdquo; is designed to specify tableau parser options. Go to read details about Metatsheet →.
A YAML metasheet example:
# define metasheet &quot;@sheet&quot;: &quot;@TABLEAU&quot; Sheet1: Alias: ItemConf OrderedMap: true Index: &quot;(ID,Type)@Item&quot; Sheet2: Alias: FruitConf Sep: &quot;,&quot; Subsep: &quot;:&quot; FieldPresence: true TODO # More details&hellip;
`}).add({id:27,href:"/docs/xml/scalar/",title:"Scalar",description:"XML scalar guide.",content:`Scalar # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;ID&gt;uint32&lt;/ID&gt; &lt;Num&gt;int32&lt;/Num&gt; &lt;Value&gt;uint64&lt;/Value&gt; &lt;Weight&gt;int64&lt;/Weight&gt; &lt;Percentage&gt;float&lt;/Percentage&gt; &lt;Ratio&gt;double&lt;/Ratio&gt; &lt;Name&gt;string&lt;/Name&gt; &lt;Blob&gt;bytes&lt;/Blob&gt; &lt;OK&gt;bool&lt;/OK&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;ID&gt;1&lt;/ID&gt; &lt;Num&gt;10&lt;/Num&gt; &lt;Value&gt;20&lt;/Value&gt; &lt;Weight&gt;30&lt;/Weight&gt; &lt;Percentage&gt;0.5&lt;/Percentage&gt; &lt;Ratio&gt;3.14159&lt;/Ratio&gt; &lt;Name&gt;apple&lt;/Name&gt; &lt;Blob&gt;VGFibGVhdQ==&lt;/Blob&gt; &lt;!-- # base64 of &quot;Tableau&quot; --&gt; &lt;OK&gt;true&lt;/OK&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; uint64 value = 3 [(tableau.field) = {name:&quot;Value&quot;}]; int64 weight = 4 [(tableau.field) = {name:&quot;Weight&quot;}]; float percentage = 5 [(tableau.field) = {name:&quot;Percentage&quot;}]; double ratio = 6 [(tableau.field) = {name:&quot;Ratio&quot;}]; string name = 7 [(tableau.field) = {name:&quot;Name&quot;}]; bytes blob = 8 [(tableau.field) = {name:&quot;Blob&quot;}]; bool ok = 9 [(tableau.field) = {name:&quot;OK&quot;}]; } ItemConf.json { &quot;id&quot;: 1, &quot;num&quot;: 10, &quot;value&quot;: &quot;20&quot;, &quot;weight&quot;: &quot;30&quot;, &quot;percentage&quot;: 0.5, &quot;ratio&quot;: 3.14159, &quot;name&quot;: &quot;apple&quot;, &quot;blob&quot;: &quot;VkdGaWJHVmhkUT09&quot;, &quot;ok&quot;: true } `}).add({id:28,href:"/docs/xml/",title:"XML",description:"XML guide.",content:""}).add({id:29,href:"/docs/xml/enum/",title:"Enum",description:"XML enum guide.",content:`Use predefined enum type # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;ID&gt;uint32&lt;/ID&gt; &lt;Type&gt;enum&lt;.FruitType&gt;&lt;/Type&gt; &lt;Desc&gt;string&lt;/Desc&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;ID&gt;1&lt;/ID&gt; &lt;Type&gt;FRUIT_TYPE_APPLE&lt;/Type&gt; &lt;Desc&gt;A kind of delicious fruit.&lt;/Desc&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.FruitType type = 2 [(tableau.field) = {name:&quot;Type&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } ItemConf.json { &quot;id&quot;: 1, &quot;type&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; } `}).add({id:30,href:"/docs/xml/struct/",title:"Struct",description:"XML struct guide.",content:`General struct # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;uint32&quot; StartTime=&quot;datetime&quot;&gt; &lt;Expiry&gt;duration&lt;/Expiry&gt; &lt;/Item&gt; &lt;Item2 ID=&quot;{OtherItem}uint32&quot; Name=&quot;string&quot; /&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;1&quot; StartTime=&quot;2024-10-01 10:10:10&quot;&gt; &lt;Expiry&gt;1h&lt;/Expiry&gt; &lt;/Item&gt; &lt;Item2 ID=&quot;1&quot; Name=&quot;gold&quot; /&gt; &lt;/ItemConf&gt; Tips
Well-known type: datetime → Well-known type: duration → Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; google.protobuf.Timestamp start_time = 2 [(tableau.field) = {name:&quot;StartTime&quot;}]; google.protobuf.Duration expiry = 3 [(tableau.field) = {name:&quot;Expiry&quot;}]; } OtherItem item_2 = 2 [(tableau.field) = {name:&quot;Item2&quot;}]; message OtherItem { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;startTime&quot;: &quot;2024-10-01T02:10:10Z&quot;, &quot;expiry&quot;: &quot;3600s&quot; }, &quot;item2&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;gold&quot; } } Reuse same-level struct # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;uint32&quot; StartTime=&quot;datetime&quot;&gt; &lt;Expiry&gt;duration&lt;/Expiry&gt; &lt;/Item&gt; &lt;NewItem @type=&quot;{Item}&quot; /&gt; &lt;OtherItem ID=&quot;{Item}uint32&quot; StartTime=&quot;datetime&quot;&gt; &lt;Expiry&gt;duration&lt;/Expiry&gt; &lt;/OtherItem&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;1&quot; StartTime=&quot;2024-10-01 10:10:10&quot;&gt; &lt;Expiry&gt;1h&lt;/Expiry&gt; &lt;/Item&gt; &lt;NewItem ID=&quot;2&quot; StartTime=&quot;2026-10-01 10:10:10&quot;&gt; &lt;Expiry&gt;2h&lt;/Expiry&gt; &lt;/NewItem&gt; &lt;OtherItem ID=&quot;3&quot; StartTime=&quot;2028-10-01 10:10:10&quot;&gt; &lt;Expiry&gt;3h&lt;/Expiry&gt; &lt;/OtherItem&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; google.protobuf.Timestamp start_time = 2 [(tableau.field) = {name:&quot;StartTime&quot;}]; google.protobuf.Duration expiry = 3 [(tableau.field) = {name:&quot;Expiry&quot;}]; } Item new_item = 2 [(tableau.field) = {name:&quot;NewItem&quot;}]; Item other_item = 3 [(tableau.field) = {name:&quot;OtherItem&quot;}]; } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;startTime&quot;: &quot;2024-10-01T02:10:10Z&quot;, &quot;expiry&quot;: &quot;3600s&quot; }, &quot;newItem&quot;: { &quot;id&quot;: 2, &quot;startTime&quot;: &quot;2026-10-01T02:10:10Z&quot;, &quot;expiry&quot;: &quot;7200s&quot; }, &quot;otherItem&quot;: { &quot;id&quot;: 3, &quot;startTime&quot;: &quot;2028-10-01T02:10:10Z&quot;, &quot;expiry&quot;: &quot;10800s&quot; } } Predefined struct # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item @type=&quot;{.Item}&quot; /&gt; &lt;Item2 ID=&quot;{.Item}int32&quot; Num=&quot;int32&quot; /&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;1&quot; Num=&quot;10&quot; /&gt; &lt;Item2 ID=&quot;2&quot; Num=&quot;20&quot; /&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; protoconf.Item item_2 = 2 [(tableau.field) = {name:&quot;Item2&quot;}]; } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 }, &quot;item2&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 } } Incell struct # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf Item=&quot;{uint32 ID, int32 Num}Item&quot; &gt; &lt;Item2&gt;{uint32 ID, int32 Num}OtherItem&lt;/Item2&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf Item=&quot;2, 20&quot;&gt; &lt;Item2&gt;1, 10&lt;/Item2&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item item = 1 [(tableau.field) = {name:&quot;Item&quot; span:SPAN_INNER_CELL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } OtherItem item_2 = 2 [(tableau.field) = {name:&quot;Item2&quot; span:SPAN_INNER_CELL}]; message OtherItem { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 }, &quot;item2&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } Incell predefined struct # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf Item=&quot;{.Item}&quot;&gt; &lt;Item2&gt;{.Item}&lt;/Item2&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf Item=&quot;2, 20&quot;&gt; &lt;Item2&gt;1, 10&lt;/Item2&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Item item = 1 [(tableau.field) = {name:&quot;Item&quot; span:SPAN_INNER_CELL}]; protoconf.Item item_2 = 2 [(tableau.field) = {name:&quot;Item2&quot; span:SPAN_INNER_CELL}]; } ItemConf.json { &quot;item&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 }, &quot;item2&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } `}).add({id:31,href:"/docs/xml/union/",title:"Union",description:"XML union guide.",content:`Union definition # For example, union type Target in common.proto is predefined as:
// Predefined union type. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: &quot;Type&quot; }]; oneof value { option (tableau.oneof) = { field: &quot;Field&quot; }; Pvp pvp = 1; // Binded to enum value 1: TYPE_PVP. Pve pve = 2; // Binded to enum value 2: TYPE_PVP. Story story = 3; // Binded to enum value 3: TYPE_STORY. Skill skill = 4; // Binded to enum value 4: TYPE_SKILL. } enum Type { TYPE_NIL = 0; TYPE_PVP = 1 [(tableau.evalue) = { name: &quot;PVP&quot; }]; TYPE_PVE = 2 [(tableau.evalue) = { name: &quot;PVE&quot; }]; TYPE_STORY = 3 [(tableau.evalue) = { name: &quot;Story&quot; }]; TYPE_SKILL = 4 [(tableau.evalue) = { name: &quot;Skill&quot; }]; } message Pvp { int32 type = 1; // scalar int64 damage = 2; // scalar repeated protoconf.FruitType types = 3; // incell enum list } message Pve { Mission mission = 1; // incell struct repeated int32 heros = 2; // incell list map&lt;int32, int64&gt; dungeons = 3; // incell map message Mission { int32 id = 1; uint32 level = 2; int64 damage = 3; } } message Story { protoconf.Item cost = 1; // incell predefined struct map&lt;int32, protoconf.FruitType&gt; fruits = 2; // incell map with value as enum type map&lt;int32, Flavor&gt; flavors = 3; // incell map with key as enum type message Flavor { protoconf.FruitFlavor key = 1 [(tableau.field) = { name: &quot;Key&quot; }]; int32 value = 2 [(tableau.field) = { name: &quot;Value&quot; }]; } } message Skill { int32 id = 1; // scalar int64 damage = 2; // scalar // no field tag 3 } } Predefined union # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Target @type=&quot;{.Target}&quot; /&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Target Type=&quot;PVP&quot; Field1=&quot;1&quot; Field2=&quot;10&quot; Field3=&quot;Apple,Orange,Banana&quot;/&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Target target = 1 [(tableau.field) = {name:&quot;Target&quot;}]; } ItemConf.json { &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVP&quot;, &quot;pvp&quot;: { &quot;type&quot;: 1, &quot;damage&quot;: &quot;10&quot;, &quot;types&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } } } Predefined incell union # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Target&gt;{.Target}|{form:FORM_TEXT}&lt;/Target&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Target&gt;type:TYPE_PVE pve:{mission:{id:1 level:100 damage:999} heros:1 heros:2 heros:3 dungeons:{key:1 value:10} dungeons:{key:2 value:20} dungeons:{key:3 value:30}}&lt;/Target&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Target target = 1 [(tableau.field) = {name:&quot;Target&quot; span:SPAN_INNER_CELL prop:{form:FORM_TEXT}}]; } ItemConf.json { &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVE&quot;, &quot;pve&quot;: { &quot;mission&quot;: { &quot;id&quot;: 1, &quot;level&quot;: 100, &quot;damage&quot;: &quot;999&quot; }, &quot;heros&quot;: [ 1, 2, 3 ], &quot;dungeons&quot;: { &quot;1&quot;: &quot;10&quot;, &quot;2&quot;: &quot;20&quot;, &quot;3&quot;: &quot;30&quot; } } } } Predefined union list # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Target @type=&quot;[.Target]&quot; /&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Target Type=&quot;Story&quot; Field1=&quot;1001,10&quot; Field2=&quot;1:Apple,2:Orange&quot; Field3=&quot;Fragrant:1,Sour:2&quot;/&gt; &lt;Target Type=&quot;Skill&quot; Field1=&quot;1&quot; Field2=&quot;2&quot;/&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Target target_list = 1 [(tableau.field) = {name:&quot;Target&quot;}]; } ItemConf.json { &quot;targetList&quot;: [ { &quot;type&quot;: &quot;TYPE_STORY&quot;, &quot;story&quot;: { &quot;cost&quot;: { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, &quot;fruits&quot;: { &quot;1&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;2&quot;: &quot;FRUIT_TYPE_ORANGE&quot; }, &quot;flavors&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: 1 }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: 2 } } } }, { &quot;type&quot;: &quot;TYPE_SKILL&quot;, &quot;skill&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;2&quot; } } ] } `}).add({id:32,href:"/docs/xml/list/",title:"List",description:"XML list guide.",content:`Scalar list # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item&gt;[int32]&lt;/Item&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item&gt;1&lt;/Item&gt; &lt;Item&gt;2&lt;/Item&gt; &lt;Item&gt;3&lt;/Item&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated int32 item_list = 1 [(tableau.field) = {name:&quot;Item&quot;}]; } ItemConf.json { &quot;itemList&quot;: [ 1, 2, 3 ] } Enum list # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Fruit&gt;[enum&lt;.FruitType&gt;]&lt;/Fruit&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Fruit&gt;FRUIT_TYPE_APPLE&lt;/Fruit&gt; &lt;Fruit&gt;FRUIT_TYPE_ORANGE&lt;/Fruit&gt; &lt;Fruit&gt;FRUIT_TYPE_BANANA&lt;/Fruit&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType fruit_list = 1 [(tableau.field) = {name:&quot;Fruit&quot;}]; } ItemConf.json { &quot;fruitList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } Incell scalar list # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item&gt;[]int32&lt;/Item&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item&gt;1, 2, 3&lt;/Item&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated int32 item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;itemList&quot;: [ 1, 2, 3 ] } Incell enum list # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Fruit&gt;[]enum&lt;.FruitType&gt;&lt;/Fruit&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Fruit&gt;FRUIT_TYPE_APPLE, FRUIT_TYPE_ORANGE, FRUIT_TYPE_BANANA&lt;/Fruit&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType fruit_list = 1 [(tableau.field) = {name:&quot;Fruit&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;fruitList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } Struct list # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;[Item]uint32&quot; Num=&quot;int32&quot;/&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;1&quot; Num=&quot;10&quot;/&gt; &lt;Item ID=&quot;2&quot; Num=&quot;20&quot;/&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ] } Predefined struct list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item @type=&quot;[.Item]&quot;/&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item ID=&quot;1&quot; Num=&quot;10&quot;/&gt; &lt;Item ID=&quot;2&quot; Num=&quot;20&quot;/&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot;}]; } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ] } List in list # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Country Country=&quot;[Country]string&quot; Desc=&quot;string&quot;&gt; &lt;Item Name=&quot;[Item]string&quot; Num=&quot;int32&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Country Country=&quot;USA&quot; Desc=&quot;A country in North America.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;10&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;20&quot; /&gt; &lt;/Country&gt; &lt;Country Country=&quot;China&quot; Desc=&quot;A country in East Asia.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;100&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;200&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Country country_list = 1 [(tableau.field) = {name:&quot;Country&quot;}]; message Country { string country = 1 [(tableau.field) = {name:&quot;Country&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; repeated Item item_list = 3 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countryList&quot;: [ { &quot;country&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;itemList&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } ] }, { &quot;country&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;itemList&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } ] } ] } Map in list # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Country Country=&quot;[Country]string&quot; Desc=&quot;string&quot;&gt; &lt;Item Name=&quot;map&lt;string, Item&gt;&quot; Num=&quot;int32&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Country Country=&quot;USA&quot; Desc=&quot;A country in North America.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;10&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;20&quot; /&gt; &lt;/Country&gt; &lt;Country Country=&quot;China&quot; Desc=&quot;A country in East Asia.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;100&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;200&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Country country_list = 1 [(tableau.field) = {name:&quot;Country&quot;}]; message Country { string country = 1 [(tableau.field) = {name:&quot;Country&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; map&lt;string, Item&gt; item_map = 3 [(tableau.field) = {name:&quot;Item&quot; key:&quot;Name&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countryList&quot;: [ { &quot;country&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;itemMap&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } } }, { &quot;country&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;itemMap&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } } } ] } `}).add({id:33,href:"/docs/xml/map/",title:"Map",description:"XML map guide.",content:`Incell scalar map # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item&gt;map&lt;uint32, string&gt;&lt;/Item&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item&gt;1:dog,2:bird,3:cat&lt;/Item&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, string&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: &quot;dog&quot;, &quot;2&quot;: &quot;bird&quot;, &quot;3&quot;: &quot;cat&quot; } } Incell enum map # Enum types Enum type FruitType and FruitFlavor in common.proto are predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } enum FruitFlavor { FRUIT_FLAVOR_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_FLAVOR_FRAGRANT = 1 [(tableau.evalue).name = &quot;Fragrant&quot;]; FRUIT_FLAVOR_SOUR = 2 [(tableau.evalue).name = &quot;Sour&quot;]; FRUIT_FLAVOR_SWEET = 3 [(tableau.evalue).name = &quot;Sweet&quot;]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item&gt;map&lt;enum&lt;.FruitType&gt;, enum&lt;.FruitFlavor&gt;&gt;&lt;/Item&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item&gt;FRUIT_TYPE_APPLE:FRUIT_FLAVOR_FRAGRANT, FRUIT_TYPE_ORANGE:FRUIT_FLAVOR_SOUR&lt;/Item&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, ItemValue&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;@key&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; message ItemValue { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;@key&quot;}]; protoconf.FruitFlavor value = 2 [(tableau.field) = {name:&quot;@value&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot; }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_SOUR&quot; } } } Struct map # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item Name=&quot;map&lt;string, Item&gt;&quot; Num=&quot;int32&quot; /&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;10&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;20&quot; /&gt; &lt;Item Name=&quot;banana&quot; Num=&quot;30&quot; /&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;string, Item&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;Name&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } ItemConf.json { &quot;itemMap&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;banana&quot;: { &quot;name&quot;: &quot;banana&quot;, &quot;num&quot;: 30 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } } } Enum key struct map # Enum type FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Item Key=&quot;map&lt;enum&lt;.FruitType&gt;, EnumItem&gt;&quot; Name=&quot;string&quot; Num=&quot;int32&quot; /&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Item Key=&quot;FRUIT_TYPE_APPLE&quot; Name=&quot;apple&quot; Num=&quot;10&quot; /&gt; &lt;Item Key=&quot;FRUIT_TYPE_ORANGE&quot; Name=&quot;orange&quot; Num=&quot;20&quot; /&gt; &lt;Item Key=&quot;FRUIT_TYPE_BANANA&quot; Name=&quot;banana&quot; Num=&quot;30&quot; /&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, EnumItem&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;Key&quot;}]; message EnumItem { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;Key&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 3 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 }, &quot;4&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_BANANA&quot;, &quot;name&quot;: &quot;banana&quot;, &quot;num&quot;: 30 } } } List in map # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Country Key=&quot;map&lt;string, Country&gt;&quot; Desc=&quot;string&quot;&gt; &lt;Item Name=&quot;[Item]string&quot; Num=&quot;int32&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Country Key=&quot;USA&quot; Desc=&quot;A country in North America.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;10&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;20&quot; /&gt; &lt;/Country&gt; &lt;Country Key=&quot;China&quot; Desc=&quot;A country in East Asia.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;100&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;200&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;string, Country&gt; country_map = 1 [(tableau.field) = {name:&quot;Country&quot; key:&quot;Key&quot;}]; message Country { string key = 1 [(tableau.field) = {name:&quot;Key&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; repeated Item item_list = 3 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countryMap&quot;: { &quot;China&quot;: { &quot;key&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;itemList&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } ] }, &quot;USA&quot;: { &quot;key&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;itemList&quot;: [ { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } ] } } } Map in map # A worksheet ItemConf in HelloWorld.xml:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;ItemConf&quot; /&gt; &lt;/@TABLEAU&gt; &lt;ItemConf&gt; &lt;Country Key=&quot;map&lt;string, Country&gt;&quot; Desc=&quot;string&quot;&gt; &lt;Item Name=&quot;map&lt;string, Item&gt;&quot; Num=&quot;int32&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; --&gt; &lt;ItemConf&gt; &lt;Country Key=&quot;USA&quot; Desc=&quot;A country in North America.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;10&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;20&quot; /&gt; &lt;/Country&gt; &lt;Country Key=&quot;China&quot; Desc=&quot;A country in East Asia.&quot;&gt; &lt;Item Name=&quot;apple&quot; Num=&quot;100&quot; /&gt; &lt;Item Name=&quot;orange&quot; Num=&quot;200&quot; /&gt; &lt;/Country&gt; &lt;/ItemConf&gt; Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xml&quot;}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;string, Country&gt; country_map = 1 [(tableau.field) = {name:&quot;Country&quot; key:&quot;Key&quot;}]; message Country { string key = 1 [(tableau.field) = {name:&quot;Key&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; map&lt;string, Item&gt; item_map = 3 [(tableau.field) = {name:&quot;Item&quot; key:&quot;Name&quot;}]; message Item { string name = 1 [(tableau.field) = {name:&quot;Name&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;countryMap&quot;: { &quot;China&quot;: { &quot;key&quot;: &quot;China&quot;, &quot;desc&quot;: &quot;A country in East Asia.&quot;, &quot;itemMap&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 100 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 200 } } }, &quot;USA&quot;: { &quot;key&quot;: &quot;USA&quot;, &quot;desc&quot;: &quot;A country in North America.&quot;, &quot;itemMap&quot;: { &quot;apple&quot;: { &quot;name&quot;: &quot;apple&quot;, &quot;num&quot;: 10 }, &quot;orange&quot;: { &quot;name&quot;: &quot;orange&quot;, &quot;num&quot;: 20 } } } } } `}).add({id:34,href:"/docs/xml/metasheet/",title:"Metasheet",description:"XML metasheet @TABLEAU guide.",content:`What is a metasheet in XML? # A metasheet is a comment block normally written at the beginning of an XML file, which must begin with keyword @TABLEAU and define types of attributes of nodes in the following lines. e.g.:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- &lt;@TABLEAU&gt; &lt;Item Sheet=&quot;Sheet1&quot; Alias=&quot;ItemConf&quot; OrderedMap=&quot;true&quot; Index=&quot;(ID,Type)@Item&quot; /&gt; &lt;Item Sheet=&quot;Sheet2&quot; Alias=&quot;FruitConf&quot; Sep=&quot;,&quot; Subsep=&quot;:&quot; FieldPresence=“true” /&gt; &lt;/@TABLEAU&gt; &lt;Sheet1&gt; &lt;ID&gt;uint32&lt;/ID&gt; &lt;Num&gt;int32&lt;/Num&gt; &lt;Value&gt;uint64&lt;/Value&gt; &lt;Weight&gt;int64&lt;/Weight&gt; &lt;Percentage&gt;float&lt;/Percentage&gt; &lt;Ratio&gt;double&lt;/Ratio&gt; &lt;Name&gt;string&lt;/Name&gt; &lt;Blob&gt;bytes&lt;/Blob&gt; &lt;OK&gt;bool&lt;/OK&gt; &lt;/Sheet1&gt; &lt;Sheet2&gt; &lt;Countries Key=&quot;map&lt;string, Country&gt;&quot; Desc=&quot;string&quot;&gt; &lt;Items Name=&quot;map&lt;string, Item&gt;&quot; Num=&quot;int32&quot; /&gt; &lt;/Countries&gt; &lt;/Sheet2&gt; --&gt; Without metasheet # If one XML file has no metasheet (In other words, has no comment block beginning with @TABLEAU), no protobuf and json will be generated.
`}).add({id:35,href:"/docs/csv/",title:"CSV",description:"CSV guide.",content:""}).add({id:36,href:"/docs/csv/overview/",title:"Overview",description:"CSV overview.",content:`Concepts # As Tableau recognizes the pattern &lt;BookName&gt;#&lt;SheetName&gt;.csv, so a CSV workbook (Glob Pattern) &lt;BookName&gt;#*.csv is composed of multiple CSV worksheets (files) in the same directory.
E.g.:
A CSV workbook HelloWorld#*.csv is composed of three CSV worksheets:
Worksheet Item: HelloWorld#Item.csv Worksheet Activity: HelloWorld#Activity.csv Worksheet @TABLEAU: HelloWorld#@TABLEAU.csv Guide # As the CSV worksheet is same as the Excel worksheet, so just read Excel Guide →
`}).add({id:37,href:"/docs/excel/",title:"Excel",description:"Excel guide.",content:""}).add({id:38,href:"/docs/excel/scalar/",title:"Scalar",description:"Excel scalar guide.",content:`Scalar # A worksheet Apple in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Apple @TABLEAU ID Name Desc uint32 string string Item&rsquo;s ID Item&rsquo;s Name Item&rsquo;s Description 1 Apple A kind of delicious fruit. In this worksheet, three scalar fields are defined:
ID: uint32 Name: string Desc: string Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message Apple { option (tableau.worksheet) = {name:&quot;Apple&quot;}; uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } Apple.json { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; } Note # Scalar type is usually used to define fields of struct type. Struct →
`}).add({id:39,href:"/docs/excel/enum/",title:"Enum",description:"Excel enum guide.",content:`Use predefined enum type # The basic enum guide, please go to read Enum →
For example, enum type FruitType in common.proto is defined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 2 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Type map&lt;uint32, Item&gt; enum&lt;.FruitType&gt; Item&rsquo;s ID Fruit&rsquo;s type 1 1 2 Orange 3 FRUIT_TYPE_BANANA Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; FruitType type = 2 [(tableau.field) = {name:&quot;Type&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;type&quot;: &quot;FRUIT_TYPE_APPLE&quot; }, &quot;2&quot;: { &quot;id&quot;: 3, &quot;type&quot;: &quot;FRUIT_TYPE_ORANGE&quot; } &quot;3&quot;: { &quot;id&quot;: 2, &quot;type&quot;: &quot;FRUIT_TYPE_BANANA&quot; }, } } Define enum type in sheet # There are two kinds of Mode (in metasheet @TABLEAU) to define enum types in a sheet:
MODE_ENUM_TYPE: define single enum type in a sheet. MODE_ENUM_TYPE_MULTI: define multiple enum types in a sheet. Single enum type in sheet # You should specify Mode option to MODE_ENUM_TYPE in metasheet @TABLEAU.
For example, a worksheet ItemType in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemType @TABLEAU Name Alias ITEM_TYPE_FRUIT Fruit ITEM_TYPE_EQUIP Equip ITEM_TYPE_BOX Box Sheet Mode ItemType MODE_ENUM_TYPE Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; // Generated from sheet: ItemType. enum ItemType { ITEM_TYPE_INVALID = 0; ITEM_TYPE_FRUIT = 1 [(tableau.evalue).name = &quot;Fruit&quot;]; ITEM_TYPE_EQUIP = 2 [(tableau.evalue).name = &quot;Equip&quot;]; ITEM_TYPE_BOX = 3 [(tableau.evalue).name = &quot;Box&quot;]; } Multiple enum types in sheet # A block defines an enum type, and it is a series of contiguous non-empty rows. So different blocks are seperated by one or more empty rows.
You should specify Mode option to MODE_ENUM_TYPE_MULTI in metasheet @TABLEAU.
For example, a worksheet ItemType in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemType @TABLEAU CatType CatType note Number Name Alias 1 CAT_TYPE_RAGDOLL Ragdoll 2 CAT_TYPE_PERSIAN Persian 3 CAT_TYPE_SPHYNX Sphynx DogType DogType note Number Name Alias 1 DOG_TYPE_POODLE Poodle 2 DOG_TYPE_BULLDOG Bulldog 3 DOG_TYPE_DACHSHUND Dachshund BirdType BirdType note Number Name Alias 1 CANARY Canary 2 WOODPECKER Woodpecker 3 OWL Owl Sheet Mode ItemType MODE_ENUM_TYPE_MULTI Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; // CatType note enum CatType { option (tableau.etype) = {name:&quot;EnumType&quot; note:&quot;CatType note&quot;}; CAT_TYPE_INVALID = 0; CAT_TYPE_RAGDOLL = 1 [(tableau.evalue).name = &quot;Ragdoll&quot;]; // Ragdoll CAT_TYPE_PERSIAN = 2 [(tableau.evalue).name = &quot;Persian&quot;]; // Persian CAT_TYPE_SPHYNX = 3 [(tableau.evalue).name = &quot;Sphynx&quot;]; // Sphynx } // DogType note enum DogType { option (tableau.etype) = {name:&quot;EnumType&quot; note:&quot;DogType note&quot;}; DOG_TYPE_INVALID = 0; DOG_TYPE_POODLE = 1 [(tableau.evalue).name = &quot;Poodle&quot;]; // Poodle DOG_TYPE_BULLDOG = 2 [(tableau.evalue).name = &quot;Bulldog&quot;]; // Bulldog DOG_TYPE_DACHSHUND = 3 [(tableau.evalue).name = &quot;Dachshund&quot;]; // Dachshund } // BirdType note enum BirdType { option (tableau.etype) = {name:&quot;EnumType&quot; note:&quot;BirdType note&quot;}; BIRD_TYPE_INVALID = 0; BIRD_TYPE_CANARY = 1 [(tableau.evalue).name = &quot;Canary&quot;]; // Canary BIRD_TYPE_WOODPECKER = 2 [(tableau.evalue).name = &quot;Woodpecker&quot;]; // Woodpecker BIRD_TYPE_OWL = 3 [(tableau.evalue).name = &quot;Owl&quot;]; // Owl } Specify Number column # In Number column, you can specify custom unique enum value number.
ⓘ If you not specify default enum value "0", it will be auto generated. And the default enum value name pattern is: "{ENUM_TYPE}_INVALID". For example, a worksheet ItemType in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemType @TABLEAU Number Name Alias 0 ITEM_TYPE_UNKNOWN Unknown 10 ITEM_TYPE_FRUIT Fruit 20 ITEM_TYPE_EQUIP Equip 30 ITEM_TYPE_BOX Box Sheet Mode ItemType MODE_ENUM_TYPE Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; // Generated from sheet: ItemType. enum ItemType { ITEM_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; ITEM_TYPE_FRUIT = 10 [(tableau.evalue).name = &quot;Fruit&quot;]; ITEM_TYPE_EQUIP = 20 [(tableau.evalue).name = &quot;Equip&quot;]; ITEM_TYPE_BOX = 30 [(tableau.evalue).name = &quot;Box&quot;]; } Define and use enum type in sheet # For example, two worksheets ItemType and ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemType ItemConf @TABLEAU Number Name Alias 1 ITEM_TYPE_FRUIT Fruit 2 ITEM_TYPE_EQUIP Equip 3 ITEM_TYPE_BOX Box ID Type Name Price map&lt;int32, Item&gt; enum&lt;.ItemType&gt; string int32 Item’s ID Item’s type Item’s name Item’s price 1 Fruit Apple 40 2 Fruit Orange 20 3 Equip Sword 10 Sheet Mode ItemType MODE_ENUM_TYPE ItemConf Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; // Generated from sheet: ItemType. enum ItemType { ITEM_TYPE_INVALID = 0; ITEM_TYPE_FRUIT = 1 [(tableau.evalue).name = &quot;Fruit&quot;]; ITEM_TYPE_EQUIP = 2 [(tableau.evalue).name = &quot;Equip&quot;]; ITEM_TYPE_BOX = 3 [(tableau.evalue).name = &quot;Box&quot;]; } message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.ItemType type = 2 [(tableau.field) = {name:&quot;Type&quot;}]; string name = 3 [(tableau.field) = {name:&quot;Name&quot;}]; int32 price = 4 [(tableau.field) = {name:&quot;Price&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;type&quot;: &quot;ITEM_TYPE_FRUIT&quot;, &quot;name&quot;: &quot;Apple&quot;, &quot;price&quot;: 40 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;type&quot;: &quot;ITEM_TYPE_FRUIT&quot;, &quot;name&quot;: &quot;Orange&quot;, &quot;price&quot;: 20 }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;type&quot;: &quot;ITEM_TYPE_EQUIP&quot;, &quot;name&quot;: &quot;Sword&quot;, &quot;price&quot;: 10 } } } `}).add({id:40,href:"/docs/excel/struct/",title:"Struct",description:"Excel struct guide.",content:`Cross-cell struct # Syntax: &lt;StructType&gt;ColumnType.
Each column name should be prefixed with the same struct variable name, which is just the same as struct type name by default.
For example, a worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU PropertyID PropertyName PropertyDesc {Property}int32 string string Property&rsquo;s ID Property&rsquo;s Name Property&rsquo;s Description 1 Orange A kind of sour fruit. Note that each column name in ItemConf is prefixed with struct variable name Property which is same as struct type name.
Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Property property = 1 [(tableau.field) = {name:&quot;Property&quot;}]; message Property { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } } ItemConf.json { &quot;property&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Orange&quot;, &quot;desc&quot;: &quot;A kind of sour fruit.&quot; } } Note # Cross-cell struct is usually used together with:
cross-cell horizontal/vertical map, as map value type. Map → cross-cell horizontal/vertical list, as list element type. List → Incell struct # Each field type of the struct should be scalar type.
For example, a worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Prop map&lt;int32, Item&gt; {int32 ID,string Name,string Desc}Property Item&rsquo;s ID Item&rsquo;s property. 1 1,Orange,A good fruit. 2 2,Apple 3 3 The Property column&rsquo;s type is in-cell struct {int32 ID,string Name,string Desc}Property.
Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; Property prop = 2 [(tableau.field) = {name:&quot;Prop&quot; span:SPAN_INNER_CELL}]; message Property { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;prop&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;prop&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;desc&quot;: &quot;&quot; } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;prop&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;&quot;, &quot;desc&quot;: &quot;&quot; } } } } Predefined struct # For example, struct type Prop in common.proto is defined as:
message Prop { int32 id = 1 [(tableau.field).name = &quot;ID&quot;]; int32 value = 2 [(tableau.field).name = &quot;Value&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Prop1ID Prop1Value Prop2ID Prop2Value map&lt;uint32, Item&gt; [.Prop]int32 int32 int32 int32 Item&rsquo;s ID Prop1&rsquo;s ID Prop1&rsquo;s value Prop2&rsquo;s ID Prop2&rsquo;s value 1 1 100 2 200 2 3 300 4 400 3 5 500 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; repeated Prop prop_list = 2 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_HORIZONTAL}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;propList&quot;: [ { &quot;id&quot;: 1, &quot;value&quot;: 100 }, { &quot;id&quot;: 2, &quot;value&quot;: 200 } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;propList&quot;: [ { &quot;id&quot;: 3, &quot;value&quot;: 300 }, { &quot;id&quot;: 4, &quot;value&quot;: 400 } ] }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;propList&quot;: [ { &quot;id&quot;: 5, &quot;value&quot;: 500 } ] } } } Predefined incell struct # Each field type of the predefined struct should be scalar type.
For example, Property in common.proto is predefined as:
message Property { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Prop map&lt;uint32, Item&gt; {.Property} Item&rsquo;s ID Item&rsquo;s property. 1 1,Orange,A good fruit. 2 2,Apple 3 3 The Prop column&rsquo;s type is a predefined struct Property.
Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.Property prop = 2 [(tableau.field) = {name:&quot;Prop&quot; span:SPAN_INNER_CELL}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;prop&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;prop&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;desc&quot;: &quot;&quot; } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;prop&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;&quot;, &quot;desc&quot;: &quot;&quot; } } } } Custom named struct # By default, struct variable name is same as struct type name, but you can specify a different struct variable name. Custom named struct is mainly used to identify name prefix of continuous cells in name row, when the tableau (protogen) can&rsquo;t auto-recognize the variable name.
Syntax: just after struct type name, use parentheses () to specify struct variable name: VariableType(VariableName).
For example, Item is predefined:
message Item { int32 id = 1 [(tableau.field).name = &quot;ID&quot;]; int32 num = 2 [(tableau.field).name = &quot;Num&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU RewardItemID RewardItemNum CostItemID CostItemNum PredefinedItemID PredefinedItemNum {Item(RewardItem)}int32 int32 {Item(CostItem)}int32 int32 {.Item(PredefinedItem)}int32 int32 Item&rsquo;s ID Item&rsquo;s ID Cost&rsquo;s ID Cost&rsquo;s ID Predefined item&rsquo;s ID Predefined item&rsquo;s ID 1 100 2 200 10 20 Details: In type cell {Item(RewardItem)}int32, RewardItem is the custom variable name of new defined struct Item. And in type cell {Item(CostItem)}int32, CostItem is the custom variable name of just already defined struct Item in the same scope. Finally, in type cell {.Item(PredefinedItem)}int32, PredefinedItem is the custom variable name of predefined struct Item at global (at the same protobuf package).
Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Item reward_item = 1 [(tableau.field) = {name:&quot;RewardItem&quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } Item cost_item = 2 [(tableau.field) = {name:&quot;CostItem&quot;}]; protoconf.Item predefined_item = 3 [(tableau.field) = {name:&quot;PredefinedItem&quot;}]; } ItemConf.json { &quot;rewardItem&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 100 }, &quot;costItem&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 200 }, &quot;predefinedItem&quot;: { &quot;id&quot;: 10, &quot;num&quot;: 20 } } Advanced predefined incell struct # In some situations, you may want to configure any complex struct in a cell, so tableau support two kinds of protobuf serialized formats: text format, and JSON format.
Syntax: in field prop, specify form option as FORM_TEXT or FORM_JSON.
For example, Transform is predefined as:
message Transform { Vector3 position = 1; Vector3 rotation = 2; Vector3 scale = 3; } message Vector3 { float x = 1; float y = 2; float z = 3; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Transform1 Transform2 {.Transform}|{form:FORM_TEXT} {.Transform}|{form:FORM_JSON} Box&rsquo;s transform1 Box&rsquo;s transform2 position:{x:1 y:2 z:3} rotation:{x:4 y:5 z:6} scale:{x:7 y:8 z:9} {&ldquo;position&rdquo;:{&ldquo;x&rdquo;:1, &ldquo;y&rdquo;:2, &ldquo;z&rdquo;:3}, &ldquo;rotation&rdquo;:{&ldquo;x&rdquo;:4, &ldquo;y&rdquo;:5, &ldquo;z&rdquo;:6}, &ldquo;scale&rdquo;:{&ldquo;x&rdquo;:7, &ldquo;y&rdquo;:8, &ldquo;z&rdquo;:9}} Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; protoconf.Transform transform_1 = 1 [(tableau.field) = {name:&quot;Transform1&quot; span:SPAN_INNER_CELL prop{form:FORM_TEXT}}]; protoconf.Transform transform_2 = 2 [(tableau.field) = {name:&quot;Transform2&quot; span:SPAN_INNER_CELL prop:{form:FORM_JSON}}]; } ItemConf.json { &quot;transform1&quot;: { &quot;position&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 }, &quot;rotation&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, &quot;z&quot;: 6 }, &quot;scale&quot;: { &quot;x&quot;: 7, &quot;y&quot;: 8, &quot;z&quot;: 9 } }, &quot;transform2&quot;: { &quot;position&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 }, &quot;rotation&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, &quot;z&quot;: 6 }, &quot;scale&quot;: { &quot;x&quot;: 7, &quot;y&quot;: 8, &quot;z&quot;: 9 } } } Define struct type in sheet # There are two kinds of Mode (in metasheet @TABLEAU) to define struct types in a sheet:
MODE_STRUCT_TYPE: define single struct type in a sheet. MODE_STRUCT_TYPE_MULTI: define multiple struct types in a sheet. Single struct type in sheet # You should specify Mode option to MODE_STRUCT_TYPE in metasheet @TABLEAU.
For example, a worksheet Item in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Item @TABLEAU Name Type ID uint32 Num int32 FruitType enum&lt;.FruitType&gt; Feature []int32 Prop map&lt;int32, string&gt; Detail {enum&lt;.ItemType&gt; Type, string Name, string Desc}Detail Sheet Mode Item MODE_STRUCT_TYPE Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; // Generated from sheet: Item. message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; protoconf.FruitType fruit_type = 3 [(tableau.field) = {name:&quot;FruitType&quot;}]; repeated int32 feature_list = 4 [(tableau.field) = {name:&quot;Feature&quot; layout:LAYOUT_INCELL}]; map&lt;int32, string&gt; prop_map = 5 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_INCELL}]; Detail detail = 6 [(tableau.field) = {name:&quot;Detail&quot; span:SPAN_INNER_CELL}]; message Detail { protoconf.ItemType type = 1 [(tableau.field) = {name:&quot;Type&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } } Multiple struct types in sheet # A block defines a struct type, and it is a series of contiguous non-empty rows. So different blocks are seperated by one or more empty rows.
You should specify Mode option to MODE_STRUCT_TYPE_MULTI in metasheet @TABLEAU.
For example, a worksheet Item in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Item @TABLEAU Tree Tree note Name Type ID uint32 Num int32 Pet Pet note Name Type Kind int32 Tip []string FruitShop FruitShop note Name Type FruitType enum&lt;.FruitType&gt; Prop map&lt;int32, string&gt; Sheet Mode Item MODE_STRUCT_TYPE_MULTI Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; message Tree { option (tableau.struct) = {name:&quot;StructType&quot; note:&quot;Tree note&quot;}; uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } message Pet { option (tableau.struct) = {name:&quot;StructType&quot; note:&quot;Pet note&quot;}; int32 kind = 1 [(tableau.field) = {name:&quot;Kind&quot;}]; repeated string tip_list = 2 [(tableau.field) = {name:&quot;Tip&quot; layout:LAYOUT_INCELL}]; } message FruitShop { option (tableau.struct) = {name:&quot;StructType&quot; note:&quot;FruitShop note&quot;}; protoconf.FruitType fruit_type = 1 [(tableau.field) = {name:&quot;FruitType&quot;}]; map&lt;int32, string&gt; prop_map = 2 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_INCELL}]; } Specify Number column # In Number column, you can specify custom unique field number.
For example, a worksheet Item in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Item @TABLEAU Number Name Type 1 ID uint32 20 Num int32 30 FruitType enum&lt;.FruitType&gt; Sheet Mode Item MODE_STRUCT_TYPE Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; // Generated from sheet: Item. message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 20 [(tableau.field) = {name:&quot;Num&quot;}]; protoconf.FruitType fruit_type = 30 [(tableau.field) = {name:&quot;FruitType&quot;}]; } `}).add({id:41,href:"/docs/excel/union/",title:"Union",description:"Excel union guide.",content:`Theory # In protoconf, union type means the tagged union: a data structure used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a tag field explicitly indicates which one is in use. More details can be learned from wikipedia Tagged union.
Tagged union in different programming languages:
C++: std::variant. Rust: Defining an Enum. Tableau use protobuf message to bundle enum type and oneof type together to implement tagged union. By default, each enum value (&gt;0) is bound to a field with the same tag number of oneof type.
Union definition # For example, union type Target in common.proto is predefined as:
// Predefined union type. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: &quot;Type&quot; }]; oneof value { option (tableau.oneof) = { field: &quot;Field&quot; }; Pvp pvp = 1; // Bound to enum value 1: TYPE_PVP. Pve pve = 2; // Bound to enum value 2: TYPE_PVP. Story story = 3; // Bound to enum value 3: TYPE_STORY. Skill skill = 4; // Bound to enum value 4: TYPE_SKILL. } enum Type { TYPE_NIL = 0; TYPE_PVP = 1 [(tableau.evalue) = { name: &quot;PVP&quot; }]; TYPE_PVE = 2 [(tableau.evalue) = { name: &quot;PVE&quot; }]; TYPE_STORY = 3 [(tableau.evalue) = { name: &quot;Story&quot; }]; TYPE_SKILL = 4 [(tableau.evalue) = { name: &quot;Skill&quot; }]; } message Pvp { int32 type = 1; // scalar int64 damage = 2; // scalar repeated protoconf.FruitType types = 3; // incell enum list } message Pve { Mission mission = 1; // incell struct repeated int32 heros = 2; // incell list map&lt;int32, int64&gt; dungeons = 3; // incell map message Mission { int32 id = 1; uint32 level = 2; int64 damage = 3; } } message Story { protoconf.Item cost = 1; // incell predefined struct map&lt;int32, protoconf.FruitType&gt; fruits = 2; // incell map with value as enum type map&lt;int32, Flavor&gt; flavors = 3; // incell map with key as enum type message Flavor { protoconf.FruitFlavor key = 1 [(tableau.field) = { name: &quot;Key&quot; }]; int32 value = 2 [(tableau.field) = { name: &quot;Value&quot; }]; } } message Skill { int32 id = 1; // scalar int64 damage = 2; // scalar // no field tag 3 } } Predefined union in list # Based on predefined union type Target.
A worksheet TaskConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Apple @TABLEAU ID Target1Type Target1Field1 Target1Field2 Target1Field3 Target2Type Target2Field1 Target2Field2 Target2Field3 map&lt;int32, Task&gt; [.Target]enum&lt;.Target.Type&gt; union union union enum&lt;.Target.Type&gt; union union union ID Target1&rsquo;s type Target1&rsquo;s field1 Target1&rsquo;s field2 Target1&rsquo;s field3 Target2&rsquo;s type Target2&rsquo;s field1 Target2&rsquo;s field2 Target2&rsquo;s field3 1 PVP 1 10 Apple,Orange,Banana PVE 1,100,999 1,2,3 1:10,2:20,3:30 2 Story 1001,10 1:Apple,2:Orange Fragrant:1,Sour:2 Skill 1 2 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message TaskConf { option (tableau.worksheet) = {name:&quot;TaskConf&quot;}; map&lt;int32, Task&gt; task_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Task { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; repeated protoconf.Target target_list = 2 [(tableau.field) = {name:&quot;Target&quot; layout:LAYOUT_HORIZONTAL}]; } } TaskConf.json { &quot;taskMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;targetList&quot;: [ { &quot;type&quot;: &quot;TYPE_PVP&quot;, &quot;pvp&quot;: { &quot;type&quot;: 1, &quot;damage&quot;: &quot;10&quot;, &quot;types&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } }, { &quot;type&quot;: &quot;TYPE_PVE&quot;, &quot;pve&quot;: { &quot;mission&quot;: { &quot;id&quot;: 1, &quot;level&quot;: 100, &quot;damage&quot;: &quot;999&quot; }, &quot;heros&quot;: [ 1, 2, 3 ], &quot;dungeons&quot;: { &quot;1&quot;: &quot;10&quot;, &quot;2&quot;: &quot;20&quot;, &quot;3&quot;: &quot;30&quot; } } } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;targetList&quot;: [ { &quot;type&quot;: &quot;TYPE_STORY&quot;, &quot;story&quot;: { &quot;cost&quot;: { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, &quot;fruits&quot;: { &quot;1&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;2&quot;: &quot;FRUIT_TYPE_ORANGE&quot; }, &quot;flavors&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: 1 }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: 2 } } } }, { &quot;type&quot;: &quot;TYPE_SKILL&quot;, &quot;skill&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;2&quot; } } ] } } } TaskConf.txt task_map: { key: 1 value: { id: 1 target_list: { type: TYPE_PVP pvp: { type: 1 damage: 10 types: FRUIT_TYPE_APPLE types: FRUIT_TYPE_ORANGE types: FRUIT_TYPE_BANANA } } target_list: { type: TYPE_PVE pve: { mission: { id: 1 level: 100 damage: 999 } heros: 1 heros: 2 heros: 3 dungeons: { key: 1 value: 10 } dungeons: { key: 2 value: 20 } dungeons: { key: 3 value: 30 } } } } } task_map: { key: 2 value: { id: 2 target_list: { type: TYPE_STORY story: { cost: { id: 1001 num: 10 } fruits: { key: 1 value: FRUIT_TYPE_APPLE } fruits: { key: 2 value: FRUIT_TYPE_ORANGE } flavors: { key: 1 value: { key: FRUIT_FLAVOR_FRAGRANT value: 1 } } flavors: { key: 2 value: { key: FRUIT_FLAVOR_SOUR value: 2 } } } } target_list: { type: TYPE_SKILL skill: { id: 1 damage: 2 } } } } Predefined union in map # Based on predefined union type Target.
A worksheet TaskConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Apple @TABLEAU ID TargetType TargetField1 TargetField2 TargetField3 Progress map&lt;int32, Task&gt; {.Target}enum&lt;.Target.Type&gt; union union union int32 ID Target&rsquo;s type Target&rsquo;s field1 Target&rsquo;s field2 Target&rsquo;s field3 Progress 1 PVP 1 10 Apple,Orange,Banana 3 2 PVE 1,100,999 1,2,3 1:10,2:20,3:30 10 3 Story 1001,10 1:Apple,2:Orange Fragrant:1,Sour:2 10 4 Skill 1 2 8 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message TaskConf { option (tableau.worksheet) = {name:&quot;TaskConf&quot;}; map&lt;int32, Task&gt; task_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Task { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.Target target = 2 [(tableau.field) = {name:&quot;Target&quot;}]; int32 progress = 3 [(tableau.field) = {name:&quot;Progress&quot;}]; } } TaskConf.json { &quot;taskMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVP&quot;, &quot;pvp&quot;: { &quot;type&quot;: 1, &quot;damage&quot;: &quot;10&quot;, &quot;types&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } }, &quot;progress&quot;: 3 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVE&quot;, &quot;pve&quot;: { &quot;mission&quot;: { &quot;id&quot;: 1, &quot;level&quot;: 100, &quot;damage&quot;: &quot;999&quot; }, &quot;heros&quot;: [ 1, 2, 3 ], &quot;dungeons&quot;: { &quot;1&quot;: &quot;10&quot;, &quot;2&quot;: &quot;20&quot;, &quot;3&quot;: &quot;30&quot; } } }, &quot;progress&quot;: 10 }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_STORY&quot;, &quot;story&quot;: { &quot;cost&quot;: { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, &quot;fruits&quot;: { &quot;1&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;2&quot;: &quot;FRUIT_TYPE_ORANGE&quot; }, &quot;flavors&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: 1 }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: 2 } } } }, &quot;progress&quot;: 10 }, &quot;4&quot;: { &quot;id&quot;: 4, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_SKILL&quot;, &quot;skill&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;2&quot; } }, &quot;progress&quot;: 8 } } } TaskConf.txt task_map: { key: 1 value: { id: 1 target: { type: TYPE_PVP pvp: { type: 1 damage: 10 types: FRUIT_TYPE_APPLE types: FRUIT_TYPE_ORANGE types: FRUIT_TYPE_BANANA } } progress: 3 } } task_map: { key: 2 value: { id: 2 target: { type: TYPE_PVE pve: { mission: { id: 1 level: 100 damage: 999 } heros: 1 heros: 2 heros: 3 dungeons: { key: 1 value: 10 } dungeons: { key: 2 value: 20 } dungeons: { key: 3 value: 30 } } } progress: 10 } } task_map: { key: 3 value: { id: 3 target: { type: TYPE_STORY story: { cost: { id: 1001 num: 10 } fruits: { key: 1 value: FRUIT_TYPE_APPLE } fruits: { key: 2 value: FRUIT_TYPE_ORANGE } flavors: { key: 1 value: { key: FRUIT_FLAVOR_FRAGRANT value: 1 } } flavors: { key: 2 value: { key: FRUIT_FLAVOR_SOUR value: 2 } } } } progress: 10 } } task_map: { key: 4 value: { id: 4 target: { type: TYPE_SKILL skill: { id: 1 damage: 2 } } progress: 8 } } Predefined incell union in map # Based on predefined union type Target.
A worksheet TaskConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Apple @TABLEAU ID Target1 Target2 Progress map&lt;int32, Task&gt; {.Target}|{form:FORM_TEXT} {.Target}|{form:FORM_JSON} int32 ID Target1 Target2 Progress 1 type:TYPE_PVP pvp:{type:1 damage:10 types:FRUIT_TYPE_APPLE types:FRUIT_TYPE_ORANGE types:FRUIT_TYPE_BANANA} {&ldquo;type&rdquo;:&ldquo;TYPE_PVP&rdquo;,&ldquo;pvp&rdquo;:{&ldquo;type&rdquo;:1,&ldquo;damage&rdquo;:&ldquo;10&rdquo;,&ldquo;types&rdquo;:[&ldquo;FRUIT_TYPE_APPLE&rdquo;,&ldquo;FRUIT_TYPE_ORANGE&rdquo;,&ldquo;FRUIT_TYPE_BANANA&rdquo;]}} 3 2 type:TYPE_PVE pve:{mission:{id:1 level:100 damage:999} heros:1 heros:2 heros:3 dungeons:{key:1 value:10} dungeons:{key:2 value:20} dungeons:{key:3 value:30}} {&ldquo;type&rdquo;:&ldquo;TYPE_PVE&rdquo;,&ldquo;pve&rdquo;:{&ldquo;mission&rdquo;:{&ldquo;id&rdquo;:1,&ldquo;level&rdquo;:100,&ldquo;damage&rdquo;:&ldquo;999&rdquo;},&ldquo;heros&rdquo;:[1,2,3],&ldquo;dungeons&rdquo;:{&ldquo;1&rdquo;:&ldquo;10&rdquo;,&ldquo;2&rdquo;:&ldquo;20&rdquo;,&ldquo;3&rdquo;:&ldquo;30&rdquo;}}} 10 3 type:TYPE_STORY story:{cost:{id:1001 num:10} fruits:{key:1 value:FRUIT_TYPE_APPLE} fruits:{key:2 value:FRUIT_TYPE_ORANGE} flavors:{key:1 value:{key:FRUIT_FLAVOR_FRAGRANT value:1}} flavors:{key:2 value:{key:FRUIT_FLAVOR_SOUR value:2}}} {&ldquo;type&rdquo;:&ldquo;TYPE_STORY&rdquo;,&ldquo;story&rdquo;:{&ldquo;cost&rdquo;:{&ldquo;id&rdquo;:1001,&ldquo;num&rdquo;:10},&ldquo;fruits&rdquo;:{&ldquo;1&rdquo;:&ldquo;FRUIT_TYPE_APPLE&rdquo;,&ldquo;2&rdquo;:&ldquo;FRUIT_TYPE_ORANGE&rdquo;},&ldquo;flavors&rdquo;:{&ldquo;1&rdquo;:{&ldquo;key&rdquo;:&ldquo;FRUIT_FLAVOR_FRAGRANT&rdquo;,&ldquo;value&rdquo;:1},&ldquo;2&rdquo;:{&ldquo;key&rdquo;:&ldquo;FRUIT_FLAVOR_SOUR&rdquo;,&ldquo;value&rdquo;:2}}}} 10 4 type:TYPE_SKILL skill:{id:1 damage:2} {&ldquo;type&rdquo;:&ldquo;TYPE_SKILL&rdquo;,&ldquo;skill&rdquo;:{&ldquo;id&rdquo;:1,&ldquo;damage&rdquo;:&ldquo;2&rdquo;}} 8 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message TaskConf { option (tableau.worksheet) = {name:&quot;TaskConf&quot;}; map&lt;int32, Task&gt; task_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Task { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.Target target_1 = 2 [(tableau.field) = {name:&quot;Target1&quot; span:SPAN_INNER_CELL prop:{form:FORM_TEXT}}]; protoconf.Target target_2 = 3 [(tableau.field) = {name:&quot;Target2&quot; span:SPAN_INNER_CELL prop:{form:FORM_JSON}}]; int32 progress = 4 [(tableau.field) = {name:&quot;Progress&quot;}]; } } TaskConf.json { &quot;taskMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;target1&quot;: { &quot;type&quot;: &quot;TYPE_PVP&quot;, &quot;pvp&quot;: { &quot;type&quot;: 1, &quot;damage&quot;: &quot;10&quot;, &quot;types&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } }, &quot;target2&quot;: { &quot;type&quot;: &quot;TYPE_PVP&quot;, &quot;pvp&quot;: { &quot;type&quot;: 1, &quot;damage&quot;: &quot;10&quot;, &quot;types&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } }, &quot;progress&quot;: 3 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;target1&quot;: { &quot;type&quot;: &quot;TYPE_PVE&quot;, &quot;pve&quot;: { &quot;mission&quot;: { &quot;id&quot;: 1, &quot;level&quot;: 100, &quot;damage&quot;: &quot;999&quot; }, &quot;heros&quot;: [ 1, 2, 3 ], &quot;dungeons&quot;: { &quot;1&quot;: &quot;10&quot;, &quot;2&quot;: &quot;20&quot;, &quot;3&quot;: &quot;30&quot; } } }, &quot;target2&quot;: { &quot;type&quot;: &quot;TYPE_PVE&quot;, &quot;pve&quot;: { &quot;mission&quot;: { &quot;id&quot;: 1, &quot;level&quot;: 100, &quot;damage&quot;: &quot;999&quot; }, &quot;heros&quot;: [ 1, 2, 3 ], &quot;dungeons&quot;: { &quot;1&quot;: &quot;10&quot;, &quot;2&quot;: &quot;20&quot;, &quot;3&quot;: &quot;30&quot; } } }, &quot;progress&quot;: 10 }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;target1&quot;: { &quot;type&quot;: &quot;TYPE_STORY&quot;, &quot;story&quot;: { &quot;cost&quot;: { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, &quot;fruits&quot;: { &quot;1&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;2&quot;: &quot;FRUIT_TYPE_ORANGE&quot; }, &quot;flavors&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: 1 }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: 2 } } } }, &quot;target2&quot;: { &quot;type&quot;: &quot;TYPE_STORY&quot;, &quot;story&quot;: { &quot;cost&quot;: { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, &quot;fruits&quot;: { &quot;1&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;2&quot;: &quot;FRUIT_TYPE_ORANGE&quot; }, &quot;flavors&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: 1 }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: 2 } } } }, &quot;progress&quot;: 10 }, &quot;4&quot;: { &quot;id&quot;: 4, &quot;target1&quot;: { &quot;type&quot;: &quot;TYPE_SKILL&quot;, &quot;skill&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;2&quot; } }, &quot;target2&quot;: { &quot;type&quot;: &quot;TYPE_SKILL&quot;, &quot;skill&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;2&quot; } }, &quot;progress&quot;: 8 } } } Define union type in sheet # There are two kinds of Mode (in metasheet @TABLEAU) to define union types in a sheet:
MODE_UNION_TYPE: define single union type in a sheet. MODE_UNION_TYPE_MULTI: define multiple union types in a sheet. You can define each union field by following types:
Scalar → Enum → Wellknown types → Incell struct → Incell list → Incell map → Single union type in sheet # You should specify Mode option to MODE_UNION_TYPE in metasheet @TABLEAU.
For example, a worksheet Target in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Target @TABLEAU Name Alias Field1 Field2 Field3 PVP AliasPVP ID
uint32
Note Damage
int64
Note Type
enum&lt;.FruitType&gt;
Note PVE AliasPVE Hero
[]uint32
Note Dungeon
map&lt;int32, int64&gt;
Note Skill AliasSkill StartTime
datetime
Note Duration
duration
Note Sheet Mode Target MODE_UNION_TYPE Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; // Generated from sheet: Target. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: &quot;Type&quot; }]; oneof value { option (tableau.oneof) = {field: &quot;Field&quot;}; PVP pvp = 1; // Bound to enum value: TYPE_PVP. PVE pve = 2; // Bound to enum value: TYPE_PVE. Skill skill = 3; // Bound to enum value: TYPE_SKILL. } enum Type { TYPE_INVALID = 0; TYPE_PVP = 1 [(tableau.evalue).name = &quot;AliasPVP&quot;]; TYPE_PVE = 2 [(tableau.evalue).name = &quot;AliasPVE&quot;]; TYPE_SKILL = 3 [(tableau.evalue).name = &quot;AliasSkill&quot;]; } message PVP { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 damage = 2 [(tableau.field) = {name:&quot;Damage&quot;}]; protoconf.FruitType type = 3 [(tableau.field) = {name:&quot;Type&quot;}]; } message PVE { repeated uint32 hero_list = 1 [(tableau.field) = {name:&quot;Hero&quot; layout:LAYOUT_INCELL}]; map&lt;int32, int64&gt; dungeon_map = 2 [(tableau.field) = {name:&quot;Dungeon&quot; layout:LAYOUT_INCELL}]; } message Skill { google.protobuf.Timestamp start_time = 1 [(tableau.field) = {name:&quot;StartTime&quot;}]; google.protobuf.Duration duration = 2 [(tableau.field) = {name:&quot;Duration&quot;}]; } } Multiple union types in sheet # You should specify Mode option to MODE_UNION_TYPE_MULTI in metasheet @TABLEAU.
For example, a worksheet Target in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Target @TABLEAU WishTarget WishTarget note Name Alias Field1 Field2 Field3 Higher WishHigher Height
int32 Richer WishRicher ID
uint32 Bank
map&lt;int32, string&gt; HeroTarget HeroTarget note Name Alias Field1 Field2 Field3 StarUp HeroStarUp ID
uint32 Star
int32 LevelUp HeroLevelUp ID
[]uint32 Level
int32 Super
bool BattleTarget BattleTarget note Name Alias Field1 Field2 Field3 PVP BattlePVP BattleID
int32 Damage
int64 PVE BattlePVE HeroID
[]int32 Dungeon
map&lt;int32, int64&gt; Boss
{uint32 ID, int64 Damage}Boss Sheet Mode Target MODE_UNION_TYPE_MULTI Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; message WishTarget { option (tableau.union) = {name:&quot;UnionType&quot; note:&quot;WishTarget note&quot;}; Type type = 9999 [(tableau.field) = {name:&quot;Type&quot;}]; oneof value { option (tableau.oneof) = {note:&quot;WishTarget note&quot; field:&quot;Field&quot;}; Higher higher = 1; // Bound to enum value: TYPE_HIGHER. Richer richer = 2; // Bound to enum value: TYPE_RICHER. } enum Type { TYPE_INVALID = 0; TYPE_HIGHER = 1 [(tableau.evalue).name = &quot;WishHigher&quot;]; // WishHigher TYPE_RICHER = 2 [(tableau.evalue).name = &quot;WishRicher&quot;]; // WishRicher } message Higher { int32 height = 1 [(tableau.field) = {name:&quot;Height&quot;}]; } message Richer { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; map&lt;int32, string&gt; bank_map = 2 [(tableau.field) = {name:&quot;Bank&quot; layout:LAYOUT_INCELL}]; } } message HeroTarget { option (tableau.union) = {name:&quot;UnionType&quot; note:&quot;HeroTarget note&quot;}; Type type = 9999 [(tableau.field) = {name:&quot;Type&quot;}]; oneof value { option (tableau.oneof) = {note:&quot;HeroTarget note&quot; field:&quot;Field&quot;}; StarUp star_up = 1; // Bound to enum value: TYPE_STAR_UP. LevelUp level_up = 2; // Bound to enum value: TYPE_LEVEL_UP. } enum Type { TYPE_INVALID = 0; TYPE_STAR_UP = 1 [(tableau.evalue).name = &quot;HeroStarUp&quot;]; // HeroStarUp TYPE_LEVEL_UP = 2 [(tableau.evalue).name = &quot;HeroLevelUp&quot;]; // HeroLevelUp } message StarUp { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 star = 2 [(tableau.field) = {name:&quot;Star&quot;}]; } message LevelUp { repeated uint32 id_list = 1 [(tableau.field) = {name:&quot;ID&quot; layout:LAYOUT_INCELL}]; int32 level = 2 [(tableau.field) = {name:&quot;Level&quot;}]; bool super = 3 [(tableau.field) = {name:&quot;Super&quot;}]; } } message BattleTarget { option (tableau.union) = {name:&quot;UnionType&quot; note:&quot;BattleTarget note&quot;}; Type type = 9999 [(tableau.field) = {name:&quot;Type&quot;}]; oneof value { option (tableau.oneof) = {note:&quot;BattleTarget note&quot; field:&quot;Field&quot;}; PVP pvp = 1; // Bound to enum value: TYPE_PVP. PVE pve = 2; // Bound to enum value: TYPE_PVE. } enum Type { TYPE_INVALID = 0; TYPE_PVP = 1 [(tableau.evalue).name = &quot;BattlePVP&quot;]; // BattlePVP TYPE_PVE = 2 [(tableau.evalue).name = &quot;BattlePVE&quot;]; // BattlePVE } message PVP { int32 battle_id = 1 [(tableau.field) = {name:&quot;BattleID&quot;}]; int64 damage = 2 [(tableau.field) = {name:&quot;Damage&quot;}]; } message PVE { repeated int32 hero_id_list = 1 [(tableau.field) = {name:&quot;HeroID&quot; layout:LAYOUT_INCELL}]; map&lt;int32, int64&gt; dungeon_map = 2 [(tableau.field) = {name:&quot;Dungeon&quot; layout:LAYOUT_INCELL}]; Boss boss = 3 [(tableau.field) = {name:&quot;Boss&quot; span:SPAN_INNER_CELL}]; message Boss { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 damage = 2 [(tableau.field) = {name:&quot;Damage&quot;}]; } } } Specify Number column # In Number column, you can specify custom unique field number and corresponding enum value number.
For example, a worksheet Target in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Target @TABLEAU Number Name Alias Field1 Field2 Field3 1 PVP AliasPVP ID
uint32
Note Damage
int64
Note Type
enum&lt;.FruitType&gt;
Note 20 PVE AliasPVE Hero
[]uint32
Note Dungeon
map&lt;int32, int64&gt;
Note 30 Skill AliasSkill StartTime
datetime
Note Duration
duration
Note Sheet Mode Target MODE_UNION_TYPE Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot;}; // Generated from sheet: Target. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: &quot;Type&quot; }]; oneof value { option (tableau.oneof) = {field: &quot;Field&quot;}; PVP pvp = 1; // Bound to enum value: TYPE_PVP. PVE pve = 20; // Bound to enum value: TYPE_PVE. Skill skill = 30; // Bound to enum value: TYPE_SKILL. } enum Type { TYPE_INVALID = 0; TYPE_PVP = 1 [(tableau.evalue).name = &quot;AliasPVP&quot;]; TYPE_PVE = 20 [(tableau.evalue).name = &quot;AliasPVE&quot;]; TYPE_SKILL = 30 [(tableau.evalue).name = &quot;AliasSkill&quot;]; } message PVP { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 damage = 2 [(tableau.field) = {name:&quot;Damage&quot;}]; protoconf.FruitType type = 3 [(tableau.field) = {name:&quot;Type&quot;}]; } message PVE { repeated uint32 hero_list = 1 [(tableau.field) = {name:&quot;Hero&quot; layout:LAYOUT_INCELL}]; map&lt;int32, int64&gt; dungeon_map = 2 [(tableau.field) = {name:&quot;Dungeon&quot; layout:LAYOUT_INCELL}]; } message Skill { google.protobuf.Timestamp start_time = 1 [(tableau.field) = {name:&quot;StartTime&quot;}]; google.protobuf.Duration duration = 2 [(tableau.field) = {name:&quot;Duration&quot;}]; } } Complex union type in sheet # For example, two worksheets Target and TaskConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Target TaskConf @TABLEAU Name Alias Field1 Field2 Field3 PVP AliasPVP ID
uint32
Note Damage
int64
Note Type
[]enum&lt;.FruitType&gt;
Note PVE AliasPVE Mission
{uint32 ID, enum&lt;.ItemType&gt; Type}Mission
Note Hero
[]uint32
Note Dungeon
map&lt;int32, int64&gt;
Note Story AliasStory Cost
{.Item}
Note Fruit
map&lt;int32, enum&lt;.FruitType&raquo;
Note Flavor
map&lt;enum&lt;.FruitFlavor&gt;, enum&lt;.FruitType&raquo;
Note Hobby AliasHobby Flavor
map&lt;enum&lt;.FruitFlavor&gt;, enum&lt;.FruitType&raquo;
Note StartTime
datetime
Note Duration
duration
Note Skill AliasSkill ID
uint32
Note Damage
int64
Note Empty AliasEmpty ID TargetType TargetField1 TargetField2 TargetField3 Progress map&lt;int32, Task&gt; {.Target}enum&lt;.Target.Type&gt; union union union int32 ID Target&rsquo;s type Target&rsquo;s field1 Target&rsquo;s field2 Target&rsquo;s field3 Progress 1 AliasPVP 1 10 Apple,Orange,Banana 3 2 AliasPVE 1,Equip 1,2,3 1:10,2:20,3:30 10 3 AliasStory 1001,10 1:Apple,2:Orange Fragrant:Apple,Sour:Orange 10 4 AliasHobby Fragrant:Apple,Sour:Orange 2023-06-01 10:00:00 22s 12 5 AliasSkill 1 200 8 6 AliasEmpty Sheet Mode Target MODE_UNION_TYPE Task Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; // Generated from sheet: Target. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: &quot;Type&quot; }]; oneof value { option (tableau.oneof) = {field: &quot;Field&quot;}; PVP pvp = 1; // Bound to enum value: TYPE_PVP. PVE pve = 2; // Bound to enum value: TYPE_PVE. Story story = 3; // Bound to enum value: TYPE_STORY. Hobby hobby = 4; // Bound to enum value: TYPE_HOBBY. Skill skill = 5; // Bound to enum value: TYPE_SKILL. Empty empty = 6; // Bound to enum value: TYPE_EMPTY. } enum Type { TYPE_INVALID = 0; TYPE_PVP = 1 [(tableau.evalue).name = &quot;AliasPVP&quot;]; TYPE_PVE = 2 [(tableau.evalue).name = &quot;AliasPVE&quot;]; TYPE_STORY = 3 [(tableau.evalue).name = &quot;AliasStory&quot;]; TYPE_HOBBY = 4 [(tableau.evalue).name = &quot;AliasHobby&quot;]; TYPE_SKILL = 5 [(tableau.evalue).name = &quot;AliasSkill&quot;]; TYPE_EMPTY = 6 [(tableau.evalue).name = &quot;AliasEmpty&quot;]; } message PVP { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 damage = 2 [(tableau.field) = {name:&quot;Damage&quot;}]; repeated protoconf.FruitType type_list = 3 [(tableau.field) = {name:&quot;Type&quot; layout:LAYOUT_INCELL}]; } message PVE { Mission mission = 1 [(tableau.field) = {name:&quot;Mission&quot; span:SPAN_INNER_CELL}]; message Mission { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.ItemType type = 2 [(tableau.field) = {name:&quot;Type&quot;}]; } repeated uint32 hero_list = 2 [(tableau.field) = {name:&quot;Hero&quot; layout:LAYOUT_INCELL}]; map&lt;int32, int64&gt; dungeon_map = 3 [(tableau.field) = {name:&quot;Dungeon&quot; layout:LAYOUT_INCELL}]; } message Story { protoconf.Item cost = 1 [(tableau.field) = {name:&quot;Cost&quot; span:SPAN_INNER_CELL}]; map&lt;int32, protoconf.FruitType&gt; fruit_map = 2 [(tableau.field) = {name:&quot;Fruit&quot; layout:LAYOUT_INCELL}]; map&lt;int32, Flavor&gt; flavor_map = 3 [(tableau.field) = {name:&quot;Flavor&quot; key:&quot;Key&quot; layout:LAYOUT_INCELL}]; message Flavor { protoconf.FruitFlavor key = 1 [(tableau.field) = {name:&quot;Key&quot;}]; protoconf.FruitType value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } message Hobby { map&lt;int32, Flavor&gt; flavor_map = 1 [(tableau.field) = {name:&quot;Flavor&quot; key:&quot;Key&quot; layout:LAYOUT_INCELL}]; message Flavor { protoconf.FruitFlavor key = 1 [(tableau.field) = {name:&quot;Key&quot;}]; protoconf.FruitType value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } google.protobuf.Timestamp start_time = 2 [(tableau.field) = {name:&quot;StartTime&quot;}]; google.protobuf.Duration duration = 3 [(tableau.field) = {name:&quot;Duration&quot;}]; } message Skill { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 damage = 2 [(tableau.field) = {name:&quot;Damage&quot;}]; } message Empty { } } message TaskConf { option (tableau.worksheet) = {name:&quot;TaskConf&quot;}; map&lt;int32, Task&gt; task_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Task { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.Target target = 2 [(tableau.field) = {name:&quot;Target&quot;}]; int32 progress = 3 [(tableau.field) = {name:&quot;Progress&quot;}]; } } TaskConf.json { &quot;taskMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVP&quot;, &quot;pvp&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;10&quot;, &quot;typeList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } }, &quot;progress&quot;: 3 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_PVE&quot;, &quot;pve&quot;: { &quot;mission&quot;: { &quot;id&quot;: 1, &quot;type&quot;: &quot;ITEM_TYPE_EQUIP&quot; }, &quot;heroList&quot;: [ 1, 2, 3 ], &quot;dungeonMap&quot;: { &quot;1&quot;: &quot;10&quot;, &quot;2&quot;: &quot;20&quot;, &quot;3&quot;: &quot;30&quot; } } }, &quot;progress&quot;: 10 }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_STORY&quot;, &quot;story&quot;: { &quot;cost&quot;: { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, &quot;fruitMap&quot;: { &quot;1&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;2&quot;: &quot;FRUIT_TYPE_ORANGE&quot; }, &quot;flavorMap&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: &quot;FRUIT_TYPE_APPLE&quot; }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: &quot;FRUIT_TYPE_ORANGE&quot; } } } }, &quot;progress&quot;: 10 }, &quot;4&quot;: { &quot;id&quot;: 4, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_HOBBY&quot;, &quot;hobby&quot;: { &quot;flavorMap&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;value&quot;: &quot;FRUIT_TYPE_APPLE&quot; }, &quot;2&quot;: { &quot;key&quot;: &quot;FRUIT_FLAVOR_SOUR&quot;, &quot;value&quot;: &quot;FRUIT_TYPE_ORANGE&quot; } }, &quot;startTime&quot;: &quot;2023-06-01T02:00:00Z&quot;, &quot;duration&quot;: &quot;22s&quot; } }, &quot;progress&quot;: 12 }, &quot;5&quot;: { &quot;id&quot;: 5, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_SKILL&quot;, &quot;skill&quot;: { &quot;id&quot;: 1, &quot;damage&quot;: &quot;200&quot; } }, &quot;progress&quot;: 8 }, &quot;6&quot;: { &quot;id&quot;: 6, &quot;target&quot;: { &quot;type&quot;: &quot;TYPE_EMPTY&quot;, &quot;empty&quot;: {} }, &quot;progress&quot;: 0 } } } `}).add({id:42,href:"/docs/excel/list/",title:"List",description:"Excel list guide.",content:`Horizontal list # NOTE: Column name of horizontal list MUST have a digit suffix which started at 1.
Overview of horizontal list syntax:
List element type Syntax example scalar []uint32 enum []enum&lt;.FruiteType&gt; struct [Item]uint32 predefined struct [.Item]uint32 incell struct []{uint32 ID, string Num}Item incell predefined struct []{.Item} Horizontal scalar list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID1 ID2 ID3 []uint32 uint32 uint32 ID1&rsquo;s value ID2&rsquo;s value ID3&rsquo;s value 1 2 3 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated uint32 id_list = 1 [(tableau.field) = {name:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; } ItemConf.json { &quot;idList&quot;: [ 1, 2, 3 ] } Horizontal enum list # FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Param1 Param2 Param3 []enum&lt;.FruitType&gt; enum&lt;.FruitType&gt; enum&lt;.FruitType&gt; Param1&rsquo;s value Param2&rsquo;s value Param3&rsquo;s value 1 FRUIT_TYPE_ORANGE Banana Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType param_list = 1 [(tableau.field) = {name:&quot;Param&quot; layout:LAYOUT_HORIZONTAL}]; } ItemConf.json { &quot;paramList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } Horizontal struct list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name [Item]uint32 string uint32 string uint32 string Item1&rsquo;s ID Item1&rsquo;s name Item2&rsquo;s ID Item2&rsquo;s name Item3&rsquo;s ID Item3&rsquo;s name 1 Apple 2 Orange 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot; }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot; } ] } Horizontal predefined-struct list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Num Item2ID Item2Num Item3ID Item3Num [.Item]int32 int32 int32 int32 int32 int32 Item1&rsquo;s ID Item1&rsquo;s num Item2&rsquo;s ID Item3&rsquo;s num Item3&rsquo;s ID Item3&rsquo;s num 1 100 2 200 3 300 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL}]; } ItemConf.json { &quot;ItemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 100 }, { &quot;id&quot;: 2, &quot;num&quot;: 200 }, { &quot;id&quot;: 3, &quot;num&quot;: 300 } ] } Horizontal incell-struct list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1 Item2 Item3 []{int32 ID, string Name}Item Item Item Item1&rsquo;s info Item2&rsquo;s info Item3&rsquo;s info 1,Apple 2,Orange 3,Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot; }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot; } ] } Horizontal incell-predefined-struct list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1 Reward2 Reward3 []{.Item} .Item .Item Item1&rsquo;s info Item2&rsquo;s info Item3&rsquo;s info 1,100 2,200 3,300 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Item reward_list = 1 [(tableau.field) = {name:&quot;Reward&quot; layout:LAYOUT_HORIZONTAL span:SPAN_INNER_CELL}]; } ItemConf.json { &quot;rewardList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 100 }, { &quot;id&quot;: 2, &quot;num&quot;: 200 }, { &quot;id&quot;: 3, &quot;num&quot;: 300 } ] } Vertical list # NOTE: Column name of horizontal list MUST NOT have a digit suffix which started at 1.
Overview of horizontal list syntax:
TODO: table form
Vertical scalar list # It&rsquo;s defined same as Incell scalar list, but will aggregate multiple rows if provided.
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID []uint32 ID 1,2,3 1,2 1 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated uint32 id_list = 1 [(tableau.field) = {name:&quot;ID&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;idList&quot;: [ 1, 2, 3, 1, 2, 1 ] } Vertical enum list # It&rsquo;s defined same as Incell enum list, but will aggregate multiple rows if provided.
FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Type []enum&lt;.FruitType&gt; Type Apple,Orange,Banana FRUIT_TYPE_APPLE,FRUIT_TYPE_ORANGE 1 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType type_list = 1 [(tableau.field) = {name:&quot;Type&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;typeList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot;, &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_APPLE&quot; ] } Vertical struct list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name Desc [Item]uint32 string string Item&rsquo;s ID Item&rsquo;s name Item&rsquo;s desc 1 Apple A kind of delicious fruit. 2 Orange A kind of sour fruit. 3 Banana A kind of calorie-rich fruit. Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;desc&quot;: &quot;A kind of sour fruit.&quot; }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;desc&quot;: &quot;A kind of calorie-rich fruit.&quot; } ] } Vertical predefined-struct list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Num [.Item]int32 int32 Item&rsquo;s ID Item&rsquo;s num 1 100 2 200 3 300 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Item _item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; } ItemConf.json { &quot;ItemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 100 }, { &quot;id&quot;: 2, &quot;num&quot;: 200 }, { &quot;id&quot;: 3, &quot;num&quot;: 300 } ] } Vertical incell-struct list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item []{int32 ID,int32 Num}Item Item list 1:100 2:200,3:300 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 100 }, { &quot;id&quot;: 2, &quot;num&quot;: 200 }, { &quot;id&quot;: 3, &quot;num&quot;: 300 } ] } Vertical incell-predefined-struct list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item []{.Item} Item&rsquo;s info 1:100 2:200,3:300 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 100 }, { &quot;id&quot;: 2, &quot;num&quot;: 200 }, { &quot;id&quot;: 3, &quot;num&quot;: 300 } ] } Incell list # NOTE: Column name of horizontal list MUST NOT have a digit suffix which started at 1.
Overview of incell list syntax:
TODO: table form
There are 4 kinds of incell list:
Incell scalar list, each element type is scalar. E.g: []int32. Incell enum list, each element type is enum. E.g: []enum&lt;.FruitType&gt;. Incell struct list, each element type is struct. E.g: []{int32 ID,int32 Num}Item. Incell predefined-struct list, each element type is predefined struct. E.g.: []{.Item}. Incell scalar list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Param []int32 Param list 1,2,3 4,5 6 The Param column&rsquo;s type is incell list []int32, as the list element is scalar type int32.
Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated int32 param_list = 1 [(tableau.field) = {name:&quot;Param&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;paramList&quot;: [ 1, 2, 3, 4, 5, 6 ] } Incell enum list # FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Param []enum&lt;.FruitType&gt; Param list 1,FRUIT_TYPE_ORANGE,Banana The Param column&rsquo;s type is incell list []enum&lt;.FruitType&gt;, as the list element is the predefined enum type FruitType.
Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType param_list = 1 [(tableau.field) = {name:&quot;Param&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;paramList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } Incell struct list # For more advanced incell data parsing, see Advanced predefined incell struct →.
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item []{int32 ID,int32 Num}Item Item&rsquo;s info 1:100,2:200,3:300 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 100 }, { &quot;id&quot;: 2, &quot;num&quot;: 200 }, { &quot;id&quot;: 3, &quot;num&quot;: 300 } ] } Incell predefined-struct list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item []{.Item} Item&rsquo;s info 1:100,2:200,3:300 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 100 }, { &quot;id&quot;: 2, &quot;num&quot;: 200 }, { &quot;id&quot;: 3, &quot;num&quot;: 300 } ] } Horizontal list size # Dynamic size # By default, all lists are Dynamically Sized Types. List elements should be present continuously, otherwise an error is reported if an empty element is existed in between.
Fixed size # Implicit fixed size # The list size is auto resolved by the max present list elements in name row.
In this example below, though the second element Item2 is empty, it is legal as the field property fixed is set true. Besides, Item2 will also be generated as an empty element. You can see it in the generated file ItemConf.json.
A worksheet ItemConf in HelloWorld.xlsx.
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name [Item]uint32|{fixed:true} string uint32 string uint32 string Item1&rsquo;s ID Item1&rsquo;s name Item2&rsquo;s ID Item2&rsquo;s name Item3&rsquo;s ID Item3&rsquo;s name 1 Apple 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL prop:{fixed:true}}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot; }, { &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot; }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot; } ] } Explicit fixed size # The list size is explicitly set by field property size.
In this example below, field property size is set as 2, then list elements after the second element Item2 will all be truncated. Besides, Item2 will also be generated as an empty element. You can see it in the generated file ItemConf.json.
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name [Item]uint32|{size:2} string uint32 string uint32 string Item1&rsquo;s ID Item1&rsquo;s name Item2&rsquo;s ID Item2&rsquo;s name Item3&rsquo;s ID Item3&rsquo;s name 1 Apple 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL prop:{size:2}}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot; }, { &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot; } ] } Advanced features # Horizontal column-skipped list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU D Prop1ID Prop1Value Prop2ID Prop2Value map&lt;uint32, Item&gt; [Prop]int32 int32 int32 int32 Item&rsquo;s ID Prop1’s ID Prop1’s name Prop1’s value Prop2’s ID Prop2’s name Prop2’s value 1 1 Apple 100 2 Orange 200 2 3 Banana 300 4 Pomelo 400 3 5 Watermelon 500 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; repeated Prop prop_list = 2 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } HeroConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;propList&quot;: [ { &quot;id&quot;: 1, &quot;value&quot;: 100 }, { &quot;id&quot;: 2, &quot;value&quot;: 200 } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;propList&quot;: [ { &quot;id&quot;: 3, &quot;value&quot;: 300 }, { &quot;id&quot;: 4, &quot;value&quot;: 400 } ] }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;propList&quot;: [ { &quot;id&quot;: 5, &quot;value&quot;: 500 } ] } } } `}).add({id:43,href:"/docs/excel/map/",title:"Map",description:"Excel map guide.",content:`Horizontal map # There are some kinds of horizontal map:
Horizontal scalar map, as map value type is scalar. E.g: map&lt;int32, int32&gt;. Horizontal struct map, as map value type is struct. E.g: map&lt;int32, Item&gt;. Horizontal predefined-struct map, as map value type is predefined struct. E.g: map&lt;int32, .Item&gt;. Horizontal scalar map # No need to support, use this instead: map&lt;int32, Item&gt;.
Horizontal struct map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name map&lt;uint32, Item&gt; string uint32 string uint32 string Item1&rsquo;s ID Item1&rsquo;s name Item2&rsquo;s ID Item2&rsquo;s name Item3&rsquo;s ID Item3&rsquo;s name 1 Apple 2 Orange 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot; }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot; }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot; } } } Horizontal predefined-struct map # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Num Item2ID Item2Num Item3ID Item3Num map&lt;int32, .Item&gt; int32 int32 int32 int32 int32 Item1&rsquo;s ID Item1&rsquo;s num Item2&rsquo;s ID Item3&rsquo;s num Item3&rsquo;s ID Item3&rsquo;s num 1 100 2 200 3 300 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, protoconf.Item&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 100 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 200 }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;num&quot;: 300 } } } Vertical map # There are some kinds of vertical map:
Vertical scalar map, as map value type is scalar. E.g: map&lt;int32, int32&gt;. Vertical struct map, as map value type is struct. E.g: map&lt;int32, Item&gt;. Vertical predefined-struct map, as map value type is predefined struct. E.g: map&lt;int32, .Item&gt;. Vertical scalar map # No need to support, use map&lt;int32, Item&gt; instead.
Vertical struct map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name Desc map&lt;uint32, Item&gt; string string Item’s ID Item’s name Item’s desc 1 Apple A kind of delicious fruit. 2 Orange A kind of sour fruit. 3 Banana A kind of calorie-rich fruit. Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;desc&quot;: &quot;A kind of sour fruit.&quot; }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;desc&quot;: &quot;A kind of calorie-rich fruit.&quot; } } } Vertical predefined-struct map # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Num map&lt;int32, .Item&gt; int32 Item&rsquo;s ID Item&rsquo;s num 1 100 2 200 3 300 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, protoconf.Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 100 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 200 }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;num&quot;: 300 } } } Incell map # There are some kinds of in-cell map:
in-cell scalar map, as map value type is scalar. E.g: map&lt;int32, int32&gt;. in-cell struct map, as map value type is struct. E.g: map&lt;int32, Item&gt;. Incell scalar map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item map&lt;uint32, string&gt; Item key-value pairs 1:Apple,2:Orange,3:Banana,4,:Peach The Item column&rsquo;s type is in-cell map map&lt;uint32, string&gt;, as the map value is scalar type string.
⚠️ NOTE: If you want explicit pattern like: [Key:Value]..., then set the field property present as true. See Option present →.
Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, string&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;itemMap&quot;: { &quot;0&quot;: &quot;Peach&quot;, &quot;1&quot;: &quot;Apple&quot;, &quot;2&quot;: &quot;Orange&quot;, &quot;3&quot;: &quot;Banana&quot;, &quot;4&quot;: &quot;&quot; } } Incell enum map # For incell map, both the key and value can be enum types.
For example, predefined enum types FruitType and FruitFlavor in common.proto are:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 2 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 3 [(tableau.evalue).name = &quot;Banana&quot;]; } enum FruitFlavor { FRUIT_FLAVOR_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_FLAVOR_FRAGRANT = 1 [(tableau.evalue).name = &quot;Fragrant&quot;]; FRUIT_FLAVOR_SOUR = 2 [(tableau.evalue).name = &quot;Sour&quot;]; FRUIT_FLAVOR_SWEET = 3 [(tableau.evalue).name = &quot;Sweet&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Fruit Flavor Item map&lt;enum&lt;.FruitType&gt;, int64&gt; map&lt;int64, enum&lt;.FruitFlavor&raquo; map&lt;enum&lt;.FruitType&gt;, enum&lt;.FruitFlavor&raquo; Fruits Flavors Items Apple:1,Orange:2 1:Fragrant,2:Sweet Apple:Fragrant,Orange:Sour Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, Fruit&gt; fruit_map = 1 [(tableau.field) = {name:&quot;Fruit&quot; key:&quot;Key&quot; layout:LAYOUT_INCELL}]; message Fruit { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;Key&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } map&lt;int64, protoconf.FruitFlavor&gt; flavor_map = 2 [(tableau.field) = {name:&quot;Flavor&quot; layout:LAYOUT_INCELL}]; map&lt;int32, Item&gt; item_map = 3 [(tableau.field) = {name:&quot;Item&quot; key:&quot;Key&quot; layout:LAYOUT_INCELL}]; message Item { protoconf.FruitType key = 1 [(tableau.field) = {name:&quot;Key&quot;}]; protoconf.FruitFlavor value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } ItemConf.json { &quot;fruitMap&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;value&quot;: &quot;1&quot; }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;value&quot;: &quot;2&quot; } }, &quot;flavorMap&quot;: { &quot;1&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot;, &quot;2&quot;: &quot;FRUIT_FLAVOR_SWEET&quot; }, &quot;itemMap&quot;: { &quot;1&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_FRAGRANT&quot; }, &quot;3&quot;: { &quot;key&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;value&quot;: &quot;FRUIT_FLAVOR_SOUR&quot; } } } Empty key map # If map key is not configured, then it will be treated as default value of map key type. Default value is illustrated at Scalar types →.
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Desc map&lt;uint32, Item&gt; string Item&rsquo;s ID Item&rsquo;s name 1 Apple Orange 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string desc = 2 [(tableau.field) = {name:&quot;Desc&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;0&quot;: { &quot;id&quot;: 0, &quot;desc&quot;: &quot;Orange&quot; }, &quot;1&quot;: { &quot;id&quot;: 1, &quot;desc&quot;: &quot;Apple&quot; }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;desc&quot;: &quot;Banana&quot; } } } Enum key map # As the protobuf documents the restrictions of map key type:
&hellip; the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). Note that enum is not a valid key_type.
However, key type as enum is very useful in some situations. So we support it in a simple way:
enum type is treated as int32 as map key type， enum type is reserved in map value type (struct). For example, FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } then map&lt;enum&lt;.FruitType&gt;, ValueType&gt; will be converted to map&lt;int32, ValueType&gt;, and FruitType is reserved in ValueType:
message ValueType { FruitType key = 1; ... } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Type Price map&lt;enum&lt;.FruitType&gt;, Item&gt; int32 Item&rsquo;s type Item&rsquo;s price Apple 100 Orange 200 Banana 300 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;Type&quot; layout:LAYOUT_VERTICAL}]; message Item { protoconf.FruitType type = 1 [(tableau.field) = {name:&quot;Type&quot;}]; int32 price = 2 [(tableau.field) = {name:&quot;Price&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;type&quot;: &quot;FRUIT_TYPE_APPLE&quot;, &quot;price&quot;: 100 }, &quot;3&quot;: { &quot;type&quot;: &quot;FRUIT_TYPE_ORANGE&quot;, &quot;price&quot;: 200 }, &quot;4&quot;: { &quot;type&quot;: &quot;FRUIT_TYPE_BANANA&quot;, &quot;price&quot;: 300 } } } Horizontal map size # Dynamic size # By default, all maps are Dynamically Sized Types. Map items should be present continuously, otherwise an error is reported if an empty item is existed in between.
Fixed size # Implicit fixed size # The map size is auto resolved by the max map items present in name row.
In this example below, though the second map item Item2 is empty, it is legal as the field property fixed is set true. Besides, Item2 will also be generated as an empty map item. You can see it in the generated file ItemConf.json.
👉 If more than one empty map items are inserted into map, then only one empty map item is really generated. Because all the empty map items's keys are same. This is different from list, you should pay special attention to it. A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name map&lt;uint32, Item&gt;|{fixed:true} string uint32 string uint32 string Item1&rsquo;s ID Item1&rsquo;s name Item2&rsquo;s ID Item2&rsquo;s name Item3&rsquo;s ID Item3&rsquo;s name 1 Apple 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL prop:{fixed:true}}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;0&quot;: { &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot; }, &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot; }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot; } } } Explicit fixed size # The map size is explicitly set by field property size.
In this example below, field property size is set as 2, then map items after the second item Item2 will all be truncated. Besides, Item2 will also be generated as an empty map item. You can see it in the generated file ItemConf.json.
👉 If more than one empty map items are inserted into map, then only one empty map item is really generated. Because all the empty map items's keys are same. This is different from list, you should pay special attention to it. A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name map&lt;uint32, Item&gt;|{size:2} string uint32 string uint32 string Item1&rsquo;s ID Item1&rsquo;s name Item2&rsquo;s ID Item2&rsquo;s name Item3&rsquo;s ID Item3&rsquo;s name 1 Apple 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL prop:{size:2}}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;0&quot;: { &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot; }, &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot; } } } Advanced features # Horizontal column-skipped map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU D Prop1ID Prop1Value Prop2ID Prop2Value map&lt;uint32, Item&gt; map&lt;int32, Prop&gt; int32 int32 int32 Item&rsquo;s ID Prop1’s ID Prop1’s name Prop1’s value Prop2’s ID Prop2’s name Prop2’s value 1 1 Apple 100 2 Orange 200 2 3 Banana 300 4 Pomelo 400 3 5 Watermelon 500 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; map&lt;int32, Prop&gt; prop_map = 2 [(tableau.field) = {name:&quot;Prop&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } HeroConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;desc&quot;: &quot;item1&quot;, &quot;propertyMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;value&quot;: &quot;10&quot; }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;value&quot;: &quot;20&quot; } } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;desc&quot;: &quot;item2&quot;, &quot;propertyMap&quot;: { &quot;3&quot;: { &quot;id&quot;: 3, &quot;value&quot;: &quot;30&quot; }, &quot;4&quot;: { &quot;id&quot;: 4, &quot;value&quot;: &quot;40&quot; } } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;desc&quot;: &quot;item3&quot;, &quot;propertyMap&quot;: { &quot;5&quot;: { &quot;id&quot;: 5, &quot;value&quot;: &quot;50&quot; } } } } } Ordered-map # In the metasheet @TABLEAU, set the OrderedMap option to true, then ordered map accessers will be generated. This feature is powered by tableauio/loader. Currently supported programming languages are:
C++ Go C# JS/TS Example # If we want ItemConf to generate ordered map accessers, then set OrderedMap option to true of metasheet @TABLEAU:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name map&lt;uint32, Item&gt; string Item&rsquo;s ID Item&rsquo;s Name 1 Apple 2 Orange 3 Banana Sheet OrderedMap ItemConf true More useful options are illustrated at metasheet chapter. Metasheet @TABLEAU →
`}).add({id:44,href:"/docs/excel/keyedlist/",title:"KeyedList",description:"Excel keyed list guide.",content:`Syntax # Keyed list is same as normal list, except that ColumnType (first field type) is surrounded by angle brackets &lt;&gt;, and is treated as map key.
Syntax: [ElemType]&lt;ColumnType&gt;
Horizontal list # TODO&hellip;
Vertical KeyedList # Vertical scalar KeyedList # It&rsquo;s defined same as Incell scalar KeyedList, but will aggregate multiple rows if provided.
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID []&lt;uint32&gt; ID 1,2,3 4,5 6 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated uint32 id_list = 1 [(tableau.field) = {name:&quot;ID&quot; key:&quot;ID&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;idList&quot;: [ 1, 2, 3, 4, 5, 6 ] } Vertical enum KeyedList # It&rsquo;s defined same as Incell enum keyedList, but will aggregate multiple rows if provided.
FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Type []&lt;enum&lt;.FruitType&gt;&gt; Type Apple,Orange FRUIT_TYPE_BANANA 0 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType type_list = 1 [(tableau.field) = {name:&quot;Type&quot; key:&quot;Type&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;typeList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot;, &quot;FRUIT_TYPE_UNKNOWN&quot; ] } Vertical struct KeyedList # For example, a worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID PropID PropName [Item]&lt;uint32&gt; map&lt;int32, Prop&gt; string Item&rsquo;s ID Prop&rsquo;s ID Prop&rsquo;s name 1 1 sweet 2 1 sweet 2 2 delicious Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; map&lt;int32, Prop&gt; prop_map = 2 [(tableau.field) = {key:&quot;PropID&quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:&quot;PropID&quot;}]; string prop_name = 2 [(tableau.field) = {name:&quot;PropName&quot;}]; } } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;propMap&quot;: { &quot;1&quot;: { &quot;propId&quot;: 1, &quot;propName&quot;: &quot;sweet&quot; } } }, { &quot;id&quot;: 2, &quot;propMap&quot;: { &quot;1&quot;: { &quot;propId&quot;: 1, &quot;propName&quot;: &quot;sweet&quot; }, &quot;2&quot;: { &quot;propId&quot;: 2, &quot;propName&quot;: &quot;delicious&quot; } } } ] } Incell KeyedList # Incell scalar KeyedList # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID []&lt;uint32&gt; ID list 1,2,3 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;; repeated uint32 id_list = 1 [(tableau.field) = {name:&quot;ID&quot; key:&quot;ID&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;idList&quot;: [ 1, 2, 3 ] } Incell enum KeyedList # FruitType in common.proto is predefined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = &quot;Banana&quot;]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Param []enum&lt;.FruitType&gt; Param list 1,FRUIT_TYPE_ORANGE,Banana The Param column&rsquo;s type is incell list []enum&lt;.FruitType&gt;, as the list element is the predefined enum type FruitType.
Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated protoconf.FruitType type_list = 1 [(tableau.field) = {name:&quot;Type&quot; key:&quot;Type&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;typeList&quot;: [ &quot;FRUIT_TYPE_APPLE&quot;, &quot;FRUIT_TYPE_ORANGE&quot;, &quot;FRUIT_TYPE_BANANA&quot; ] } `}).add({id:45,href:"/docs/excel/wellknown-types/",title:"Wellknown types",description:"Wellknown guide.",content:`Datetime # Datetime # See Basics: Datetime →
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU BeginDatetime EndDatetime Datetime datetime datetime []datetime Begin datetime End datetime Datetime 2020-01-01 10:25:00 2022-10-10 05:10:00 2020-01-01 10:25:00,2022-10-10 05:10:00 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; google.protobuf.Timestamp begin_datetime = 1 [(tableau.field) = {name:&quot;BeginDatetime&quot;}]; google.protobuf.Timestamp end_datetime = 2 [(tableau.field) = {name:&quot;EndDatetime&quot;}]; repeated google.protobuf.Timestamp datetime_list = 3 [(tableau.field) = {name:&quot;Datetime&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;beginDatetime&quot;: &quot;2020-01-01T02:25:00Z&quot;, &quot;endDatetime&quot;: &quot;2022-10-09T21:10:00Z&quot;, &quot;datetimeList&quot;: [ &quot;2020-01-01T02:25:00Z&quot;, &quot;2022-10-09T21:10:00Z&quot; ] } Date # See Basics: Datetime →
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU BeginDate EndDate Date date date []date Begin date End date Date 2020-01-01 20221010 2020-01-01,20221010 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; google.protobuf.Timestamp begin_date = 1 [(tableau.field) = {name:&quot;BeginDate&quot;}]; google.protobuf.Timestamp end_date = 2 [(tableau.field) = {name:&quot;EndDate&quot;}]; repeated google.protobuf.Timestamp date_list = 3 [(tableau.field) = {name:&quot;Date&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;beginDate&quot;: &quot;2019-12-31T16:00:00Z&quot;, &quot;endDate&quot;: &quot;2022-10-09T16:00:00Z&quot;, &quot;dateList&quot;: [ &quot;2019-12-31T16:00:00Z&quot;, &quot;2022-10-09T16:00:00Z&quot; ] } Time # See Basics: Datetime →
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU BeginTime EndTime Time time time []time Begin time End time Time 10:25:00 1125 10:25:00,1125 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; google.protobuf.Duration begin_time = 1 [(tableau.field) = {name:&quot;BeginTime&quot;}]; google.protobuf.Duration end_time = 2 [(tableau.field) = {name:&quot;EndTime&quot;}]; repeated google.protobuf.Duration time_list = 3 [(tableau.field) = {name:&quot;Time&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;beginTime&quot;: &quot;37500s&quot;, &quot;endTime&quot;: &quot;41100s&quot;, &quot;timeList&quot;: [ &quot;37500s&quot;, &quot;41100s&quot; ] } Duration # See Basics: Duration →
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Duration1 Duration2 Duration duration duration []duration Duration 1 Duration 2 Duration 1h2m3s 4ms5us6ns 1h2m3s,4ms5us6ns Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; google.protobuf.Duration duration_1 = 1 [(tableau.field) = {name:&quot;Duration1&quot;}]; google.protobuf.Duration duration_2 = 2 [(tableau.field) = {name:&quot;Duration2&quot;}]; repeated google.protobuf.Duration duration_list = 3 [(tableau.field) = {name:&quot;Duration&quot; layout:LAYOUT_INCELL}]; } ItemConf.json { &quot;duration1&quot;: &quot;3723s&quot;, &quot;duration2&quot;: &quot;0.004005006s&quot;, &quot;durationList&quot;: [ &quot;3723s&quot;, &quot;0.004005006s&quot; ] } Fraction # See Basics: Fraction →
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU MinRatio Ratio1 Ratio2 Ratio3 Ratio4 fraction []fraction fraction fraction fraction min ratio ratio1 ratio 2 ratio 3 ratio 4 1/4 10% 10‰ 10‱ 10 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; tableau.Fraction min_ratio = 1 [(tableau.field) = {name:&quot;MinRatio&quot;}]; repeated tableau.Fraction ratio_list = 2 [(tableau.field) = {name:&quot;Ratio&quot; layout:LAYOUT_HORIZONTAL}]; } ItemConf.json { &quot;minRatio&quot;: { &quot;num&quot;: 1, &quot;den&quot;: 4 }, &quot;ratioList&quot;: [ { &quot;num&quot;: 10, &quot;den&quot;: 100 }, { &quot;num&quot;: 10, &quot;den&quot;: 1000 }, { &quot;num&quot;: 10, &quot;den&quot;: 10000 }, { &quot;num&quot;: 10, &quot;den&quot;: 1 } ] } Comparator # See Basics: Comparator →
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU MinRatio Ratio1 Ratio2 Ratio3 Ratio4 Ratio5 comparator []comparator comparator comparator comparator comparator min ratio ratio1 ratio 2 ratio 3 ratio 4 ratio 5 !=1/4 &lt;10% &lt;=10‰ &gt;10‱ &gt;=10 ==3/5 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; tableau.Comparator min_ratio = 1 [(tableau.field) = {name:&quot;MinRatio&quot;}]; repeated tableau.Comparator ratio_list = 2 [(tableau.field) = {name:&quot;Ratio&quot; layout:LAYOUT_HORIZONTAL}]; } ItemConf.json { &quot;minRatio&quot;: { &quot;sign&quot;: &quot;SIGN_NOT_EQUAL&quot;, &quot;value&quot;: { &quot;num&quot;: 1, &quot;den&quot;: 4 } }, &quot;ratioList&quot;: [ { &quot;sign&quot;: &quot;SIGN_LESS&quot;, &quot;value&quot;: { &quot;num&quot;: 10, &quot;den&quot;: 100 } }, { &quot;sign&quot;: &quot;SIGN_LESS_OR_EQUAL&quot;, &quot;value&quot;: { &quot;num&quot;: 10, &quot;den&quot;: 1000 } }, { &quot;sign&quot;: &quot;SIGN_GREATER&quot;, &quot;value&quot;: { &quot;num&quot;: 10, &quot;den&quot;: 10000 } }, { &quot;sign&quot;: &quot;SIGN_GREATER_OR_EQUAL&quot;, &quot;value&quot;: { &quot;num&quot;: 10, &quot;den&quot;: 1 } }, { &quot;sign&quot;: &quot;SIGN_EQUAL&quot;, &quot;value&quot;: { &quot;num&quot;: 3, &quot;den&quot;: 5 } } ] } `}).add({id:46,href:"/docs/excel/struct-in-struct/",title:"Struct in struct",description:"Excel struct in struct guide.",content:`Struct in struct # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU RewardID RewardItemID RewardItemNum {Reward}int32 {Item}int32 int32 Reward&rsquo;s ID Item&rsquo;s ID Item&rsquo;s num 1 1 10 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Reward reward = 1 [(tableau.field) = {name:&quot;Reward&quot;}]; message Reward { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; Item item = 2 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;reward&quot;: { &quot;id&quot;: 1, &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } } Predefined-struct in struct # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU RewardID RewardItemID RewardItemNum {Reward}int32 {.Item}int32 int32 Reward&rsquo;s ID Item&rsquo;s ID Item&rsquo;s num 1 1 10 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Reward reward = 1 [(tableau.field) = {name:&quot;Reward&quot;}]; message Reward { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.Item item = 2 [(tableau.field) = {name:&quot;Item&quot;}]; } } ItemConf.json { &quot;reward&quot;: { &quot;id&quot;: 1, &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } } } Incell-struct in struct # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU RewardID RewardItem {Reward}int32 {int32 ID, int32 Num}Item Reward&rsquo;s ID Reward&rsquo;s item 1 1,100 2,200 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; Reward reward = 1 [(tableau.field) = {name:&quot;Reward&quot;}]; message Reward { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; Item item = 2 [(tableau.field) = {name:&quot;Item&quot; span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;reward&quot;: { &quot;id&quot;: 1, &quot;item&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 200 } } } `}).add({id:47,href:"/docs/excel/struct-in-list/",title:"Struct in list",description:"Excel struct in list guide.",content:`Nested in vertical-list # Struct in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name PropID PropValue [Item]uint32 string {Prop}int32 int64 Item&rsquo;s ID Item&rsquo;s name Prop&rsquo;s ID Prop&rsquo;s value 1 Apple 1 10 2 Orange 2 20 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; Prop prop = 3 [(tableau.field) = {name:&quot;Prop&quot;}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;prop&quot;: { &quot;id&quot;: 1, &quot;value&quot;: &quot;10&quot; } }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;prop&quot;: { &quot;id&quot;: 2, &quot;value&quot;: &quot;20&quot; } }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;prop&quot;: null } ] } Incell-struct in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name PropID [Item]uint32 string {int32 ID,int64 Value}Prop Item&rsquo;s ID Item&rsquo;s name Prop&rsquo;s ID 1 Apple 1,100 2 Orange 2,200 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; Prop prop_id = 3 [(tableau.field) = {name:&quot;PropID&quot; span:SPAN_INNER_CELL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propId&quot;: { &quot;id&quot;: 1, &quot;value&quot;: &quot;100&quot; } }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propId&quot;: { &quot;id&quot;: 2, &quot;value&quot;: &quot;200&quot; } }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;propId&quot;: null } ] } First-field in horizontal-list # Struct in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1ItemID Reward1ItemNum Reward1Name Reward2ItemID Reward2ItemNum Reward2Name [Reward]{Item}int32 int32 string int32 int32 string Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name 1 10 Lotto 10 100 Super Lotto Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Reward reward_list = 1 [(tableau.field) = {name:&quot;Reward&quot; layout:LAYOUT_HORIZONTAL}]; message Reward { Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;rewardList&quot;: [ { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 }, &quot;name&quot;: &quot;Lotto&quot; }, { &quot;item&quot;: { &quot;id&quot;: 10, &quot;num&quot;: 100 }, &quot;name&quot;: &quot;Super Lotto&quot; } ] } Predefined-struct in horizontal-list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1ItemID Reward1ItemNum Reward1Name Reward2ItemID Reward2ItemNum Reward2Name [Reward]{.Item}int32 int32 string int32 int32 string Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name 1 10 Lotto 10 100 Super Lotto Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Reward reward_list = 1 [(tableau.field) = {name:&quot;Reward&quot; layout:LAYOUT_HORIZONTAL}]; message Reward { protoconf.Item item = 1 [(tableau.field) = {name:&quot;Item&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;rewardList&quot;: [ { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 }, &quot;name&quot;: &quot;Lotto&quot; }, { &quot;item&quot;: { &quot;id&quot;: 10, &quot;num&quot;: 100 }, &quot;name&quot;: &quot;Super Lotto&quot; } ] } Incell-struct in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1Item Reward1Name Reward2Item Reward2Name [Reward]{int32 ID, int32 Num}Item string Item string Reward1&rsquo;s item Reward&rsquo;s name Reward2&rsquo;s item Reward&rsquo;s name 1,10 Lotto 2,20 Super Lotto Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; Prop prop_id = 3 [(tableau.field) = {name:&quot;PropID&quot; span:SPAN_INNER_CELL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } ItemConf.json { &quot;rewardList&quot;: [ { &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 }, &quot;name&quot;: &quot;Lotto&quot; }, { &quot;item&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 }, &quot;name&quot;: &quot;Super Lotto&quot; } ] } `}).add({id:48,href:"/docs/excel/struct-in-map/",title:"Struct in map",description:"Excel struct in map guide.",content:`Nested in vertical-map # Struct in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID ItemID ItemNum map&lt;int32, Reward&gt; {Item}int32 int32 Reward&rsquo;s ID Item&rsquo;s ID Item&rsquo;s Num 1 1 10 2 2 20 3 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, Reward&gt; reward_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Reward { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; Item item = 2 [(tableau.field) = {name:&quot;Item&quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;item&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;item&quot;: null } } } Predefined-struct in vertical-map # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID ItemID ItemNum map&lt;int32, Reward&gt; {.Item}int32 int32 Reward&rsquo;s ID Item&rsquo;s ID Item&rsquo;s Num 1 1 10 2 2 20 3 Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, Reward&gt; reward_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Reward { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; protoconf.Item item = 2 [(tableau.field) = {name:&quot;Item&quot;}]; } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;item&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;item&quot;: null } } } Incell-struct in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Item map&lt;int32, Reward&gt; {int32 ID, int32 Num}Item Reward&rsquo;s ID Item&rsquo;s info 1 1,100 2 2,200 3 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;int32, Reward&gt; reward_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Reward { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; Item item = 2 [(tableau.field) = {name:&quot;Item&quot; span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;item&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 100 } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;item&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 200 } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;item&quot;: null } } } `}).add({id:49,href:"/docs/excel/list-in-list/",title:"List in list",description:"Excel list in list guide.",content:`Nested in vertical-list # Horizontal-list in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name Prop1ID Prop1Value Prop2ID Prop2Value [Item]uint32 string [Prop]int32 int64 int32 int64 Item&rsquo;s ID Item&rsquo;s name Prop1&rsquo;s ID Prop1&rsquo;s value Prop2&rsquo;s ID Prop2&rsquo;s value 1 Apple 1 10 2 20 2 Orange 3 30 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propList&quot;: [ { &quot;id&quot;: 1, &quot;value&quot;: &quot;10&quot; }, { &quot;id&quot;: 2, &quot;value&quot;: &quot;20&quot; } ] }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propList&quot;: [ { &quot;id&quot;: 3, &quot;value&quot;: &quot;30&quot; } ] }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;propList&quot;: [] } ] } Vertical-list in vertical-keyed-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name PropID PropValue [Item]&lt;uint32&gt; string [Prop]int32 int64 Item&rsquo;s ID Item&rsquo;s name Prop&rsquo;s ID Prop&rsquo;s value 1 Apple 1 10 2 Orange 1 20 2 Banana 2 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:&quot;PropID&quot;}]; int64 prop_value = 2 [(tableau.field) = {name:&quot;PropValue&quot;}]; } } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propList&quot;: [ { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;10&quot; } ] }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propList&quot;: [ { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;20&quot; }, { &quot;propId&quot;: 2, &quot;propValue&quot;: &quot;30&quot; } ] } ] } Incell-list in vertical-keyed-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Prop [Item]uint32 []int32 Item&rsquo;s ID Item&rsquo;s props 1 10,20,30 2 10,20 3 10 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; repeated int32 prop_list = 2 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_INCELL}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;propList&quot;: [ 10, 20, 30 ] }, { &quot;id&quot;: 2, &quot;propList&quot;: [ 10, 20 ] }, { &quot;id&quot;: 3, &quot;propList&quot;: [ 10 ] } ] } First-field in horizontal-list # Horizontal-list in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name [Reward][Item]int32 int32 int32 int32 string int32 int32 string Item1&rsquo;s ID Item1&rsquo;s num Item2&rsquo;s ID Item2&rsquo;s num Reward&rsquo;s name Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name 1 10 2 20 Lotto 10 100 Super Lotto Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Reward reward_list = 1 [(tableau.field) = {name:&quot;Reward&quot; layout:LAYOUT_HORIZONTAL}]; message Reward { repeated Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;rewardList&quot;: [ { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ], &quot;name&quot;: &quot;Lotto&quot; }, { &quot;itemList&quot;: [ { &quot;id&quot;: 10, &quot;num&quot;: 100 } ], &quot;name&quot;: &quot;Super Lotto&quot; } ] } Predefined-struct-list in horizontal-list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name [Reward][.Item]int32 int32 int32 int32 string int32 int32 string Item1&rsquo;s ID Item1&rsquo;s num Item2&rsquo;s ID Item2&rsquo;s num Reward&rsquo;s name Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name 1 10 2 20 Lotto 10 100 Super Lotto Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Reward reward_list = 1 [(tableau.field) = {name:&quot;Reward&quot; layout:LAYOUT_HORIZONTAL}]; message Reward { repeated protoconf.Item item_list = 1 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;rewardList&quot;: [ { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ], &quot;name&quot;: &quot;Lotto&quot; }, { &quot;itemList&quot;: [ { &quot;id&quot;: 10, &quot;num&quot;: 100 } ], &quot;name&quot;: &quot;Super Lotto&quot; } ] } `}).add({id:50,href:"/docs/excel/list-in-map/",title:"List in map",description:"Excel list in map guide.",content:`Nested in vertical-map # Horizontal-list in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name Prop1ID Prop1Value Prop2ID Prop2Value map&lt;uint32, Item&gt; string [Prop]int32 int64 int32 int64 Item&rsquo;s ID Item&rsquo;s name Prop1&rsquo;s ID Prop1&rsquo;s value Prop2&rsquo;s ID Prop2&rsquo;s value 1 Apple 1 10 2 20 2 Orange 3 30 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propList&quot;: [ { &quot;id&quot;: 1, &quot;value&quot;: &quot;10&quot; }, { &quot;id&quot;: 2, &quot;value&quot;: &quot;20&quot; } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propList&quot;: [ { &quot;id&quot;: 3, &quot;value&quot;: &quot;30&quot; } ] }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;propList&quot;: [] } } } Vertical-list in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name PropID PropValue map&lt;uint32, Item&gt; string [Prop]int32 int64 Item&rsquo;s ID Item&rsquo;s name Prop&rsquo;s ID Prop&rsquo;s value 1 Apple 1 10 2 Orange 1 20 2 Banana 2 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:&quot;PropID&quot;}]; int64 prop_value = 2 [(tableau.field) = {name:&quot;PropValue&quot;}]; } } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propList&quot;: [ { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;10&quot; } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propList&quot;: [ { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;20&quot; }, { &quot;propId&quot;: 2, &quot;propValue&quot;: &quot;30&quot; } ] } } } Incell-list in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Prop map&lt;uint32, Item&gt; []int32 Item&rsquo;s ID Item&rsquo;s props 1 10,20,30 2 10,20 3 10 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; repeated int32 prop_list = 2 [(tableau.field) = {name:&quot;Prop&quot; layout:LAYOUT_INCELL}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;propList&quot;: [ 10, 20, 30 ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;propList&quot;: [ 10, 20 ] }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;propList&quot;: [ 10 ] } } } Incell-struct-list in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Item map&lt;uint32, Reward&gt; []{uint32 ID,int32 Num}Item Reward&rsquo;s ID Reward&rsquo;s items 1 1001:10,1002:20,1003:30 2 2001:10,2002:20 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Reward&gt; reward_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Reward { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; repeated Item item_list = 2 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;itemList&quot;: [ { &quot;id&quot;: 1001, &quot;num&quot;: 10 }, { &quot;id&quot;: 1002, &quot;num&quot;: 20 }, { &quot;id&quot;: 1003, &quot;num&quot;: 30 } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;itemList&quot;: [ { &quot;id&quot;: 2001, &quot;num&quot;: 10 }, { &quot;id&quot;: 2002, &quot;num&quot;: 20 } ] } } } Nested in horizontal-map # Horizontal-list in horizontal-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1ID Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward2ID Reward2Item1ID Reward2Item1Num map&lt;uint32, Reward&gt; [Item]uint32 int32 uint32 int32 uint32 uint32 int32 Reward1 ID Reward1 item1 ID Reward1 item1 num Reward1 item2 ID Reward1 item2 num Reward2 ID Reward2 item1 ID Reward2 item1 num 1 1 10 2 20 2 3 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Reward&gt; reward_map = 1 [(tableau.field) = {name:&quot;Reward&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; // Reward message Reward { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; // ID repeated Item item_list = 2 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_HORIZONTAL}]; // item message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; // ID int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; // num } } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;itemList&quot;: [ { &quot;id&quot;: 3, &quot;num&quot;: 30 } ] } } } Incell-list in horizontal-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1ID Reward1Item Reward2ID Reward2Item map&lt;uint32, Reward&gt; []{uint32 ID,int32 Num}Item uint32 []Item Reward1 ID Reward1 items Reward2 ID Reward2 items 1 1:10,2:20 2 3:30 For predefined struct list, you can use []{.Item} instead of []{uint32 ID,int32 Num}Item.
Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Reward&gt; reward_map = 1 [(tableau.field) = {name:&quot;Reward&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; // Reward message Reward { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; // ID repeated Item item_list = 2 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL span:SPAN_INNER_CELL}]; // items message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;num&quot;: 10 }, { &quot;id&quot;: 2, &quot;num&quot;: 20 } ] }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;itemList&quot;: [ { &quot;id&quot;: 3, &quot;num&quot;: 30 } ] } } } `}).add({id:51,href:"/docs/excel/map-in-list/",title:"Map in list",description:"Excel map in list guide.",content:`Nested in vertical-list # Horizontal-map in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name Prop1ID Prop1Value Prop2ID Prop2Value [Item]uint32 string map&lt;int32, Prop&gt; int64 int32 int64 Item&rsquo;s ID Item&rsquo;s name Prop1&rsquo;s ID Prop1&rsquo;s value Prop2&rsquo;s ID Prop2&rsquo;s value 1 Apple 1 10 2 20 2 Orange 3 30 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; map&lt;int32, Prop&gt; prop_map = 3 [(tableau.field) = {name:&quot;Prop&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;value&quot;: &quot;10&quot; }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;value&quot;: &quot;20&quot; } } }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propMap&quot;: { &quot;3&quot;: { &quot;id&quot;: 3, &quot;value&quot;: &quot;30&quot; } } }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;propMap&quot;: {} } ] } Vertical-map in vertical-keyed-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name PropID PropValue [Item]&lt;uint32&gt; string map&lt;int32, Prop&gt; int64 Item&rsquo;s ID Item&rsquo;s name Prop&rsquo;s ID Prop&rsquo;s value 1 Apple 1 10 2 Orange 1 20 2 Banana 2 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; map&lt;int32, Prop&gt; prop_map = 3 [(tableau.field) = {key:&quot;PropID&quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:&quot;PropID&quot;}]; int64 prop_value = 2 [(tableau.field) = {name:&quot;PropValue&quot;}]; } } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propMap&quot;: { &quot;1&quot;: { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;10&quot; } } }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propMap&quot;: { &quot;1&quot;: { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;20&quot; }, &quot;2&quot;: { &quot;propId&quot;: 2, &quot;propValue&quot;: &quot;30&quot; } } } ] } Incell-map in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Props [Item]uint32 map&lt;int32, string&gt; Item&rsquo;s ID Item&rsquo;s props 1 1:sour,2:sweet,3:delicious 2 1:sour,2:sweet 3 1:sour Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; map&lt;int32, string&gt; props_map = 2 [(tableau.field) = {name:&quot;Props&quot; layout:LAYOUT_INCELL}]; } } ItemConf.json { &quot;itemList&quot;: [ { &quot;id&quot;: 1, &quot;propsMap&quot;: { &quot;1&quot;: &quot;sour&quot;, &quot;2&quot;: &quot;sweet&quot;, &quot;3&quot;: &quot;delicious&quot; } }, { &quot;id&quot;: 2, &quot;propsMap&quot;: { &quot;1&quot;: &quot;sour&quot;, &quot;2&quot;: &quot;sweet&quot; } }, { &quot;id&quot;: 3, &quot;propsMap&quot;: { &quot;1&quot;: &quot;sour&quot; } } ] } First-field in horizontal-list # Horizontal-map in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name [Reward]map&lt;int32, Item&gt; int32 int32 int32 string int32 int32 string Item1&rsquo;s ID Item1&rsquo;s num Item2&rsquo;s ID Item2&rsquo;s num Reward&rsquo;s name Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name 1 10 2 20 Lotto 10 100 Super Lotto Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Reward reward_list = 1 [(tableau.field) = {name:&quot;Reward&quot; layout:LAYOUT_HORIZONTAL}]; message Reward { map&lt;int32, Item&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;rewardList&quot;: [ { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 } }, &quot;name&quot;: &quot;Lotto&quot; }, { &quot;itemMap&quot;: { &quot;10&quot;: { &quot;id&quot;: 10, &quot;num&quot;: 100 } }, &quot;name&quot;: &quot;Super Lotto&quot; } ] } Predefined-struct-map in horizontal-list # Item in common.proto is predefined as:
message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; } A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name [Reward]map&lt;int32, .Item&gt; int32 int32 int32 string int32 int32 string Item1&rsquo;s ID Item1&rsquo;s num Item2&rsquo;s ID Item2&rsquo;s num Reward&rsquo;s name Item1&rsquo;s ID Item1&rsquo;s num Reward&rsquo;s name 1 10 2 20 Lotto 10 100 Super Lotto Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; repeated Reward reward_list = 1 [(tableau.field) = {name:&quot;Reward&quot; layout:LAYOUT_HORIZONTAL}]; message Reward { map&lt;int32, protoconf.Item&gt; item_map = 1 [(tableau.field) = {name:&quot;Item&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } ItemConf.json { &quot;rewardList&quot;: [ { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 } }, &quot;name&quot;: &quot;Lotto&quot; }, { &quot;itemMap&quot;: { &quot;10&quot;: { &quot;id&quot;: 10, &quot;num&quot;: 100 } }, &quot;name&quot;: &quot;Super Lotto&quot; } ] } `}).add({id:52,href:"/docs/excel/map-in-map/",title:"Map in map",description:"Excel map in map guide.",content:`Nested in vertical-map # Horizontal-map in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name Prop1ID Prop1Value Prop2ID Prop2Value map&lt;uint32, Item&gt; string map&lt;int32, Prop&gt; int64 int32 int64 Item&rsquo;s ID Item&rsquo;s name Prop1&rsquo;s ID Prop1&rsquo;s value Prop2&rsquo;s ID Prop2&rsquo;s value 1 Apple 1 10 2 20 2 Orange 3 30 3 Banana Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; map&lt;int32, Prop&gt; prop_map = 3 [(tableau.field) = {name:&quot;Prop&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; int64 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;value&quot;: &quot;10&quot; }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;value&quot;: &quot;20&quot; } } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propMap&quot;: { &quot;3&quot;: { &quot;id&quot;: 3, &quot;value&quot;: &quot;30&quot; } } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;propMap&quot;: {} } } } Vertical-map in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Name PropID PropValue map&lt;uint32, Item&gt; string map&lt;int32, Prop&gt; int64 Item&rsquo;s ID Item&rsquo;s name Prop&rsquo;s ID Prop&rsquo;s value 1 Apple 1 10 2 Orange 1 20 2 Orange 2 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; map&lt;int32, Prop&gt; prop_map = 3 [(tableau.field) = {key:&quot;PropID&quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:&quot;PropID&quot;}]; int64 prop_value = 2 [(tableau.field) = {name:&quot;PropValue&quot;}]; } } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;propMap&quot;: { &quot;1&quot;: { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;10&quot; } } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;propMap&quot;: { &quot;1&quot;: { &quot;propId&quot;: 1, &quot;propValue&quot;: &quot;20&quot; }, &quot;2&quot;: { &quot;propId&quot;: 2, &quot;propValue&quot;: &quot;30&quot; } } } } } Incell-map in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Props map&lt;uint32, Item&gt; map&lt;int32, string&gt; Item&rsquo;s ID Item&rsquo;s props 1 1:sour,2:sweet,3:delicious 2 1:sour,2:sweet 3 1:sour Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; map&lt;int32, string&gt; props_map = 2 [(tableau.field) = {name:&quot;Props&quot; layout:LAYOUT_INCELL}]; } } ItemConf.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;propsMap&quot;: { &quot;1&quot;: &quot;sour&quot;, &quot;2&quot;: &quot;sweet&quot;, &quot;3&quot;: &quot;delicious&quot; } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;propsMap&quot;: { &quot;1&quot;: &quot;sour&quot;, &quot;2&quot;: &quot;sweet&quot; } }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;propsMap&quot;: { &quot;1&quot;: &quot;sour&quot; } } } } Nested in horizontal-map # Horizontal-map in horizontal-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1ID Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward2ID Reward2Item1ID Reward2Item1Num map&lt;uint32, Reward&gt; map&lt;uint32, Item&gt; int32 uint32 int32 uint32 uint32 int32 Reward1 ID Reward1 item1 ID Reward1 item1 num Reward1 item2 ID Reward1 item2 num Reward2 ID Reward2 item1 ID Reward2 item1 num 1 1 10 2 20 2 3 30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Reward&gt; reward_map = 1 [(tableau.field) = {name:&quot;Reward&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; // Reward message Reward { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; // ID map&lt;uint32, Item&gt; item_map = 2 [(tableau.field) = {name:&quot;Item&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; // item message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; // ID int32 num = 2 [(tableau.field) = {name:&quot;Num&quot;}]; // num } } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;num&quot;: 10 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;num&quot;: 20 } } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;itemMap&quot;: { &quot;3&quot;: { &quot;id&quot;: 3, &quot;num&quot;: 30 } } } } } Incell-map in horizontal-map # A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU Reward1ID Reward1Item Reward2ID Reward2Item map&lt;uint32, Reward&gt; map&lt;uint32, int32&gt; uint32 map&lt;uint32, int32&gt; Reward1 ID Reward1 items Reward2 ID Reward2 items 1 1:10,2:20 2 3:30 Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Reward&gt; reward_map = 1 [(tableau.field) = {name:&quot;Reward&quot; key:&quot;ID&quot; layout:LAYOUT_HORIZONTAL}]; // Reward message Reward { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; // ID map&lt;uint32, int32&gt; item_map = 2 [(tableau.field) = {name:&quot;Item&quot; layout:LAYOUT_INCELL}]; // Reward1 items } } ItemConf.json { &quot;rewardMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;itemMap&quot;: { &quot;1&quot;: 10, &quot;2&quot;: 20 } }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;itemMap&quot;: { &quot;3&quot;: 30 } } } } `}).add({id:53,href:"/docs/excel/infinite-nesting/",title:"Infinite nesting",description:"Excel infinite nesting guide.",content:`Overview # Now, the horizontal/vertical list element&rsquo;s first field can be any type, even as struct, list, and map.
List element&rsquo;s first field is struct: [Reward]{Icon}int32 List element&rsquo;s first field is predefined struct: [Cost]{.Item}uint32 List element&rsquo;s first field is in-cell struct: [Magic]{int32 Id, int32 Num}Ability List element&rsquo;s first field is list: [Reward][Item]uint32 List element&rsquo;s first field is list with element as predefined struct: [Power][.Item]uint32 List element&rsquo;s first field is map: [Superpower]map&lt;uint32, Ability&gt; TODO: some clear examples.
Nested naming # Predefined types in &ldquo;common.proto&rdquo;:
// --snip-- enum ConfType { CONF_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; CONF_TYPE_CLOUD = 1 [(tableau.evalue).name = &quot;Cloud&quot;]; CONF_TYPE_LOCAL = 2 [(tableau.evalue).name = &quot;Local&quot;]; CONF_TYPE_REMOTE = 3 [(tableau.evalue).name = &quot;Remote&quot;]; } enum ServerType { SERVER_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; SERVER_TYPE_GAME = 1 [(tableau.evalue).name = &quot;GameServer&quot;]; SERVER_TYPE_ACTIVITY = 2 [(tableau.evalue).name = &quot;ActivityServer&quot;]; SERVER_TYPE_MATCH = 3 [(tableau.evalue).name = &quot;MatchServer&quot;]; } HelloWorld.xlsx&nbsp; LoaderConf @TABLEAU ServerType ServerConfType ServerConfConditionType ServerConfConditionValue map&lt;enum&lt;.ServerType&gt;, Server&gt; [Conf]&lt;enum&lt;.ConfType&raquo; [Condition] int32 Server name Sheet name Condition type Condition value SERVER_TYPE_GAME CONF_TYPE_CLOUD 0 113 0 134 SERVER_TYPE_ACTIVITY CONF_TYPE_CLOUD 1 CONF_TYPE_LOCAL 9 34 CONF_TYPE_LOCAL 9 12 CONF_TYPE_LOCAL Remote MatchServer CONF_TYPE_UNKNOWN Sheet Nested LoaderConf true Generated:
hello_world.proto // --snip-- import &quot;common.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message LoaderConf { option (tableau.worksheet) = {name:&quot;LoaderConf&quot; nested:true}; map&lt;int32, Server&gt; server_map = 1 [(tableau.field) = {name:&quot;Server&quot; key:&quot;Type&quot; layout:LAYOUT_VERTICAL}]; message Server { ServerType type = 1 [(tableau.field) = {name:&quot;Type&quot;}]; repeated Conf conf_list = 2 [(tableau.field) = {name:&quot;Conf&quot; key:&quot;Type&quot; layout:LAYOUT_VERTICAL}]; message Conf { ConfType type = 1 [(tableau.field) = {name:&quot;Type&quot;}]; repeated Condition condition_list = 2 [(tableau.field) = {name:&quot;Condition&quot; key:&quot;Type&quot; layout:LAYOUT_VERTICAL}]; message Condition { int32 type = 1 [(tableau.field) = {name:&quot;Type&quot;}]; int32 value = 2 [(tableau.field) = {name:&quot;Value&quot;}]; } } } } loader_conf.json { &quot;serverMap&quot;: { &quot;1&quot;: { &quot;type&quot;: &quot;SERVER_TYPE_GAME&quot;, &quot;confList&quot;: [ { &quot;type&quot;: &quot;CONF_TYPE_CLOUD&quot;, &quot;conditionList&quot;: [ { &quot;type&quot;: 0, &quot;value&quot;: 113 } ] } ] }, &quot;2&quot;: { &quot;type&quot;: &quot;SERVER_TYPE_ACTIVITY&quot;, &quot;confList&quot;: [ { &quot;type&quot;: &quot;CONF_TYPE_CLOUD&quot;, &quot;conditionList&quot;: [] }, { &quot;type&quot;: &quot;CONF_TYPE_LOCAL&quot;, &quot;conditionList&quot;: [ { &quot;type&quot;: 9, &quot;value&quot;: 34 } ] }, { &quot;type&quot;: &quot;CONF_TYPE_REMOTE&quot;, &quot;conditionList&quot;: [] } ] }, &quot;3&quot;: { &quot;type&quot;: &quot;SERVER_TYPE_MATCH&quot;, &quot;confList&quot;: [] } } } `}).add({id:54,href:"/docs/excel/field-property/",title:"Field property",description:"Tableau field property guide.",content:`Overview # Option Type Description unique bool Check field uniqueness. Default: false. Specially for map (or KeyedList) key, default will be auto deduced. range string Format: &quot;left, right&quot;. E.g.: &quot;1,10&quot;, &quot;1,~&quot;, &quot;~,10&quot;. Different interpretations of range: - number: value range. - string: count of utf-8 code point. refer string Format: &quot;SheetName(SheetAlias).ColumnName&quot;.
Ensure this field is in another sheet&rsquo;s column value space. Multiple refers are comma-separated. sequence int64 Ensure this field&rsquo;s value is a sequence and begins with this value. default string Use this default value if cell is empty. fixed bool Auto-detected fixed size of horizontal list/map. Default: false. size uint32 Specify fixed size of horizontal list/map. form Form Specify cell data form of incell struct.
- FORM_TEXT
- FORM_JSON json_name string Specify field&rsquo;s custom JSON name instead of lowerCamelCase name of proto field name. present bool Must fill cell data explicitly if present is true. Default: false. optional bool Whether this field is optional (field name existence). patch Patch Field patch type. - PATCH_REPLACE - PATCH_MERGE sep string Field-level separator. subsep string Field-level subseparator. cross int32 Specify count of crossed nodes/cells/fields of composite types with cardinality, such as list and map. Option unique # Option unique can be specified as true or false in the field property. It can check the uniqueness of any scalar field in list/map element.
If you set unique to true explicitly, then tableau will report an error if a duplicate key is appeared. If you set unique to false explicitly, no check will be performed. Map (or KeyedList) key # Tableau will auto deduce the map (or KeyedList) key&rsquo;s unique as true or not.
The rule is: if a map&rsquo;s value type (or KeyedList element type) has no sub map/list field of the same layout (vertical/horizontal), then the key must be unique.
So in most cases, it&rsquo;s not neccessary to config it explicitly.
General scalar field # If you specify a general scalar field&rsquo;s property unique as true, then tableau will check the field&rsquo;s uniquness in map or list.
Option range # ⚠️️ This check option will not be applied if cell data is empty (not present). So if you still want to check even if cell data is empty, then you should set option \`present\` to true. Option range can be specified as format: &quot;left, right&quot; (left and right are both inclusive).
Different interpretations of range:
number: value range, e.g.: &quot;1,10&quot;, &quot;1,~&quot;, &quot;~,10&quot;. string: count of utf-8 code point. list: length of list. map: length of map. Option refer # Option refer is some like the FOREIGN KEY constraint in SQL to prevent actions that would destroy links between tables. However, tableau refer can refer to any sheet&rsquo;s column even if it is not map key column, and multiple refers (comma-separated) are also supported. It is used to ensure this field is at least in one of the other sheets&rsquo; column value space (aka message&rsquo;s field value space).
Format: &quot;SheetName(SheetAlias).ColumnName[,SheetName(SheetAlias).ColumnName]...&quot;.
For example:
map&lt;uint32, Reward&gt;|{refer:&quot;ItemConf.ID&quot;}: single-refer without alias, so sheet name is just the generated protobuf message name. map&lt;uint32, Reward&gt;|{refer:&quot;ItemConf.ID,EquipConf.ID&quot;}: multi-refer without alias, then sheet alias is the generated protobuf message name. map&lt;uint32, Reward&gt;|{refer:&quot;Sheet1(ItemConf).ID&quot;}: single-refer with alias, then sheet alias is the generated protobuf message name. Option sequence # Option sequence is used to ensure this field’s value is a sequence and begins with this value. It can be used for any fields even in nested list/map.
For example:
map&lt;uint32, Item&gt;|{sequence:1}: this map key must follow the sequence rule which begins with value 1. int32|{sequence:1}: the parent list/map elements must follow the sequence rule which begins with value 1. Option default # If option default is set, then use it as default value if cell is empty.
Option fixed # If option fixed is set as true, then auto-detect fixed size of horizontal list/map.
For example:
List: implicit fixed size → Map: implicit fixed size → Option size # Option size is used to specify fixed size of horizontal list/map.
For example:
List: explicit fixed size → Map: explicit fixed size → Option form # Option form is used to specify cell data form of incell struct.
Two kinds of form can be specified:
FORM_TEXT: protobuf text format. FORM_JSON: protobuf JSON format. For detailed demos, see Advanced predefined incell struct →.
Option json_name # By default, JSON name is deduced from the field&rsquo;s proto name by converting it to camelCase. Now you can explicitly specify it by json_name prop option.
For example, a worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; ItemConf @TABLEAU ID Rarity_1 SpecialEffect_2 map&lt;int32, Item&gt; int32|{json_name:&ldquo;rarity_1&rdquo;} int32|{json_name:&ldquo;specialEffect_2&rdquo;} Item&rsquo;s ID Item&rsquo;s rarity. Item&rsquo;s special effect. 1 10 101 2 20 102 3 30 103 Option present # If option present is set as true, then cell data cannot be empty and must be filled explicitly. Otherwise an error will be reported.
Option optional # Specify whether this field is optional (field name existence).
If set to true, then:
table formats (Excel/CSV): field&rsquo;s column can be absent. document formats (XML/YAML): field&rsquo;s name can be absent. Option patch # See field-level patch in Option Patch →.
Option sep # Field-level separator for separating:
incell list elements (scalar or struct). incell map items. If not set, it will use sheet-level seq in metasheet.
Option subsep # Field-level subseparator for separating:
key-value pair of each incell map item. struct fields of each incell struct list element. If not set, it will use sheet-level subseq in metasheet.
Option cross # Specify count of crossed nodes/cells/fields of composite types with cardinality, such as list and map.
union list field # Specify the count of union fields the list will cross and occupy (one list element for each field). It will also change this list field&rsquo;s layout from incell to horizontal.
Value 0 means it is an incell list. Value &gt; 0 means it is a horizontal list occupying N fields. Value &lt; 0 means it is a horizontal list occupying all following fields. TODO: example illustrated.
`}).add({id:55,href:"/docs/excel/metasheet/",title:"Metasheet",description:"Excel metasheet @TABLEAU guide.",content:`Overview # Options below can be specified in the metasheet @TABLEAU to affect the corresponding worksheet&rsquo;s layout, ability, loader and so on.
Option Type Description Sheet string The worksheet name to be processed. Specially, # refers to the workbook name, so you can set workbook&rsquo;s Alias. Alias string For worksheet, alias is used as proto message name. For workbook #, alias is used as proto file name (without file extension). Namerow int32 Exact row number of column name definition at a worksheet.
Default: 1. Typerow int32 Exact row number of column type definition at a worksheet.
Default: 2. Noterow int32 Exact row number of column note definition at a worksheet.
Default: 3. Datarow int32 Start row number of data at a worksheet.
Default: 4. Nameline int32 The line number of column name definition in a cell. 0 means the whole cell.
Default: 0. Typeline int32 The line number of column type definition in a cell. 0 means the whole cell.
Default: 0. Transpose bool Interchanging the rows and columns of a given sheet. Nested bool Nested naming of the namerow.
Default: false. Sep string Sheet-level separator. Subsep string Sheet-level subseparator. Merger []string Merge multiple sheets (comma-separated) into one with the same structure. Each element can be:
- just a workbook file path or glob path (relative to this workbook): &lt;Workbook&gt;, then the sheet name is the same as this sheet.
- a workbook file path (relative to this workbook) with a worksheet name: &lt;Workbook&gt;#&lt;Worksheet&gt;. AdjacentKey bool Merge adjacent rows with the same key. If the key cell is not set, it will be treated the same as the nearest key above the same column.
Default:false. FieldPresence bool In order to track field presence of basic types (numeric, string, bytes, and enums), the generated field will be labeled optional.
Default:false. Mode Mode Sheet mode. Available modes: - MODE_ENUM_TYPE - MODE_ENUM_TYPE_MULTI - MODE_STRUCT_TYPE - MODE_STRUCT_TYPE_MULTI - MODE_UNION_TYPE
- MODE_UNION_TYPE_MULTI Scatter []string Convert multiple sheets separately with same schema. Each element can be: - a workbook name or Glob which is relative to this workbook: &lt;Workbook&gt;, then the sheet name is the same as this sheet. - or a workbook name which is relative to this workbook with a worksheet name: &lt;Workbook&gt;#&lt;Worksheet&gt;. Optional bool Whether all fields in this sheet are optional (field name existence). Patch Patch Sheet patch type. - PATCH_REPLACE - PATCH_MERGE WithParentDir bool confgen: export JSON/Bin/Text files with parent dir created. ScatterWithoutBookName bool confgen(scatter): export JSON/Bin/Text filenames without book name prefix. OrderedMap bool Generate OrderedMap accessers or not. Index []string Generate index accessers, and multiple indexes are comma-separated. - Single-column index is in the forma: &lt;ColumnName&gt;[@IndexName], if IndexName is not set, it will be this column&rsquo;s parent struct type name.
- Multi-column index (or composite index) is in the form: ([column1, column2, column3,...])[@IndexName]
E.g.: - ID
- ID@Item
- (ID,Type)
- (ID,Type)@Item
- ID, (ID,Type)@Item
Supported: C++, Go. LangOptions map&lt;string, string&gt; Specify loader language options. Valid keys are: OrderedMap, Index. Different kvs must be seperated by , and one key value must be seperated by :. If one key doesn&rsquo;t exist in map, it means that this loader option is supported in all languages. Valid values are all combinations of cpp, go with space as seperator. Examples: - OrderedMap:cpp,Index:cpp go // ordered map supported in cpp, index supported in cpp and go - OrderedMap:cpp // ordered map supported in cpp, index supported in all languages Empty @TABLEAU # If metasheet @TABLEAU is empty, then all other worksheets in the same workbook will be processed.
A simple example # There is a worksheet Sheet1 in HelloWorld.xlsx, we want to rename sheet to ItemConf, define custom seperator as |, and generate ordered map accessers.
So the metasheet @TABLEAU in HelloWorld.xlsx should be configured as:
HelloWorld.xlsx&nbsp; Sheet1 @TABLEAU ID Name map&lt;uint32, Item&gt; string Item&rsquo;s ID Item&rsquo;s Name 1 Apple 2 Orange 3 Banana Sheet Alias Sep OrderedMap Sheet1 ItemConf | true Workbook Alias # The generated proto file name is the snake case of input file name. For example, if you have a workbook named HelloWorld.xlsx, the generated proto file name is hello_world.proto. If you want to manually specify a name for the generated proto file, you can also use the Alias option. In this scenario, # refers to the workbook name.
A worksheet ItemConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; Sheet1 @TABLEAU ID Name map&lt;uint32, Item&gt; string Item&rsquo;s ID Item&rsquo;s Name 1 Apple 2 Orange 3 Banana Sheet Alias # custom_conf Sheet1 ItemConf Generated:
custom_conf.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; } } Option Mode # Sheet mode defines how tableauc (protogen) parses the sheet: data or types.
Available modes:
MODE_DEFAULT: Default mode, which defines sheet&rsquo;s data structure. MODE_ENUM_TYPE: Define single enum type in a sheet, see Example. MODE_ENUM_TYPE_MULTI: Define multiple enum types in a sheet, see Example. MODE_STRUCT_TYPE: Define single struct type in a sheet, see Example. MODE_STRUCT_TYPE_MULTI: Define multiple struct types in a sheet, see Example. MODE_UNION_TYPE: Define single union type in a sheet, see Example. MODE_UNION_TYPE_MULTI: Define multiple union types in a sheet, see Example. Option Transpose # In linear algebra, transpose of a matrix is an operator which flips a matrix over its diagonal. Likewise, transpose of a sheet (2D matrix) means interchanging its rows into columns or vice versa.
See more details about Excel: Transpose (rotate) data from rows to columns or vice versa.
Option Transpose is specified as true in the metasheet @TABLEAU.
A worksheet HeroConf in HelloWorld.xlsx:
HelloWorld.xlsx&nbsp; HeroConf @TABLEAU ID int32 Hero&rsquo;s ID 123 Name string Hero&rsquo;s name Robin Desc string Hero&rsquo;s description A big hero! Skill []int32 Hero&rsquo;s skills 100,101,102 Sheet Transpose HeroConf true Generated:
hello_world.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message HeroConf { option (tableau.worksheet) = {name:&quot;HeroConf&quot; transpose:true}; int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; repeated int32 skill_list = 4 [(tableau.field) = {name:&quot;Skill&quot; layout:LAYOUT_INCELL}]; } HeroConf.json { &quot;id&quot;: 123, &quot;name&quot;: &quot;Robin&quot;, &quot;desc&quot;: &quot;A big hero!&quot;, &quot;skillList&quot;: [ 100, 101, 102 ] } Option Merger # Option Merger is used to merge multiple sheets (comma-separated) with same schema to one.
Each element can be:
just a workbook file path or Glob path (relative to this workbook): &lt;Workbook&gt;, then the sheet name is the same as this sheet. a workbook file path (relative to this workbook) with a worksheet name: &lt;Workbook&gt;#&lt;Worksheet&gt;. ⓘ Glob pattern usually should not match the main workbook. If matched, then tableauc will auto eliminate it. For example:
The first (main) workbook: a worksheet ZoneConf in MergerMain.xlsx (with @TABLEAU):
MergerMain.xlsx&nbsp; ZoneConf @TABLEAU ID Name Difficulty map&lt;uint32, Zone&gt; string int32 Zone’s ID Zone’s name Zone’s difficulty 1 Infinity 100 Sheet Merger ZoneConf Merger*.xlsx The second (sub) workbook: a worksheet ZoneConf in Merger2.xlsx (without @TABLEAU):
Merger2.xlsx&nbsp; ZoneConf ID Name Difficulty map&lt;uint32, Zone&gt; string int32 Zone’s ID Zone’s name Zone’s difficulty 2 Desert 200 The third (sub) workbook: a worksheet ZoneConf in Merger3.xlsx (without @TABLEAU):
Merger3.xlsx&nbsp; ZoneConf ID Name Difficulty map&lt;uint32, Zone&gt; string int32 Zone’s ID Zone’s name Zone’s difficulty 3 Snowfield 300 Generated:
merger_main.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ZoneConf { option (tableau.worksheet) = {name:&quot;ZoneConf&quot; merger:&quot;Merger*.xlsx&quot;}; map&lt;uint32, Zone&gt; zone_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Zone { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; int32 difficulty = 3 [(tableau.field) = {name:&quot;Difficulty&quot;}]; } } HeroConf.json { &quot;zoneMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Infinity&quot;, &quot;difficulty&quot;: 100 }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Desert&quot;, &quot;difficulty&quot;: 200 }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Snowfield&quot;, &quot;difficulty&quot;: 300 } } } Option Scatter # Option Scatter is used to scatter multiple sheets (comma-separated) with same schema to different generated config files.
Each element can be:
just a workbook file path or Glob path (relative to this workbook): &lt;Workbook&gt;, then the sheet name is the same as this sheet. a workbook file path (relative to this workbook) with a worksheet name: &lt;Workbook&gt;#&lt;Worksheet&gt;. ⓘ Glob pattern usually should not match the main workbook. If matched, then tableauc will auto eliminate it. For example, there are three workbooks (each with same sheet schema, and Scatter1.xlsx is the main workbook):
Scatter1.xlsx Scatter2.xlsx Scatter3.xlsx The first (main) workbook: a worksheet ZoneConf in Scatter1.xlsx (with @TABLEAU):
Scatter1.xlsx&nbsp; ZoneConf @TABLEAU ID Name Difficulty map&lt;uint32, Zone&gt; string int32 Zone’s ID Zone’s name Zone’s difficulty 1 Infinity 100 Sheet Scatter ZoneConf Scatter*.xlsx The second (sub) workbook: a worksheet ZoneConf in Scatter2.xlsx (without @TABLEAU):
Scatter2.xlsx&nbsp; ZoneConf ID Name Difficulty map&lt;uint32, Zone&gt; string int32 Zone’s ID Zone’s name Zone’s difficulty 2 Desert 200 The third (sub) workbook: a worksheet ZoneConf in Scatter3.xlsx (without @TABLEAU):
Scatter3.xlsx&nbsp; ZoneConf ID Name Difficulty map&lt;uint32, Zone&gt; string int32 Zone’s ID Zone’s name Zone’s difficulty 3 Snowfield 300 Generated protoconf:
scatter_1.proto // --snip-- option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ZoneConf { option (tableau.worksheet) = {name:&quot;ZoneConf&quot; scatter:&quot;Scatter*.xlsx&quot;}; map&lt;uint32, Zone&gt; zone_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Zone { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; int32 difficulty = 3 [(tableau.field) = {name:&quot;Difficulty&quot;}]; } } It is supposed to generate three different config files (name pattern: &lt;BookName&gt;_&lt;SheetName&gt;):
Scatter1_ZoneConf.json { &quot;zoneMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Infinity&quot;, &quot;difficulty&quot;: 100 } } } Scatter2_ZoneConf.json { &quot;zoneMap&quot;: { &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Desert&quot;, &quot;difficulty&quot;: 200 } } } Scatter3_ZoneConf.json { &quot;zoneMap&quot;: { &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Snowfield&quot;, &quot;difficulty&quot;: 300 } } } Option OrderedMap # If you set OrderedMap to true, then tableau loader plugins will generate ordered map APIs:
C++: OrderedMap API Go: OrderedMap API Option Index # Option Index can be specified to generate index accessers, and multiple indexes are comma-separated. There are two kinds of indexes in tableau: one is single-column index, and another is multi-column index (aka composite index).
If you set Index appropriately, then tableau loader plugins will generate index APIs:
C++: Index API Go: Index API Each column type can be:
scalar: numbers, booleans, strings, and bytes. enum: e.g.: enum&lt;.FruiteType&gt; incell scalar list: e.g: []int32 incell enum list: e.g: []enum&lt;.FruiteType&gt; Example: two worksheets ItemConf and ShopConf in HelloWorld.xlsx:
ItemConf: index on columns of the same struct as map value. ShopConf: index on columns of the same struct as list element. HelloWorld.xlsx&nbsp; ItemConf ShopConf @TABLEAU ID Name Desc map&lt;int32, Item&gt; string string Item&rsquo;s ID Item&rsquo;s name Item&rsquo;s desc 1 Apple A kind of delicious fruit. 2 Orange A kind of sour fruit. 3 Banana A kind of calorie-rich fruit. ID Type Desc [Shop]int32 int32 string Shop&rsquo;s ID Shop&rsquo;s type Shop&rsquo;s desc 1 1 Shoes shop. 2 1 T-Shirt shop. 3 2 Fruite shop. Sheet Index ItemConf ID@Item, Name@AwardItem, (ID,Name)@SpecialItem ShopConf ID@Shop, Type@ThemeShop, (ID,Type)@SpecialShop Single-column index # Format: &lt;ColumnName&gt;[@IndexName].
The sign @ is the separator between column name and index name. if IndexName is not set, it will be this column’s parent struct type name. One or more indexes can be specified by comma-separated rule.
Examples:
ID ID@Item ID, Name@AwardItem ID@Item, Name@AwardItem Multi-column index # Format: ([ColumnName1, ColumnName2, ColumnName3,...])[@IndexName].
Multi-column index (or composite index) is composed of multiple columns in the same struct (in list or map) to increase query speed.
The sign @ is the separator between enclosed column names by parentheses and index name. if IndexName is not set, it will be this column’s parent struct type name. One or more indexes can be specified by comma-separated rule.
Examples:
(ID,Name) (ID,Name)@AwardItem ID@Item, (ID,Name)@AwardItem: one single-column index and one multi-column index. Option Patch # // Patch type for both sheet-level and field-level. enum Patch { PATCH_NONE = 0; // 1 Sheet-level patch option &quot;PATCH_REPLACE&quot; // - replace whole message // 2 Top-field patch option &quot;PATCH_REPLACE&quot; // - list: Clear field firstly, and then all elements of this list field // in src are appended to the corresponded list fields in dst. // - map: Clear field firstly, and then all entries of this map field in src // are copied into the corresponding map field in dst. PATCH_REPLACE = 1; // Merge src into dst, which must be a message with the same descriptor. // - scalar: Populated scalar fields in src are copied to dst. // - message: Populated singular messages in src are merged into dst by // recursively calling [proto.Merge](https://pkg.go.dev/google.golang.org/protobuf/proto#Merge). // - list: The elements of every list field in src are appended to the // corresponded list fields in dst. // - map: The entries of every map field in src are copied into the // corresponding map field in dst, possibly replacing existing entries. // - unknown: The unknown fields of src are appended to the unknown // fields of dst. PATCH_MERGE = 2; } Option Sep # Sheet-level separator for separating:
incell list elements (scalar or struct). incell map items. If not set, it will use global-level seq (default: ,) in tableauc yaml.config.
Option Subsep # Sheet-level subseparator for separating:
key-value pair of each incell map item. struct fields of each incell struct list element. If not set, it will use global-level subseq (default: :) in tableauc yaml.config.
`}).add({id:56,href:"/docs/basics/",title:"Basics",description:"Basics of Tableau.",content:""}).add({id:57,href:"/docs/basics/concepts/",title:"Concepts",description:"Core concepts of Tableau.",content:`Terminology # Basics # Term Definition Workbook An excel file.
A bundle of CSV files named with the same prefix seperated by #. A XML file. A YAML file. Worksheet A sheet in a excel file. A CSV file. A root node of a XML file. A document in YAML file. Metasheet A worksheet named @TABLEAU to specify tableau parser options. Row The row in a sheet. Column The column in a sheet. Cell The intersection of a row and a column. In-cell The inner-side of a cell. Cross-cell Continuous cells of a row or a column. Worksheet # Term Definition Namerow Exact row number of column name definition at a worksheet.
⚠️ NOTE: each column name must be unique in a worksheet!
Default: 1. Typerow Exact row number of column type definition at a worksheet.
Default: 2. Noterow Exact row number of column note at a worksheet.
Default: 3. Datarow Start row number of data at a worksheet.
Default: 4. Nameline The line number of column name definition in a cell. 0 means the whole cell.
Default: 0. Typeline The line number of column type definition in a cell. 0 means the whole cell.
Default: 0. Sep Separator for:
1. separating in-cell list elements. 2. separating in-cell map items.
Default: ,. Subsep Subseparator for separating in-cell map Key-Value pair.
Default: :. Nested Nested naming of the namerow.
Default: false. Layout Incell, vertical(cross-cell) or horizontal(cross-cell). Transpose Interchanging the rows and columns of a given sheet. Mappings to Protoconf # Term Protoconf Workbook One protoconf(.proto) file. Worksheet One top-level message in a protoconf file, except the tableau metasheet named @TABLEAU. column One field in a message A simple mapping example # Input: an excel file # A workbook(HelloWorld.xlsx) with two data worksheets(ItemConf and ActivityConf) and an empty tableau metasheet(@TABLEAU).
HelloWorld.xlsx&nbsp; ItemConf ActivityConf @TABLEAU ID Name Type map&lt;uint32, Item&gt; string int32 Item&rsquo;s ID. Item&rsquo;s name. Item&rsquo;s type. 1 item1 100 2 item2 200 3 item3 300 ID Name Open map&lt;uint32, Activity&gt; string bool Activity&rsquo;s ID. Activity&rsquo;s name. Activity is open? 1 activity1 true 2 activity2 false 3 activity3 Output: a protoconf file # A protoconf file(hello_world.proto) with two top-level messages(ItemConf and ActivityConf).
hello_world.proto syntax = &quot;proto3&quot;; package protoconf; option go_package = &quot;github.com/tableauio/demo/examples/helloworld/protoconf&quot;; import &quot;tableau/protobuf/tableau.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message ItemConf { option (tableau.worksheet) = {name:&quot;ItemConf&quot;}; map&lt;uint32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; int32 type = 3 [(tableau.field) = {name:&quot;Type&quot;}]; } } message ActivityConf { option (tableau.worksheet) = {name:&quot;ActivityConf&quot;}; map&lt;uint32, Activity&gt; activity_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Activity { uint32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; bool open = 3 [(tableau.field) = {name:&quot;Open&quot;}]; } } `}).add({id:58,href:"/docs/basics/naming-convention/",title:"Naming convention",description:"Naming convention.",content:`All names of workbook, worksheet, column, and struct (message), should use PascalCase (with an initial capital) naming convention. So the tableau parser will treat the worksheet name as protoconf message name, and auto converts PascalCase to snake_case for protobuf message field names and file names, in order to comply with Protocol Buffers Style Guide.
Enums # Use PascalCase (with an initial capital) for enum type names and CAPITALS_WITH_UNDERSCORES for value names:
enum FooBar { FOO_BAR_UNSPECIFIED = 0; FOO_BAR_FIRST_VALUE = 1; FOO_BAR_SECOND_VALUE = 2; } See Protobuf style: enums.
Examples # Name Style Example workbook PascalCase HelloWorld.xlsx worksheet PascalCase HelloWorld struct (message) PascalCase HelloWorld field (column) PascalCase HelloWorld `}).add({id:59,href:"/docs/basics/grammar-and-types/",title:"Grammar and types",description:"Grammar and types.",content:`Overview # Tableau borrows most of its syntax and types from Protocol Buffers (proto3) and Golang.
Scalar types # Details disccused at Protocol Buffers Proto3 Scalar.
Kind Types Default Numbers int32, uint32
int64, uint64
float, double 0
0
0.0 Booleans bool false Strings string &quot;&quot; Bytes bytes &quot;&quot; Composite types # Type Description struct A struct is mapped to a protobuf message. list A list is mapped to a protobuf repeated field. map A map is mapped to a protobuf map field. struct # Feature Description Horizontal layout Each scalar field located in one cell. Simple incell struct Each field must be scalar type. It is a comma-separated list of fields. E.g.: 1,test,3.0. If the data list&rsquo;s size is not same as struct&rsquo;s fields, then fields will be filled in order. Fields not configured will be filled with default values due to its scalar type. list # Feature Description Horizontal layout This is list&rsquo;s default layout. Element type can be struct or scalar. Vertical layout List&rsquo;s element type should be struct. Simple incell list Element type must be scalar. It is a comma-separated list of elements. E.g.: 1,2,3. Scalable Scalable or dynamic list size. Ignore empty element Smart recognition of empty element at any position. map # Feature Description Horizontal layout Vertical layout This is map&rsquo;s default layout. Hash map Implemented as unordered map or hash map. Ordered map Supported by tableauio/loader.
- C++ Simple incell map Both key and value must be scalar type. It is a comma-separated list of key:value pairs. E.g.: 1:10,2:20,3:30. Scalable Scalable or dynamic map size. Ignore empty item Smart recognition of empty item at any position. Enumeration # Feature Description Three forms of enum value 1. Enum value number.
2. Enum value name.
3. Enum value alias name (with EnumValueOptions specified). Validation Auto-check legality of enum values. Empty value # Type Description scalar Empty scalar will be emplaced with scalar type&rsquo;s default value. struct Empty struct will not be spawned if all fields are empty. list Empty list will not be spawned if list&rsquo;s size is 0.
Empty struct will not be appended if list&rsquo;s element(struct type) is empty. map Empty map will not be spawned if map&rsquo;s size is 0. Empty struct will not be inserted if map&rsquo;s value(struct type) is empty. nesting Recursively empty. `}).add({id:60,href:"/docs/basics/enum/",title:"Enum",description:"Enum basics.",content:`Enum value # The tableau parser accepts three enum value forms:
enum value name. enum value number. enum value alias. It is another name in English, Chinese, or any other language, which can be specified by tableau.evalue by extending google.protobuf.EnumValueOptions. For example, enum type FruitType in common.proto is defined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 2 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 3 [(tableau.evalue).name = &quot;Banana&quot;]; } Then the three forms of enum value are all accepted:
Enum value number Enum value name Enum value alias 0 FRUIT_TYPE_UNKNOWN Unknown 1 FRUIT_TYPE_APPLE Apple 2 FRUIT_TYPE_ORANGE Orange 3 FRUIT_TYPE_BANANA Banana NOTE: Enum type must be predefined.
Go to read details about predefiend Enum type: Predefined types →.
Validation # As enum type is predefined, so the tableau parser will auto validate the enum value.
`}).add({id:61,href:"/docs/basics/wellknown-types/",title:"Wellknown types",description:"Wellknown types.",content:`Overview # For easy use, Wellknown types are built-in types in Tableau. This concept is much like Protocol Buffers Well-Known Types.
You should include the proto files provided by Tableau and Protocol Buffers:
tableau/protobuf/wellknown.proto google/protobuf/timestamp.proto google/protobuf/duration.proto Datetime # Type Default Description datetime 0000-00-00 00:00:00 Format: yyyy-MM-dd HH:mm:ss or RFC3339. e.g.: 2020-01-01 05:10:00
or 2020-01-01T05:10:00+08:00. date 0000-00-00 Format: yyyy-MM-dd or yyyyMMdd. e.g.: 2020-01-01 or 20200101. time 00:00:00 Format: HH:mm:ss or HHmmss, HH:mm or HHmm. e.g.: 05:10:00 or 051000, 05:10 or 0510. Tips:
datetime and date are based on google.protobuf.Timestamp, see JSON mapping. time is based on google.protobuf.Duration, see JSON mapping. RFC 3339: Date and Time on the Internet: Timestamps Duration # Type Default Description duration 0s Format like: 72h3m0.5s. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as 300ms, -1.5h or 2h45m. Valid time units are ns, us (or µs), ms, s, m, h. Tips:
duration is based on google.protobuf.Duration, see JSON mapping. golang duration string form. golang ParseDuration. Fraction # A fraction represents a part of a whole or, more generally, any number of equal parts. See wiki: Fraction for more details.
Type Default Description fraction 0 Format: - N%: percentage, e.g.: 10% - N‰: per thounsand, e.g.: 10‰ - N‱: per ten thounsand, e.g.: 10‱
- N/D: simple fraction, e.g.: 3/4
- N: only numerator, e.g.: 3 is same to 3/1 message Fraction { int32 num = 1; // numerator int32 den = 2; // denominator } Comparator # A comparator holds a sign and a fraction value. Any number or fraction can compare with it.
Type Default Description comparator ==0 Format: &lt;Sign&gt;&lt;Fraction&gt;. e.g.: ==10, !=1/2, &lt;10%, &lt;=10‰, &gt;10%, &gt;=10‱ message Comparator { Sign sign = 1; Fraction value = 2; enum Sign { SIGN_EQUAL = 0; // == SIGN_NOT_EQUAL = 1; // != SIGN_LESS = 2; // &lt; SIGN_LESS_OR_EQUAL = 3; // &lt;= SIGN_GREATER = 4; // &gt; SIGN_GREATER_OR_EQUAL = 5; // &gt;= } } Version # A version holds a version data with 3 formats: string, value interger and value list. A pattern option is required to parse the string into value interger, otherwise the default pattern 255.255.255 will be used.
Type Default Description str &quot;&quot; Format: &lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt;[.&lt;OTHER&gt;].... e.g.: 1.0.1 val 0 Value interger of the version, see the conversion algorithm here. major 0 Major version value, the 1st interger value of version string. minor 0 Minor version value, the 2nd interger value of version string. Zero if there is no 2nd interger value in pattern. patch 0 Patch version value, the 3rd interger value of version string. Zero if there is no 3rd interger value in pattern. others [] Other version values, the 4rd or following interger values of version string. Nil if there is no 4rd or following interger values in pattern. message Version { string str = 1; // Version in string form. uint64 val = 2; // Version in integer form. uint32 major = 3; // Major version number. uint32 minor = 4; // Minor version number. uint32 patch = 5; // Patch version number. repeated uint32 others = 6; // Other version numbers, such as build number, resource version, and so on. } `}).add({id:62,href:"/docs/basics/predefined-types/",title:"Predefined types",description:"Predefined types.",content:`Overview # You can define enum, struct, or union types in a protoconf file (such as common.proto) ahead. Then use them to specify the column type or cross-cell type of a worksheet.
Usage # Syntax: prepend a dot . to predefined CustomType (a.k.a. .CustomType) when you use it in a worksheet. Import: specify the protoFiles option of tableauc config to import the common proto files, where predefined enum, struct, union types are defined. See Tableauc config. Enum # For example, enum type FruitType in common.proto is defined as:
enum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = &quot;Unknown&quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = &quot;Apple&quot;]; FRUIT_TYPE_ORANGE = 2 [(tableau.evalue).name = &quot;Orange&quot;]; FRUIT_TYPE_BANANA = 3 [(tableau.evalue).name = &quot;Banana&quot;]; } There are some examples to demonstrate how to use predefined enum types:
Excel/CSV: Use predefined enum type. XML: Use predefined enum type YAML: Use predefined enum type Struct # For example, struct type Prop in common.proto is defined as:
message Prop { int32 id = 1 [(tableau.field).name = &quot;ID&quot;]; int32 value = 2 [(tableau.field).name = &quot;Value&quot;]; } There are some examples to demonstrate how to use predefined struct types:
Excel/CSV struct: Predefined-struct list: Vertical predefined-struct list map: Vertical predefined-struct map XML struct: Predefined-struct list: Predefined struct list map: TODO YAML struct: Predefined-struct list: Predefined struct list map: TODO In horizontal map or horizontal list, you can define custom variable name with the predefined struct. See Custom named struct.
Union # For example, struct type Target in common.proto is defined as:
// Predefined union type. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: &quot;Type&quot; }]; oneof value { option (tableau.oneof) = { field: &quot;Field&quot; }; Pvp pvp = 1; // Bound to enum value 1: TYPE_PVP. Pve pve = 2; // Bound to enum value 2: TYPE_PVP. Story story = 3; // Bound to enum value 3: TYPE_STORY. Skill skill = 4; // Bound to enum value 4: TYPE_SKILL. } enum Type { TYPE_NIL = 0; TYPE_PVP = 1 [(tableau.evalue) = { name: &quot;PVP&quot; }]; TYPE_PVE = 2 [(tableau.evalue) = { name: &quot;PVE&quot; }]; TYPE_STORY = 3 [(tableau.evalue) = { name: &quot;Story&quot; }]; TYPE_SKILL = 4 [(tableau.evalue) = { name: &quot;Skill&quot; }]; } message Pvp { int32 type = 1; // scalar int64 damage = 2; // scalar repeated protoconf.FruitType types = 3; // incell enum list } message Pve { Mission mission = 1; // incell struct repeated int32 heros = 2; // incell list map&lt;int32, int64&gt; dungeons = 3; // incell map message Mission { int32 id = 1; uint32 level = 2; int64 damage = 3; } } message Story { protoconf.Item cost = 1; // incell predefined struct map&lt;int32, protoconf.FruitType&gt; fruits = 2; // incell map with value as enum type map&lt;int32, Flavor&gt; flavors = 3; // incell map with key as enum type message Flavor { protoconf.FruitFlavor key = 1 [(tableau.field) = { name: &quot;Key&quot; }]; int32 value = 2 [(tableau.field) = { name: &quot;Value&quot; }]; } } message Skill { int32 id = 1; // scalar int64 damage = 2; // scalar // no field tag 3 } } There are some examples to demonstrate how to use predefined union types:
Excel/CSV list: Predefined union in list map: Predefined union in map XML union: Predefined union list: Predefined union list map: TODO YAML union: Predefined union list: Predefined union list map: TODO `}).add({id:63,href:"/docs/tutorial/",title:"Tutorial",description:"Tutorial of Tableau",content:""}).add({id:64,href:"/docs/tutorial/config/",title:"Tableauc config",description:"Tableauc config details",content:`config.yaml # Create a file named config.yaml, and copy configurations below to it:
# locale BCP 47 language tags: en, zh. lang: en # Location represents the collection of time offsets in use in a geographical area. # - If the name is &quot;&quot; or &quot;UTC&quot;, LoadLocation returns UTC. # - If the name is &quot;Local&quot;, LoadLocation returns Local. # - Otherwise, the name is taken to be a location name corresponding to a file in the # IANA Time Zone database, such as &quot;America/New_York&quot;, &quot;Asia/Shanghai&quot;, and so on. # # See https://go.dev/src/time/zoneinfo_abbrs_windows.go. locationName: Local # Configure your custom acronyms. Out of the box, &quot;ID&quot; -&gt; &quot;id&quot; is auto configured. # For example, if you configure K8s -&gt; k8s, then the field name in PascalCase &quot;InK8s&quot; # will be converted to snake_case &quot;in_k8s&quot; but not &quot;in_k_8_s&quot;. acronyms: {} # Log options. log: # Log mode: SIMPLE, FULL. mode: SIMPLE # Log level: DEBUG, INFO, WARN, ERROR. level: INFO # Log filename: set this if you want to write log messages to files. filename: &quot;&quot; # Log sink: CONSOLE, FILE, and MULTI. sink: CONSOLE # Options for generating proto files. proto: input: # Header options for worksheet and workbook. header: # Exact row number of column name definition at a worksheet. namerow: 1 # Exact row number of column type definition at a worksheet. typerow: 2 # Exact row number of column note at a worksheet. noterow: 3 # Start row number of data at a worksheet. datarow: 4 # The line number of column name definition in a cell. # Value 0 means the whole cell. nameline: 0 # The line number of column type definition in a cell. # Value 0 means the whole cell. typeline: 0 # The line number of column note definition in a cell. # Value 0 means the whole cell. noteline: 0 # Separator for separating: # - incell list elements (scalar or struct). # - incell map items. # # Default: &quot;,&quot; sep: &quot;&quot; # Subseparator for separating: # - key-value pair of each incell map item. # - struct fields of each incell struct list element. # # Default: &quot;:&quot; subsep: &quot;&quot; # The proto paths are used to search for dependencies that are referenced in import # statements in proto source files. If no import paths are provided then # &quot;.&quot; (current directory) is assumed to be the only import path. protoPaths: [.] # The enums and messages in protoFiles can be used in Excel/CSV/XML/YAML as # common types. protoFiles: [] # Specify input file formats to be parsed. It will recognize all formats # if not set. # # Available formats: &quot;xlsx&quot;, &quot;csv&quot;, &quot;xml&quot;, and &quot;yaml&quot;. formats: [xlsx] # Specify only these subdirs (relative to input dir) to be processed. subdirs: [] # Specify rewrite subdir path (relative to input dir). subdirRewrites: {} # Whether to follow the symbolic links when traversing directories recursively. # WARN: be careful to use this option, it may lead to infinite loop. followSymlink: false # Specify metasheet name. metasheetName: &quot;@TABLEAU&quot; # Specify the first-pass mode to parse predefined types when generate # specified config files. Under the hood, the parsed predefined types will # be recognized and used in the second-pass. # # The first-pass mode can be: # # - &quot;&quot;: default mode, parse based on specified config files. # - &quot;normal&quot;: parse based on all config files. # - &quot;advanced&quot;: parse based on all previous generated proto files. firstPassMode: &quot;&quot; # Specify the name pattern for messager(regexp supported). If the generated # messager name does not match this pattern, an error will be reported. # Example: &quot;Conf$&quot; messagerPattern: &quot;&quot; output: # Specify subdir (relative to output dir) for generated proto files. subdir: &quot;&quot; # Dir separator \`/\` or \`\\\` in filename is replaced by &quot;__&quot;. filenameWithSubdirPrefix: false # Append suffix to each generated proto filename. filenameSuffix: &quot;&quot; # Specify proto file options. # Example: go_package, csharp_namespace... fileOptions: {} # Whether to prepend prefix &quot;UPPER_SNAKE_CASE of EnumType&quot; to each enum value name. # # If set, the enum value name is prepended with &quot;ENUM_TYPE_&quot;. For example: # enum ItemType has a value &quot;EQUIP&quot;, then converted to &quot;ITEM_TYPE_EQUIP&quot;. # If the enum value name is already prefixed with &quot;ENUM_TYPE_&quot;, then it will # not be prefixed again. enumValueWithPrefix: false # Options for generating conf files. conf: input: # The proto paths are used to search for dependencies that are referenced in import # statements in proto source files. If no import paths are provided then # &quot;.&quot; (current directory) is assumed to be the only import path. protoPaths: [.] # The files to be parsed to generate configurations. # # NOTE: # - Recognize &quot;*.proto&quot; pattern if not set. # - Glob patterns is supported, which can specify sets # of filenames with wildcard characters. protoFiles: [&quot;*.proto&quot;] # The files not to be parsed to generate configurations. # # NOTE: Glob patterns is supported, which can specify sets # of filenames with wildcard characters. excludedProtoFiles: [] # Specify input file formats to be parsed. It will recognize all formats # if not set. # # Available formats: &quot;xlsx&quot;, &quot;csv&quot;, &quot;xml&quot;, and &quot;yaml&quot;. formats: [xlsx] # Specify only these subdirs (relative to workbook name option in proto file). subdirs: [] # Specify rewrite subdir path (relative to workbook name option in proto file). subdirRewrites: {} output: # Specify subdir (relative to output dir) for generated configuration files. subdir: &quot;&quot; # Specify generated conf file formats. It will generate all formats if not set. # Available formats: &quot;xlsx&quot;, &quot;csv&quot;, &quot;xml&quot;, and &quot;yaml&quot;. formats: [json] # Whether to output pretty format of JSON, with multiline and indent. pretty: true # EmitUnpopulated specifies whether to emit unpopulated fields. It does not # emit unpopulated oneof fields or unpopulated extension fields. # The JSON value emitted for unpopulated fields are as follows: # ╔═══════╤════════════════════════════╗ # ║ JSON │ Protobuf field ║ # ╠═══════╪════════════════════════════╣ # ║ false │ proto3 boolean fields ║ # ║ 0 │ proto3 numeric fields ║ # ║ &quot;&quot; │ proto3 string/bytes fields ║ # ║ null │ proto2 scalar fields ║ # ║ null │ message fields ║ # ║ [] │ list fields ║ # ║ {} │ map fields ║ # ╚═══════╧════════════════════════════╝ # # NOTE: worksheet with FieldPresence set as true ignore this option. # # Refer: https://github.com/protocolbuffers/protobuf/blob/main/docs/field_presence.md emitUnpopulated: false # Whether to emit timestamp in string format with timezones (as indicated by an offset). emitTimezones: false # Whether to use proto field name instead of lowerCamelCase name in JSON field names. useProtoNames: false # Whether to emit enum values as numbers. useEnumNumbers: false # Specify dry run mode: # - &quot;patch&quot;: if sheet options are specified: Patch (PATCH_MERGE) and Scatter dryRun: &quot;&quot; proto.input.header.seq # Default: ,
Global-level separator for separating:
incell list elements (scalar or struct). incell map items. Sheet-level and field-level separator options are also supported:
Sheet-level separator in metasheet Field-level separator in field property proto.input.header.subseq # Default: :
Global-level subseparator for separating:
key-value pair of each incell map item. struct fields of each incell struct list element. Sheet-level and field-level subseparator options are also supported:
Sheet-level subseparator in metasheet Field-level subseparator in field property `}).add({id:65,href:"/docs/prologue/",title:"Prologue",description:"Prologue of Tableau",content:""}).add({id:66,href:"/docs/prologue/introduction/",title:"Introduction",description:"Intro to Tableau.",content:`tableauc # tableauc is the Tableau Compiler with protogen and confgen inside.
protogen # protogen converts Excel/CSV/XML/YAML files to Protoconf files. Protoconf is a dialect of Protocol Buffers (proto3) extended with tableau options, aimed to define the structure of Excel/CSV/XML/YAML.
flowchart LR subgraph Input direction RL I1(Excel) I2(CSV) I3(XML) I4(YAML) end Input --&gt; B B((protogen)):::orangecalss --&gt; C(Protoconf) classDef orangecalss fill:#f96; confgen # confgen converts Excel/CSV/XML/YAML with Protoconf files to JSON/Text/Bin files.
flowchart LR subgraph Input direction RL I1(Excel) I2(CSV) I3(XML) I4(YAML) end Input --&gt; B A(Protoconf) --&gt; B B((confgen)):::orangecalss --&gt; Output classDef orangecalss fill:#f96; subgraph Output direction RL O1(&quot;JSON&quot;) O2(&quot;Text&quot;) O3(&quot;Bin&quot;) end `}).add({id:67,href:"/docs/prologue/quick-start/",title:"Quick Start",description:"Quick Start",content:`1. Download tableauc # Select the appropriate tableauc (aka Tableau Compiler) to download:
Windows x64 Linux x64 macOS x64 macOS arm64 More platforms are available on tableau releases →.
2. Add a workbook # Add HelloWorld.xlsx with two sheets:
Item: Copy data below to this worksheet. @TABLEAU: Just leave it empty now. It is the tableau metasheet → for specifying parser options. HelloWorld.xlsx&nbsp; Item @TABLEAU ID Name Desc map&lt;int32, Item&gt; string string Item’s ID Item’s name Item’s description 1 Apple A kind of delicious fruit. 2 Orange A kind of sour fruit. 3 Banana A kind of calorie-rich fruit. 3. Run tableauc # Run command: ./tableauc HelloWorld.xlsx
Then hello_world.proto and Item.json are generated:
hello_world.proto syntax = &quot;proto3&quot;; package protoconf; import &quot;tableau/protobuf/tableau.proto&quot;; option (tableau.workbook) = {name:&quot;HelloWorld.xlsx&quot; namerow:1 typerow:2 noterow:3 datarow:4}; message Item { option (tableau.worksheet) = {name:&quot;Item&quot;}; map&lt;int32, Item&gt; item_map = 1 [(tableau.field) = {key:&quot;ID&quot; layout:LAYOUT_VERTICAL}]; message Item { int32 id = 1 [(tableau.field) = {name:&quot;ID&quot;}]; string name = 2 [(tableau.field) = {name:&quot;Name&quot;}]; string desc = 3 [(tableau.field) = {name:&quot;Desc&quot;}]; } } Item.json { &quot;itemMap&quot;: { &quot;1&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;Apple&quot;, &quot;desc&quot;: &quot;A kind of delicious fruit.&quot; }, &quot;2&quot;: { &quot;id&quot;: 2, &quot;name&quot;: &quot;Orange&quot;, &quot;desc&quot;: &quot;A kind of sour fruit.&quot; }, &quot;3&quot;: { &quot;id&quot;: 3, &quot;name&quot;: &quot;Banana&quot;, &quot;desc&quot;: &quot;A kind of calorie-rich fruit.&quot; } } } Congratulations! You’ve just run the tableauc to convert a workbook to proto and JSON files.
`}).add({id:68,href:"/docs/",title:"Docs",description:"Docs Tableau.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()