var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"/docs/help/",title:"Help",description:"Help Tableau.",content:""}).add({id:1,href:"/docs/design/",title:"Design",description:"The Doks Blog.",content:""}).add({id:2,href:"/docs/advanced/",title:"Advanced",description:"Advanced topics of  Tableau.",content:""}).add({id:3,href:"/docs/guide/",title:"Guide",description:"Guide Tableau.",content:""}).add({id:4,href:"/docs/prologue/",title:"Prologue",description:"Prologue Tableau.",content:""}).add({id:5,href:"/docs/prologue/quick-start/",title:"Quick Start",description:"This guide gets you started with Tableau in Go with a simple working example.",content:"Prerequisites #  Go, any one of the three latest major releases of Go.  For installation instructions, see Go’s Getting Started guide.   Protocol buffer compiler, protoc, version 3.  For installation instructions, see Protocol Buffer Compiler Installation.   Go plugins for the protocol compiler:   Install the protocol compiler plugins for Go using the following commands:\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 go install github.com/tableauio/tableau/cmd/tableauc@v0.9.4    Update your PATH so that the protoc compiler can find the plugins:\nexport PATH=\u0026quot;$PATH:$(go env GOPATH)/bin\u0026quot;      Get the example code # The example code is part of the tableau/demo repo.\n  Download the repo as a zip file and unzip it, or clone the repo:\ngit clone https://github.com/tableauio/demo    Change to the quick start example directory:\ncd demo/examples/helloworld    Run the example # From the examples/helloworld directory:\n  Change dir to excel2proto, compile and execute:\ngo run main.go  Then proto files will be generated to examples/helloworld/proto.\n  Change dir to excel2conf, generate *.pb.go and then compile and execute:\nbash gen.sh go run main.go  Then *.pb.go files will be generated to examples/helloworld/protoconf, and JSON files will be generated to examples/helloworld/excel2conf/_out.\n  Congratulations! You’ve just run a modern configuration converter application with Tableau.\n"}).add({id:6,href:"/docs/prologue/introduction/",title:"Introduction",description:"Intro to Tableau.",content:"Get started # tableauc (protogen) # The tableauc is the tableau compiler with protogen inside, which can convert Excel/CSV/XML files to Protoconf files. Protoconf is a dialect of Protocol Buffers (proto3) extended with tableau options, aimed to define the structure of Excel/CSV/XML.\nflowchart LR subgraph Input direction RL I1(Excel) I2(CSV) I3(XML) end Input --\u0026gt; B B((tableauc)):::orangecalss --\u0026gt; C(Protoconf) classDef orangecalss fill:#f96;  confgen # flowchart LR A(Protoconf) --\u0026gt; B B((confgen)):::orangecalss --\u0026gt; Output classDef orangecalss fill:#f96; subgraph Output direction RL O1(\u0026quot;JSON(protojson)\u0026quot;) O2(\u0026quot;Text(prototext)\u0026quot;) O3(\u0026quot;Wire(protowire)\u0026quot;) end  "}).add({id:7,href:"/docs/guide/concepts/",title:"Concepts",description:"Core concepts of Tableau.",content:"Terminology # Basics #   Term Definition     workbook An excel file.\nA XML file.\nA bundle of CSV files named with same prefix seperated by #.   worksheet A sheet in a excel file.\nA root node of a XML file.\nA CSV file.   metasheet A worksheet named @TABLEAU to specify tableau parser options.   row The row in a sheet.   column The column in a sheet.   cell The intersection of a row and a column.   in-cell The inner-side of a cell.   cross-cell Continuous cells of a row or a column.    Worksheet #   Term Definition     namerow Exact row number of column name definition at a worksheet.\n⚠️NOTE: each column name must be unique in a worksheet!\nDefault: 1.   typerow Exact row number of column type definition at a worksheet.\nDefault: 2.   noterow Exact row number of column note at a worksheet.\nDefault: 3.   datarow Start row number of data at a worksheet.\nDefault: 4.   nameline The line number of column name definition in a cell. 0 means the whole cell.\nDefault: 0.   typeline The line number of column type definition in a cell. 0 means the whole cell.\nDefault: 0.   sep Separator for:\n1. separating in-cell list elements. 2. separating in-cell map items.\nDefault: ,.   subsep Subseparator for separating in-cell map Key-Value pair.\nDefault: :.   nested Nested naming of the namerow.\nDefault: false.   layout Incell, vertical(cross-cell) or horizontal(cross-cell).   transpose Interchanging the rows and columns of a given sheet.    Mappings to Protoconf #    Term Protoconf     workbook One protoconf(.proto) file.   worksheet One top-level message in a protoconf file, except the tableau metasheet named @TABLEAU.   column One field in a message.    A simple mapping example # Input: an excel file # A workbook(HelloWorld.xlsx) with two data worksheets(ItemConf and ActivityConf) and an empty tableau metasheet(@TABLEAU).\n First worksheet ItemConf:    ID Name Type     map\u0026lt;uint32, Item\u0026gt; string int32   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s type.   1 item1 100   2 item2 200   3 item3 300     Second worksheet ActivityConf:    ID Name Open     map\u0026lt;uint32, Activity\u0026gt; string bool   Activity\u0026rsquo;s ID. Activity\u0026rsquo;s name. Activity is open?   1 activity1 true   2 activity2 false   3 activity3     Output: a protoconf file # A protoconf file(hello_world.proto) with two top-level messages(ItemConf and ActivityConf).\nhello_world.proto // Generated by tableauc 0.2.1. DO NOT EDIT. syntax = \u0026quot;proto3\u0026quot;; package protoconf; option go_package = \u0026quot;github.com/tableauio/demo/examples/helloworld/protoconf\u0026quot;; import \u0026quot;tableau/protobuf/tableau.proto\u0026quot;; option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; int32 type = 3 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; } } message ActivityConf { option (tableau.worksheet) = {name:\u0026quot;ActivityConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Activity\u0026gt; activity_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Activity { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; bool open = 3 [(tableau.field) = {name:\u0026quot;Open\u0026quot;}]; } }   Naming convention # All names of workbook, worksheet, column, and struct(message), should use the CamelCase style naming convention. So the tableau parser can keep the worksheet name as protoconf message name, and exactly convert CamelCase to snake_case for protoconf field name and filename, which is suggested by Protocol Buffers Style Guide.\n"}).add({id:8,href:"/docs/guide/grammar-and-types/",title:"Grammar and types",description:"Grammar and types.",content:"Basics # Tableau borrows most of its syntax and types from Protocol Buffers (proto3) and Golang.\nScalar types #  Details disccused at Protocol Buffers Proto3 Scalar.\n    Kind Types Default     Numbers int32, uint32\nint64, uint64\nfloat, double 0\n0\n0.0   Booleans bool false   Strings string \u0026quot;\u0026quot;   Bytes bytes \u0026quot;\u0026quot;    Well-known types #   Type Default Notes     datetime 0000-00-00 00:00:00 Format: yyyy-MM-dd HH:mm:ss, e.g.: 2020-01-01 05:10:00.   date 0000-00-00 Format: yyyy-MM-dd or yyMMdd, e.g.: 2020-01-01 or 20200101.   time 00:00:00 Format: HH:mm:ss or HHmmss, e.g.: 05:10:00 or 051000.   duration 0s Format like: \u0026quot;72h3m0.5s\u0026quot;. Refer golang duration string form.    Note #  datetime and date are based on google.protobuf.Timestamp, see JSON mapping. time and duration are based on google.protobuf.Duration, see JSON mapping.  Composite types #    Type Description     struct A struct is mapped to a protobuf message.   list A list is mapped to a protobuf repeated field.   map A map is mapped to a protobuf map field.    struct #   Feature Description     Horizontal layout Each scalar field located in one cell.   Simple incell struct Each field must be scalar type. It is a comma-separated list of fields. E.g.: 1,test,3.0. List\u0026rsquo;s size need not to be equal to fields' size, as fields will be filled in order. Fields not configured will be filled default values due to its scalar type.    list #   Feature Description     Horizontal layout This is list\u0026rsquo;s default layout. Element type can be struct or scalar.   Vertical layout List\u0026rsquo;s element type should be struct.   Simple incell list Element type must be scalar. It is a comma-separated list of elements. E.g.: 1,2,3.   Scalable Scalable or dynamic list size.   Ignore empty element Smart recognition of empty element at any position.    map #   Feature Description     Horizontal layout    Vertical layout This is map\u0026rsquo;s default layout.   Hash map Implemented as unordered map or hash map.   Ordered map Supported by tableauio/loader.\n- C++   Simple incell map Both key and value must be scalar type. It is a comma-separated list of key:value pairs. E.g.: 1:10,2:20,3:30.   Scalable Scalable or dynamic map size.   Ignore empty item Smart recognition of empty item at any position.    Enumeration #   Feature Description     Three forms of enum value 1. Enum value number.\n2. Enum value name.\n3. Enum value alias name (with EnumValueOptions specified).   Validation Auto-check legality of enum values.    Empty value #   Type Description     scalar Empty scalar will be emplaced with scalar type\u0026rsquo;s default value.   struct Empty struct will not be spawned if all fields are empty.   list Empty list will not be spawned if list\u0026rsquo;s size is 0.\nEmpty struct will not be appended if list\u0026rsquo;s element(struct type) is empty.   map Empty map will not be spawned if map\u0026rsquo;s size is 0. Empty struct will not be inserted if map\u0026rsquo;s value(struct type) is empty.   nesting Recursively empty.    "}).add({id:9,href:"/docs/guide/struct/",title:"Struct",description:"Struct features.",content:"Cross-cell struct # Horizontal and vertical struct both should be used with:\n cross-cell horizontal/vertical map, as map value type. Map → cross-cell horizontal/vertical list, as list element type. List →  In-cell struct # Each field type of the struct should be scalar type.\nInput # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Property     map\u0026lt;uint32, Item\u0026gt; {int32 ID,string Name,string Desc}Prop   Item\u0026rsquo;s ID. Item\u0026rsquo;s property.   1 1,Orange,A good fruit.   2 2,Apple   3 3    The Property column\u0026rsquo;s type is in-cell struct {int32 ID,string Name,string Desc}Prop.\nOutput # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; Prop property = 2 [(tableau.field) = {name:\u0026quot;Property\u0026quot; type:TYPE_INCELL_STRUCT}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;property\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A good fruit.\u0026quot; } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;property\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;\u0026quot; } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;property\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;\u0026quot; } } } }   "}).add({id:10,href:"/docs/guide/list/",title:"List",description:"List features.",content:"Cross-cell list # Horizontal list # 👉  Vertical layout is list's default layout.   There are two kinds of cross-cell horizontal map:\n cross-cell horizontal scalar list, as element type is scalar. E.g: []int32. cross-cell horizontal struct list, as element type is struct. E.g: [Item]int32.  Cross-cell horizontal scalar list # 👉  Not supported yet.   Cross-cell horizontal struct list # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  Item1ID Item1Name Item2ID Item2Name     [Item]uint32 string uint32 string   Item1\u0026rsquo;s ID. Item1\u0026rsquo;s name. Item2\u0026rsquo;s ID. Item2\u0026rsquo;s name.   1 item1 2 item2    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }   Vertical list # There are two kinds of cross-cell vertical list:\n cross-cell vertical scalar list, as list element type is scalar. E.g: []int32. cross-cell vertical struct list, as list element type is struct. E.g: [Item]int32.  Cross-cell vertical scalar list # 👉  Not supported yet.   Cross-cell vertical struct list # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name Type     [Item]uint32 string int32   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s type.   1 item1 100   2 item2 200   3 item3 300    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; int32 type = 3 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; } }   In-cell list # There are two kinds of in-cell list:\n in-cell scalar list, as list value type is scalar. E.g: []int32. in-cell struct list, as list value type is struct. E.g: [Item]int32.  In-cell scalar list # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Props     map\u0026lt;uint32, Item\u0026gt; []int32   Item\u0026rsquo;s ID. Item\u0026rsquo;s props.   1 1,2,3   2 4,5   3 6    The Props column\u0026rsquo;s type is in-cell list []int32, as the list element is scalar type int32.\nOutput # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; repeated int32 props = 2 [(tableau.field) = {name:\u0026quot;Props\u0026quot; type:TYPE_INCELL_LIST}]; } }   in-cell struct list # 👉  Not supported yet.   Keyed list # Keyed list is same as normal list, except the first field of list struct is treated as like the map key.\nPattern: [Item]\u0026lt;int32\u0026gt;\nInput # A worksheet ItemConf in HelloWorld.xlsx:\n  ID PropID PropName     [Item] map\u0026lt;int32, Prop\u0026gt; string   Item\u0026rsquo;s ID. Item\u0026rsquo;s prop. Item\u0026rsquo;s prop name.   1 1 prop1   2 1 prop1   2 2 prop2   2 3 prop13    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 2 [(tableau.field) = {key:\u0026quot;PropID\u0026quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; string prop_name = 2 [(tableau.field) = {name:\u0026quot;PropName\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propName\u0026quot;: \u0026quot;prop1\u0026quot; } } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propName\u0026quot;: \u0026quot;prop1\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;propId\u0026quot;: 2, \u0026quot;propName\u0026quot;: \u0026quot;prop2\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;propId\u0026quot;: 3, \u0026quot;propName\u0026quot;: \u0026quot;prop13\u0026quot; } } } ] }   "}).add({id:11,href:"/docs/guide/enum/",title:"Enum",description:"Enum features.",content:"Enum value # The tableau parser accepts three enum value forms:\n enum value number. enum value name. enum value alias name (with EnumValueOptions specified).  For example, enum type FruitType is defined as:\nenum FruitType { FRUIT_TYPE_UNKOWN = 0 [(tableau.evalue).name = \u0026quot;unknown\u0026quot;]; FRUIT_TYPE_ORANGE = 1 [(tableau.evalue).name = \u0026quot;orange\u0026quot;]; FRUIT_TYPE_APPLE = 2 [(tableau.evalue).name = \u0026quot;apple\u0026quot;]; FRUIT_TYPE_BANANA = 3 [(tableau.evalue).name = \u0026quot;banana\u0026quot;]; }  Then the three forms of enum value are all accepted:\n   Enum value number Enum value name Enum value alias     0 FRUIT_TYPE_UNKOWN unknown   1 FRUIT_TYPE_ORANGE orange   2 FRUIT_TYPE_APPLE apple   3 FRUIT_TYPE_BANANA banana    👉  Enum type must be predefined.   Go to read details about predefiend Enum type. Predefined types →\nInput # A worksheet FruitConf in HelloWorld.xlsx:\n  ID Type     map\u0026lt;uint32, Fruit\u0026gt; enum\u0026lt;.FruitType\u0026gt;   Fruit\u0026rsquo;s ID. Fruit\u0026rsquo;s type.   1 1   2 FRUIT_TYPE_APPLE   3 banana    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;FruitConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Fruit\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Fruit { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; FruitType type = 2 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; } }   Validation # As enum type is predefined, so the tableau parser will auto validate the enum value.\n"}).add({id:12,href:"/docs/guide/map/",title:"Map",description:"Map features.",content:"Cross-cell map # Horizontal map # There are two kinds of cross-cell horizontal map:\n cross-cell horizontal scalar map, as map value type is scalar. E.g: map\u0026lt;int32, int32\u0026gt;. cross-cell horizontal struct map, as map value type is struct. E.g: map\u0026lt;int32, Item\u0026gt;.  Cross-cell horizontal scalar map # 👉  Not supported yet.   Cross-cell horizontal struct map #  NOTE: need to be tested enough.\n Input # A worksheet ItemConf in HelloWorld.xlsx:\n  Item1ID Item1Name Item2ID Item2Name     map\u0026lt;uint32, Item\u0026gt; string uint32 string   Item1\u0026rsquo;s ID. Item1\u0026rsquo;s name. Item2\u0026rsquo;s ID. Item2\u0026rsquo;s name.   1 item1 2 item2    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }   Vertical map # 👉  Vertical layout is map's default layout.   There are two kinds of cross-cell vertical map:\n cross-cell vertical scalar map, as map value type is scalar. E.g: map\u0026lt;int32, int32\u0026gt;. cross-cell vertical struct map, as map value type is struct. E.g: map\u0026lt;int32, Item\u0026gt;.  Cross-cell vertical scalar map # 👉  Not supported yet.   Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name     map\u0026lt;uint32, string\u0026gt; string   Item\u0026rsquo;s ID. Item\u0026rsquo;s name.   1 item1   2 item2   3 item3    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, string\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; value:\u0026quot;Name\u0026quot; layout:LAYOUT_VERTICAL}]; }   Cross-cell vertical struct map # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name Type     map\u0026lt;uint32, Item\u0026gt; string int32   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s type.   1 item1 100   2 item2 200   3 item3 300    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; int32 type = 3 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; } }   In-cell map # There are two kinds of in-cell map:\n in-cell scalar map, as map value type is scalar. E.g: map\u0026lt;int32, int32\u0026gt;. in-cell struct map, as map value type is struct. E.g: map\u0026lt;int32, Item\u0026gt;.  In-cell scalar map # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Props     map\u0026lt;uint32, Item\u0026gt; map\u0026lt;string, int32\u0026gt;   Item\u0026rsquo;s ID. Item\u0026rsquo;s props.   1 hp:1,power:2,magic:3   2 hp:10,power:20   3 hp:30    The Props column\u0026rsquo;s type is in-cell map map\u0026lt;string, int32\u0026gt;, as the map value is scalar type int32.\nOutput # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; map\u0026lt;string, int32\u0026gt; props = 2 [(tableau.field) = {name:\u0026quot;Props\u0026quot; type:TYPE_INCELL_MAP}]; } }   In-cell struct map # 👉  Not supported yet.   Ordered map # In the metasheet @TABLEAU, set the OrderedMap option to true, then ordered map accessers will be generated. This feature is powered by tableauio/loader. Currently supported programming languages are:\n C++ Golang C#  Example # If we want ItemConf to generate ordered map accessers, then set OrderedMap option to true of metasheet @TABLEAU:\n  Sheet OrderedMap     ItemConf true    More useful options are illustrated at metasheet chapter. Metasheet @TABLEAU →\nEnum key map # As the protobuf documents the restrictions of map key type:\n \u0026hellip; the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). Note that enum is not a valid key_type.\n However, key type as enum is very useful in some situations. So we support it in a simple way: enum type is treated as int32 as key type, but enum type is included in value type (struct).\nIf EnumKeyType is predefined as:\nenum EnumKeyType { ENUM_KEY_TYPE_UNKOWN = 0 [(tableau.evalue).name = \u0026quot;unknown\u0026quot;]; ENUM_KEY_TYPE_ORANGE = 1 [(tableau.evalue).name = \u0026quot;orange\u0026quot;]; ENUM_KEY_TYPE_APPLE = 2 [(tableau.evalue).name = \u0026quot;apple\u0026quot;]; ENUM_KEY_TYPE_BANANA = 3 [(tableau.evalue).name = \u0026quot;banana\u0026quot;]; }  then map\u0026lt;.EnumKeyType, ValueType\u0026gt; will be converted to map\u0026lt;int32, ValueType\u0026gt;, and EnumKeyType is included in ValueType as:\nenum ValueType { EnumKeyType key = 1; ... }  Input # A worksheet ItemConf in HelloWorld.xlsx:\n  Type Price     map\u0026lt;enum\u0026lt;.EnumKeyType\u0026gt;, Item\u0026gt; int32   Item\u0026rsquo;s type. Item\u0026rsquo;s price.   orange 100   apple 200   banana 300    Output # Generated protoconf is hello_world.proto:\nhello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { EnumKeyType type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; int32 price = 2 [(tableau.field) = {name:\u0026quot;Price\u0026quot;}]; } }   "}).add({id:13,href:"/docs/guide/nesting/",title:"Nesting",description:"Infinite nesting of composite types.",content:"Overview #  nesting: unlimited nesting of message, list, and map. nesting: the composite type\u0026rsquo;s first element can be composite type.  Map in map # Horizontal-map in vertical-map # TODO\nVertical-map in vertical-map # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name PropID PropValue     map\u0026lt;uint32, Item\u0026gt; string map\u0026lt;int32, Prop\u0026gt; int64   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value.   1 item1 10 100   2 item2 10 100   2 item2 20 200   2 item2 30 300    Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 3 [(tableau.field) = {key:\u0026quot;PropID\u0026quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;item1\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;10\u0026quot;: { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; } } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;item2\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;10\u0026quot;: { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; }, \u0026quot;20\u0026quot;: { \u0026quot;propId\u0026quot;: 20, \u0026quot;propValue\u0026quot;: \u0026quot;200\u0026quot; }, \u0026quot;30\u0026quot;: { \u0026quot;propId\u0026quot;: 30, \u0026quot;propValue\u0026quot;: \u0026quot;300\u0026quot; } } } } }   List in map # Horizontal-list in vertical-map # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name Prop1ID Prop1Value Prop2ID Prop2Value     map\u0026lt;uint32, Item\u0026gt; string [Prop]int32 int64 int32 int64   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value.   1 item1 10 100 20 200   2 item2 30 300 40 400   3 item3 50 500      Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;item1\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 10, \u0026quot;value\u0026quot;: \u0026quot;100\u0026quot; }, { \u0026quot;id\u0026quot;: 20, \u0026quot;value\u0026quot;: \u0026quot;200\u0026quot; } ] }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;item2\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 30, \u0026quot;value\u0026quot;: \u0026quot;300\u0026quot; }, { \u0026quot;id\u0026quot;: 40, \u0026quot;value\u0026quot;: \u0026quot;400\u0026quot; } ] }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;item3\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 50, \u0026quot;value\u0026quot;: \u0026quot;500\u0026quot; } ] } } }   Vertical-list in vertical-map # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name PropID PropValue     map\u0026lt;uint32, Item\u0026gt; string [Prop]int32 int64   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value.   1 item1 10 100   2 item2 10 100   2 item2 20 200   2 item2 30 300    Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;item1\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; } ] }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;item2\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; }, { \u0026quot;propId\u0026quot;: 20, \u0026quot;propValue\u0026quot;: \u0026quot;200\u0026quot; }, { \u0026quot;propId\u0026quot;: 30, \u0026quot;propValue\u0026quot;: \u0026quot;300\u0026quot; } ] } } }   List in list # Horizontal-list in vertical-list # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name Prop1ID Prop1Value Prop2ID Prop2Value     [Item]uint32 string [Prop]int32 int64 int32 int64   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value.   1 item1 10 100 20 200   2 item2 30 300 40 400   3 item3 50 500      Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;item1\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 10, \u0026quot;value\u0026quot;: \u0026quot;100\u0026quot; }, { \u0026quot;id\u0026quot;: 20, \u0026quot;value\u0026quot;: \u0026quot;200\u0026quot; } ] }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;item2\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 30, \u0026quot;value\u0026quot;: \u0026quot;300\u0026quot; }, { \u0026quot;id\u0026quot;: 40, \u0026quot;value\u0026quot;: \u0026quot;400\u0026quot; } ] }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;item3\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 50, \u0026quot;value\u0026quot;: \u0026quot;500\u0026quot; } ] } ] }   Vertical-list in vertical-keyed-list # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name PropID PropValue     [Item]\u0026lt;uint32\u0026gt; string [Prop]int32 int64   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value.   1 item1 10 100   2 item2 10 100   2 item2 20 200   2 item2 30 300    Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;item1\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; } ] }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;item2\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; }, { \u0026quot;propId\u0026quot;: 20, \u0026quot;propValue\u0026quot;: \u0026quot;200\u0026quot; }, { \u0026quot;propId\u0026quot;: 30, \u0026quot;propValue\u0026quot;: \u0026quot;300\u0026quot; } ] } ] }   Map in list # Horizontal-map in vertical-list # 👉  To be fixed.   Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name Prop1ID Prop1Value Prop2ID Prop2Value     [Item]int32 string map\u0026lt;int32, Prop\u0026gt; int64 int32 int64   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value.   1 item1 10 100 20 200   2 item2 30 300 40 400   3 item3 50 500      Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; TODO    item_conf.json TODO   Horizontal-map in vertical-keyed-list # TODO\nVertical-map in vertical-keyed-list # Input # A worksheet ItemConf in HelloWorld.xlsx:\n  ID Name PropID PropValue     [Item]\u0026lt;uint32\u0026gt; string map\u0026lt;int32, Prop\u0026gt; int64   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s prop id. Item\u0026rsquo;s prop value.   1 item1 10 100   2 item2 10 100   2 item2 20 200   2 item2 30 300    Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 3 [(tableau.field) = {key:\u0026quot;PropID\u0026quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    item_conf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;item1\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;10\u0026quot;: { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; } } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;item2\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;10\u0026quot;: { \u0026quot;propId\u0026quot;: 10, \u0026quot;propValue\u0026quot;: \u0026quot;100\u0026quot; }, \u0026quot;20\u0026quot;: { \u0026quot;propId\u0026quot;: 20, \u0026quot;propValue\u0026quot;: \u0026quot;200\u0026quot; }, \u0026quot;30\u0026quot;: { \u0026quot;propId\u0026quot;: 30, \u0026quot;propValue\u0026quot;: \u0026quot;300\u0026quot; } } } ] }   Nested naming # Input #  worksheet LoaderConf in HelloWorld.xlsx   ServerType ServerConfType ServerConfConditionType ServerConfConditionValue     map\u0026lt;enum\u0026lt;.ServerType\u0026gt;, Server\u0026gt; [Conf]\u0026lt;enum\u0026lt;.ConfType\u0026raquo; [Condition] int32   Server name Sheet name Condition type Condition value         SERVER_TYPE_GAME CONF_TYPE_CLOUD 0 113     0 134   SERVER_TYPE_ACTIVITY CONF_TYPE_CLOUD      1      CONF_TYPE_LOCAL 9 34    CONF_TYPE_LOCAL 9 12    CONF_TYPE_LOCAL      Remote     MatchServer CONF_TYPE_UNKNOWN        metasheet @TABLEAU in HelloWorld.xlsx   Sheet Nested     LoaderConf true      common.proto // NOTE: Some trivial code snippets are eliminated. enum ConfType { CONF_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; CONF_TYPE_CLOUD = 1 [(tableau.evalue).name = \u0026quot;Cloud\u0026quot;]; CONF_TYPE_LOCAL = 2 [(tableau.evalue).name = \u0026quot;Local\u0026quot;]; CONF_TYPE_REMOTE = 3 [(tableau.evalue).name = \u0026quot;Remote\u0026quot;]; } enum ServerType { SERVER_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; SERVER_TYPE_GAME = 1 [(tableau.evalue).name = \u0026quot;GameServer\u0026quot;]; SERVER_TYPE_ACTIVITY = 2 [(tableau.evalue).name = \u0026quot;ActivityServer\u0026quot;]; SERVER_TYPE_MATCH = 3 [(tableau.evalue).name = \u0026quot;MatchServer\u0026quot;]; }   Output #  hello_world.proto // NOTE: Some trivial code snippets are eliminated. option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message LoaderConf { option (tableau.worksheet) = {name:\u0026quot;LoaderConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nested:true}; map\u0026lt;int32, Server\u0026gt; server_map = 1 [(tableau.field) = {name:\u0026quot;Server\u0026quot; key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Server { ServerType type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; repeated Conf conf_list = 2 [(tableau.field) = {name:\u0026quot;Conf\u0026quot; key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Conf { ConfType type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; repeated Condition condition_list = 2 [(tableau.field) = {name:\u0026quot;Condition\u0026quot; key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Condition { int32 type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; int32 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } } }    loader_conf.json { \u0026quot;serverMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;SERVER_TYPE_GAME\u0026quot;, \u0026quot;confList\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_CLOUD\u0026quot;, \u0026quot;conditionList\u0026quot;: [ { \u0026quot;type\u0026quot;: 0, \u0026quot;value\u0026quot;: 113 } ] } ] }, \u0026quot;2\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;SERVER_TYPE_ACTIVITY\u0026quot;, \u0026quot;confList\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_CLOUD\u0026quot;, \u0026quot;conditionList\u0026quot;: [] }, { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_LOCAL\u0026quot;, \u0026quot;conditionList\u0026quot;: [ { \u0026quot;type\u0026quot;: 9, \u0026quot;value\u0026quot;: 34 } ] }, { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_REMOTE\u0026quot;, \u0026quot;conditionList\u0026quot;: [] } ] }, \u0026quot;3\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;SERVER_TYPE_MATCH\u0026quot;, \u0026quot;confList\u0026quot;: [] } } }   "}).add({id:14,href:"/docs/guide/predefined-types/",title:"Predefined types",description:"Predefined types.",content:"Enum # TODO\nStruct # TODO\nVariable naming # You can define custom variable name with the predefined struct.\n"}).add({id:15,href:"/docs/guide/metasheet/",title:"Metasheet @TABLEAU",description:"Metasheet @TABLEAU.",content:"Options #   Option Function     Sheet The worksheet name needed to be processed.   Alias Rename worksheet to be used as the generated protoconf message name.   Nameline The line number of column name definition in a cell. 0 means the whole cell.\nDefault: 0.   Typeline The line number of column type definition in a cell. 0 means the whole cell.\nDefault: 0.   Transpose Interchanging the rows and columns of a given sheet.   Nested Nested naming of the namerow.\nDefault: false.   Sep Separator for:\n1. separating in-cell list elements. 2. separating in-cell map items.\nDefault: ,.   Subsep Subseparator for separating in-cell map Key-Value pair.\nDefault: :.   OrderedMap Generate OrderedMap accessers or not.\nDefault: false.    Empty @TABLEAU # If metasheet @TABLEAU is empty, then all other worksheets in the same workbook will be processed.\nA simple example # There is a worksheet Sheet1 in HelloWorld.xlsx, we want to rename sheet to ItemConf, define custom seperator as |, and generate ordered map accessers.\nSo the metasheet @TABLEAU in HelloWorld.xlsx should be configured as:\n@TABLEAU   Sheet Alias Sep OrderedMap     Sheet1 ItemConf | true     "}).add({id:16,href:"/docs/advanced/incell/",title:"Incell",description:"Composite types in cell.",content:"TODO #  Struct List Map  "}).add({id:17,href:"/docs/advanced/validation/",title:"Validation",description:"Validation of Tableau.",content:"TODO #  unique: check map key uniqueness. range: [left, right]. refer: XXXConf.ID. To be supported by tableauio/loader.  "}).add({id:18,href:"/docs/design/overview/",title:"Overview",description:"Tableau is a powerful configuration converter powered by Protobuf(proto3).",content:"Features #  Convert Excel to JSON, JSON is the first-class citizen of exporting targets. Use Protoconf as the IDL(Interface Description Language) to define the structure of Excel/XML. Use Golang to develop the conversion engine. Support multiple programming languages, thanks to Protobuf(proto3).  Concepts #  Importer: Excel/XML importer. IR: Intermediate Representation. Filter: filter the IR. Exporter: JSON(protojson), TEXT(prototext), and BIN(protowire). Protoconf: a configuration metadata format based on protobuf.  Workflow # flowchart TD subgraph Input I1(Excel) click I1 href \u0026quot;https://github.com/qax-os/excelize\u0026quot; I2(CSV) click I2 href \u0026quot;https://pkg.go.dev/encoding/csv\u0026quot; I3(XML) click I3 href \u0026quot;https://github.com/antchfx/xmlquery\u0026quot; end Input --\u0026gt; I[importer] click I href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/importer\u0026quot; subgraph Protogen PGP[protogen.Parser] --\u0026gt; E1[protogen.Exporter] click PGP href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/protogen/parser.go\u0026quot; click E1 href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/protogen/exporter.go\u0026quot; end I --\u0026gt; Protogen:::orangeclass subgraph Confgen CGP[confgen.Parser] --\u0026gt; CE[confgen.Exporter] click CGP href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/confgen/parser.go\u0026quot; click CE href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/confgen/mexporter\u0026quot; end I --\u0026gt; Confgen:::orangeclass Protogen --\u0026gt; B B{{Protoconf}}:::greenclass --\u0026gt; |protoc-gen-go| Confgen subgraph Output O1(\u0026quot;JSON(protojson)\u0026quot;) click O1 href \u0026quot;https://developers.google.com/protocol-buffers/docs/proto3#json\u0026quot; O2(\u0026quot;Text(prototext)\u0026quot;) click O2 href \u0026quot;https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext\u0026quot; O3(\u0026quot;Wire(protowire)\u0026quot;) click O3 href \u0026quot;https://pkg.go.dev/google.golang.org/protobuf/encoding/protowire\u0026quot; end Confgen --\u0026gt; Output classDef orangeclass fill:#f96; classDef greenclass fill:#40E0D0;  Types #  Scalar Message(struct) List Map(unordered) Timestamp Duration  TODO # protoc plugins #  Golang C++ C#/.NET Python Lua Javascript/Typescript/Node Java  Metadata #  metatable: a message to describe the worksheet\u0026rsquo;s metadata. metafield: a message to describe the caption\u0026rsquo;s metadata. captrow: caption row, the exact row number of captions at worksheet. Newline in caption is allowed for more readability, and will be trimmed in conversion. descrow: description row, the exact row number of descriptions at worksheet. datarow: data row, the start row number of data.  Newline(line break) in major operating systems:\n   OS Abbreviation Escape sequence     Unix (linux, OS X) LF \\n   Microsoft Windows CRLF \\r\\n   classic Mac OS/OS X CR \\r     LF: Line Feed, CR: Carriage Return.\nMac OS X\n Generator #  generate protoconf by Excel(header): Excel -\u0026gt; protoconf generate Excel(header) by protoconf: protoconf -\u0026gt; Excel  Conversion #  Excel -\u0026gt; JSON(default format and human readable) Excel -\u0026gt; protowire(small size) Excel -\u0026gt; prototext(human debugging) JSON -\u0026gt; Excel protowire -\u0026gt; Excel prototext -\u0026gt; Excel  Pretty Print #  Multiline: every textual element on a new line Indent: 4 space characters JSON support prototext support  EmitUnpopulated #  JSON: EmitUnpopulated specifies whether to emit unpopulated fields.  Scalar Types #  interger: int32, uint32, int64 and uint64 float: float and double bool string bytes datetime, date, time, duration  Enumerations #  enum: The Parser accepts three enum value forms:  enum value number enum value name enum value alias name (with EnumValueOptions specified)   enum: validate the enum value.  Composite Types #  message: horizontal(row direction) layout, fields located in cells. message: simple in-cell message, each field must be scalar type. It is a comma-separated list of fields. E.g.: 1,test,3.0. List\u0026rsquo;s size need not to be equal to fields' size, as fields will be filled in order. Fields not configured will be filled default values due to its scalar type. list: horizontal(row direction) layout, which is list\u0026rsquo;s default layout, and each item can be message or scalar. list: vertical(column direction) layout. and each item should be message. list: simple in-cell list, element must be scalar type. It is a comma-separated list of elements. E.g.: 1,2,3. list: scalable or dynamic list size. list: smart recognition of empty element at any position. map: horizontal(row direction) layout. map: vertical(column direction) layout, and is map\u0026rsquo;s default layout. map: unordered-map or hash-map. map: ordered-map supported by tableauio/loader.  C++ Golang C#   map: simple in-cell map, both key and value must be scalar type. It is a comma-separated list of key:value pairs. E.g.: 1:10,2:20,3:30. map: scalable or dynamic map size. map: smart recognition of empty value at any position. nesting: unlimited nesting of message, list, and map. nesting: the composite type\u0026rsquo;s first element can be composite type.  Default Values # Each scalar type\u0026rsquo;s default value is same as protobuf.\n interger: 0 float: 0.0 bool: false string: \u0026quot;\u0026quot; bytes: \u0026quot;\u0026quot; in-cell message: each field\u0026rsquo;s default value is same as protobuf in-cell list: element\u0026rsquo;s default value is same as protobuf in-cell map: both key and value\u0026rsquo;s default value are same as protobuf message: all fields have default values  Empty #  scalar: default value same as protobuf. message: empty message will not be spawned if all fields are empty. list: empty list will not be spawned if list\u0026rsquo;s size is 0. list: empty message will not be appended if list\u0026rsquo;s element(message type) is empty. map: empty map will not be spawned if map\u0026rsquo;s size is 0. map: empty message will not be inserted if map\u0026rsquo;s value(message type) is empty. nesting: recursively empty.  Merge #  merge multiple workbooks merge multiple worksheets  Workbook meta # workbook meta sheet @TABLEAU:\n specify which sheets to be parsed specify parser options for each sheet     Sheet Alias Nameline Typeline     Sheet1 ExchangeInfo 2 2    Datetime #  Understanding about RFC 3339 for Datetime and Timezone Formatting in Software Engineering\n2019-10-12T07:20:50.52Z # This is acceptable in ISO 8601 and RFC 3339 (with T) 2019-10-12 07:20:50.52Z # This is only accepted in RFC 3339 (without T)\n \u0026ldquo;Z\u0026rdquo; stands for Zero timezone or Zulu timezone UTC+0, and equal to +00:00 in the RFC 3339. RFC 3339 follows the ISO 8601 DateTime format. The only difference is RFC allows us to replace \u0026ldquo;T\u0026rdquo; with \u0026ldquo;space\u0026rdquo;.   Use RFC 3339 , which is following ISO 8601.\n Timestamp: based on google.protobuf.Timestamp, see JSON mapping Timezone: see ParseInLocation DST: Daylight Savings Time. There is no plan to handle this boring stuff. Datetime: excel format: yyyy-MM-dd HH:mm:ss, e.g.: 2020-01-01 05:10:00 Date: excel format: yyyy-MM-dd or yyMMdd, e.g.: 2020-01-01 or 20200101 Time: excel format: HH:mm:ss or HHmmss, e.g.: 05:10:00 or 051000 Duration: based ongoogle.protobuf.Duration , see JSON mapping Duration: excel format: form \u0026quot;72h3m0.5s\u0026quot;, see golang duration string form  Transpose #  Interchange the rows and columns of a worksheet.  Validation #  unique: check map key uniqueness. range: [left, right]. refer: XXXConf.ID. To be supported by tableauio/loader.  Error Message #  Report clear and precise error messages when converter failed, please refer to the programming language compiler Use golang template to define error message template Multiple languages support, focused on English and Simplified Chinese  Performace #  Stress test Each goroutine process one worksheet Mutiple process model  "}).add({id:19,href:"/docs/design/metadata/",title:"Metadata",description:"We create an IDL called Protoconf to describe Excel's structure(metadata), based on Protobuf(proto3).",content:"Notation # The syntax is specified using Extended Backus-Naur Form (EBNF).\nWorkbook -\u0026gt; Protoconf # Basic # workbook: (AliasTest)DemoTest, worksheet: (AliasActivity)DemoActivity\n protoconf file name is alias_test.proto. If with no (), name will be demo_test.proto configuration message name is AliasActivity. If with no (), name will be DemoActivity list: [ELEM-TYPE]COLUMN-TYPE, COLUMN-TYPE is column type, ELEM-TYPE is message name and list prefix (must not conflict with the protobuf keyword). map: map\u0026lt;KEY-TYPE,VALUE-TYPE\u0026gt;, KEY-TYPE must be scalar types, and VALUE-TYPE is message name and map prefix (must not conflict with build-in scalar type). import message types: .TYPE, e.g.: .Item represents the message Item already defined in the same protobuf package, and should not redefine it. well-known types  Timestamp: google.protobuf.Timestamp Duration: google.protobuf.Duration     activity.xlsx   ActivityID ActivityName ActivityBeginTime ActivityDuration ChapterID ChapterName SectionID SectionName SectionItem1Id SectionItem1Num SectionItem2Id SectionItem2Num     map\u0026lt;uint32,Activity\u0026gt; string timestamp duration map\u0026lt;uint32,Chapter\u0026gt; string [Section]uint32 int32 [.Item]int32 int32 int32 int32   1 activity1 2020-01-01 05:00:00 72h 1 chapter1 1 section1 1001 1 1002 2   1 activity1 2020-01-01 05:00:00 72h 1 chapter1 2 section2 1001 1 1002 2   1 activity1 2020-01-01 05:00:00 72h 2 chapter2 1 section1 1001 1 1002 2   2 activity2 2020-01-01 05:00:00 72h3m0.5s 1 chapter1 1 section1 1001 1 1002 2     // common.proto message Item { int32 id = 1 [(tableau.field).name = \u0026quot;Id\u0026quot;]; int32 num= 2 [(tableau.field).name = \u0026quot;Num\u0026quot;]; }  Output without prefix # // demo_test.proto import \u0026quot;common.proto\u0026quot; message DemoActivity{ map\u0026lt;uint32, Activity\u0026gt; activity_map = 1 [(key) = \u0026quot;ActivityID\u0026quot;]; message Activity { uint32 id= 1 [(tableau.field).name = \u0026quot;ActivityID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;ActivityName\u0026quot;]; map\u0026lt;uint32, Chapter\u0026gt; chapter_map = 3 [(tableau.field).key = \u0026quot;ChapterID\u0026quot;]; } message Chapter { uint32 id= 1 [(tableau.field).name = \u0026quot;ChapterID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;ChapterName\u0026quot;]; repeated Section section_list = 3 [(tableau.field).layout = LAYOUT_VERTICAL]; } message Section { uint32 id= 1 [(tableau.field).name = \u0026quot;SectionID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;SectionName\u0026quot;]; repeated Item item_list = 3 [(tableau.field).name = \u0026quot;SectionItem\u0026quot;]; } }  Output with prefix # // demo_test.proto message DemoActivity{ map\u0026lt;uint32, Activity\u0026gt; activity_map = 1 [(key) = \u0026quot;ActivityID\u0026quot;]; message Activity { uint32 activity_id= 1 [(tableau.field).name = \u0026quot;ActivityID\u0026quot;]; string activity_name = 2 [(tableau.field).name = \u0026quot;ActivityName\u0026quot;]; map\u0026lt;uint32, Chapter\u0026gt; chapter_map = 3 [(tableau.field).key = \u0026quot;ChapterID\u0026quot;]; } message Chapter { uint32 chapter_id= 1 [(tableau.field).name = \u0026quot;ChapterID\u0026quot;]; string chapter_name = 2 [(tableau.field).name = \u0026quot;ChapterName\u0026quot;]; repeated Section section_list = 3 [(tableau.field).layout = LAYOUT_VERTICAL]; } message Section { uint32 section_id= 1 [(tableau.field).name = \u0026quot;SectionID\u0026quot;]; string section_name = 2 [(tableau.field).name = \u0026quot;SectionName\u0026quot;]; repeated Item section_item_list = 3 [(tableau.field).name = \u0026quot;SectionItem\u0026quot;]; } }  Incell # workbook: (AliasTest)DemoTest, worksheet: (Env)Environment\n  ID Name IncellMessage IncellList IncellMap IncellMessageList IncellMessageMap     uint32 string {int32 id,string desc,int32 value}Msg []int32 map\u0026lt;int32,string\u0026gt; []{int32 id,string desc}Elem map\u0026lt;int32,Value{int32 id,string desc}\u0026gt;   1 Earth 1,desc,100 1,2,3 1:hello,2:world {1,hello},{2,world} 1:{1,hello},2:{2,world}    IncellMessage # Syntax: TODO: EBNF Type: message type Value: comma seperated field values, e.g.: 1,desc,100 Rules:\n   Default Type Value     int32 can be parsed as number   string cannot be parsed as number    IncellList # Syntax: []Type Type: any scalar type Value: comma seperated list items, e.g.: 1,2,3\nIncellMap # Syntax: map\u0026lt;Type,Type\u0026gt; Type: any scalar type Value: comma seperated key-value pairs, and key-value is seperated by colon. e.g.: 1:hello,2:world\nIncellMessageList # TODO\u0026hellip;\nIncellMessageMap # TODO\u0026hellip;\nOutput # // demo_test.proto message Env { uint32 ID = 1 [(tableau.field).name = \u0026quot;ID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;Name\u0026quot;]; Msg incell_message= 3 [(tableau.field).name = \u0026quot;IncellMessage\u0026quot;]; repeated int32 incell_list= 4 [(tableau.field).name = \u0026quot;IncellList\u0026quot;]; map\u0026lt;int32, string\u0026gt; incell_map = 5 [(tableau.field).name = \u0026quot;IncellMap\u0026quot;]; repeated Elem incell_message_list= 6 [(tableau.field).name = \u0026quot;IncellMessageList\u0026quot;]; map\u0026lt;int32, Value\u0026gt; incell_message_map = 7 [(tableau.field).name = \u0026quot;IncellMessageMap\u0026quot;]; // defaut name: field + \u0026lt;tagid\u0026gt; message Msg { int32 id = 1; string desc= 2; int32 value= 3; } message Elem { int32 id = 1; string desc= 2; } message Value { int32 id = 1; string desc= 2; } }   Incell message: comma seperated sequence: {TYPE [NAME],TYPE [NAME]}, NAME is optional, and will be auto generated as field + \u0026lt;tagid\u0026gt; if not specified. Incell list: []TYPE, TYPE must be scalar type. Incell map: map[KEY]VALUE, KEY and VALUE must be scalar types. Incell message list: []TYPE, TYPE must be message type. Incell message map: map[KEY]VALUE, KEY is scalar, and VALUE must be message type.  Protoconf -\u0026gt; Workbook # TODO\u0026hellip;\n"}).add({id:20,href:"/docs/help/how-to-update/",title:"How to Update",description:"Regularly update the installed npm packages to keep your Doks website stable, usable, and secure.",content:"💡  Learn more about semantic versioning and advanced range syntax.   Check for outdated packages # The npm outdated command will check the registry to see if any (or, specific) installed packages are currently outdated:\nnpm outdated [[\u0026lt;@scope\u0026gt;/]\u0026lt;pkg\u0026gt; ...]  Update packages # The npm update command will update all the packages listed to the latest version (specified by the tag config), respecting semver:\nnpm update [\u0026lt;pkg\u0026gt;...]  "}).add({id:21,href:"/docs/help/troubleshooting/",title:"Troubleshooting",description:"Solutions to common problems.",content:"Problems updating npm packages # Delete the ./node_modules folder, and run again:\nnpm install  Problems with cache # Delete the temporary directories:\nnpm run clean  "}).add({id:22,href:"/docs/help/faq/",title:"FAQ",description:"Answers to frequently asked questions.",content:"Hyas? # Doks is a Hyas theme build by the creator of Hyas.\nFooter notice? # Please keep it in place.\nKeyboard shortcuts for search? #  focus: Ctrl + / select: ↓ and ↑ open: Enter close: Esc  Other documentation? #  Netlify Hugo  Can I get support? # Create a topic:\n Netlify Community Hugo Forums Doks Discussions  Contact the creator? # Send h-enk a message:\n Netlify Community Hugo Forums Doks Discussions  "}).add({id:23,href:"/docs/",title:"Docs",description:"Docs Tableau.",content:""}),search.addEventListener('input',b,!0);function b(){var b,e;const d=5;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[h,g]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href=h,b.appendChild(a);const e=document.createElement('span');e.textContent=g.title,e.classList.add("suggestion__title"),a.appendChild(e);const f=document.createElement('span');if(f.textContent=g.description,f.classList.add("suggestion__description"),a.appendChild(f),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()