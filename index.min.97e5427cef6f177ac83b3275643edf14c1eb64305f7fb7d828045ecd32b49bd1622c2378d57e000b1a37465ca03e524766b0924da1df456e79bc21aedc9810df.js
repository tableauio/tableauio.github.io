var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"/docs/api/checker/",title:"Checker",description:"Checker guide.",content:""}).add({id:1,href:"/docs/api/checker/guide/",title:"Guide",description:"Go checker guide.",content:"Overview # TODO: refer Tableau checker.\n"}).add({id:2,href:"/docs/help/",title:"Help",description:"Help Tableau.",content:""}).add({id:3,href:"/docs/help/how-to-update/",title:"How to Update",description:"Regularly update the installed toolchain to keep your tableau stable, usable, and secure.",content:"💡  Learn more about semantic versioning and advanced range syntax.   tableauc #  TODO \u0026hellip;\n "}).add({id:4,href:"/docs/help/troubleshooting/",title:"Troubleshooting",description:"Solutions to common problems.",content:"Problems updating tableauc config #  TODO \u0026hellip;\n Problems with loader #  TODO \u0026hellip;\n "}).add({id:5,href:"/docs/help/faq/",title:"FAQ",description:"Answers to frequently asked questions.",content:"Question 1 ? #  TODO \u0026hellip;\n "}).add({id:6,href:"/docs/design/",title:"Design",description:"The Doks Blog.",content:""}).add({id:7,href:"/docs/design/overview/",title:"Overview",description:"Tableau is a powerful configuration converter powered by Protobuf (proto3).",content:"Features #  Convert Excel/CSV/XML to JSON/Text/Bin, JSON is the first-class citizen of exporting targets. Use Protobuf to define the structure of Excel/CSV/XML. Use Golang to develop the conversion engine. Support multiple programming languages, thanks to Protobuf (proto3).  Concepts #  Importer: Excel/CSV/XML importer. IR: Intermediate Representation. Filter: filter the IR. Exporter: JSON, Text, and Bin. Protoconf: a configuration metadata format based on protobuf.  Workflow # flowchart TD subgraph Input I1(Excel) click I1 href \u0026quot;https://github.com/qax-os/excelize\u0026quot; I2(CSV) click I2 href \u0026quot;https://pkg.go.dev/encoding/csv\u0026quot; I3(XML) click I3 href \u0026quot;https://github.com/antchfx/xmlquery\u0026quot; end Input --\u0026gt; I[importer] click I href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/importer\u0026quot; subgraph Protogen PGP[protogen.Parser] --\u0026gt; E1[protogen.Exporter] click PGP href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/protogen/parser.go\u0026quot; click E1 href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/protogen/exporter.go\u0026quot; end I --\u0026gt; Protogen:::orangeclass subgraph Confgen CGP[confgen.Parser] --\u0026gt; CE[confgen.Exporter] click CGP href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/confgen/parser.go\u0026quot; click CE href \u0026quot;https://github.com/tableauio/tableau/tree/master/internal/confgen/mexporter\u0026quot; end I --\u0026gt; Confgen:::orangeclass Protogen --\u0026gt; B B{{Protoconf}}:::greenclass --\u0026gt; | protobuf descriptor | Confgen subgraph Output O1(\u0026quot;JSON\u0026quot;) click O1 href \u0026quot;https://developers.google.com/protocol-buffers/docs/proto3#json\u0026quot; O2(\u0026quot;Text\u0026quot;) click O2 href \u0026quot;https://developers.google.com/protocol-buffers/docs/text-format-spec\u0026quot; O3(\u0026quot;Bin\u0026quot;) click O3 href \u0026quot;https://developers.google.com/protocol-buffers/docs/encoding\u0026quot; end Confgen --\u0026gt; Output classDef orangeclass fill:#f96; classDef greenclass fill:#40E0D0;  Types #  Scalar Message(struct) List Map(unordered) Timestamp Duration  TODO # protoc plugins #  Golang C++ C#/.NET Python Lua Javascript/Typescript/Node Java  Metadata #  metatable: a message to describe the worksheet\u0026rsquo;s metadata. metafield: a message to describe the caption\u0026rsquo;s metadata. captrow: caption row, the exact row number of captions at worksheet. Newline in caption is allowed for more readability, and will be trimmed in conversion. descrow: description row, the exact row number of descriptions at worksheet. datarow: data row, the start row number of data.  Newline(line break) in major operating systems:\n   OS Abbreviation Escape sequence     Unix (linux, OS X) LF \\n   Microsoft Windows CRLF \\r\\n   classic Mac OS/OS X CR \\r     LF: Line Feed, CR: Carriage Return.\nMac OS X\n Generator #  generate protoconf by Excel(header): Excel -\u0026gt; protoconf generate Excel(header) by protoconf: protoconf -\u0026gt; Excel  Conversion #  Excel -\u0026gt; JSON(default format and human readable) Excel -\u0026gt; protowire(small size) Excel -\u0026gt; prototext(human debugging) JSON -\u0026gt; Excel protowire -\u0026gt; Excel prototext -\u0026gt; Excel  Pretty Print #  Multiline: every textual element on a new line Indent: 4 space characters JSON support prototext support  EmitUnpopulated #  JSON: EmitUnpopulated specifies whether to emit unpopulated fields.  Scalar Types #  interger: int32, uint32, int64 and uint64 float: float and double bool string bytes datetime, date, time, duration  Enumerations #  enum: The Parser accepts three enum value forms:  enum value number enum value name enum value alias name (with EnumValueOptions specified)   enum: validate the enum value.  Composite Types #  message: horizontal(row direction) layout, fields located in cells. message: simple in-cell message, each field must be scalar type. It is a comma-separated list of fields. E.g.: 1,test,3.0. List\u0026rsquo;s size need not to be equal to fields' size, as fields will be filled in order. Fields not configured will be filled default values due to its scalar type. list: horizontal(row direction) layout, which is list\u0026rsquo;s default layout, and each item can be message or scalar. list: vertical(column direction) layout. and each item should be message. list: simple in-cell list, element must be scalar type. It is a comma-separated list of elements. E.g.: 1,2,3. list: scalable or dynamic list size. list: smart recognition of empty element at any position. list  In-cell struct list: no need to support Cross-cell horizontal scalar/enum list Cross-cell horizontal incell-struct list Cross-cell vertical scalar list: no need to support, use this: [Item]int32 Cross-cell vertical incell-struct list   list size  dynamic size: items should be present continuously, and report error if empty item is inserted. fixed size   map: horizontal(row direction) layout. map: vertical(column direction) layout, and is map\u0026rsquo;s default layout. map: unordered-map or hash-map. map: ordered-map supported by tableauio/loader.  C++ Golang C#   map: simple in-cell map, both key and value must be scalar type. It is a comma-separated list of key:value pairs. E.g.: 1:10,2:20,3:30. map: scalable or dynamic map size. map: smart recognition of empty value at any position. map  Cross-cell horizontal scalar map: no need to support, use this: map\u0026lt;int32, Item\u0026gt; Cross-cell vertical scalar map: : no need to support, use this: map\u0026lt;int32, Item\u0026gt;   map size  dynamic size: items should be present continuously, and report error if empty item is inserted. fixed size   nesting: unlimited nesting of message, list, and map. nesting: the composite type\u0026rsquo;s first element can be composite type.  Default Values # Each scalar type\u0026rsquo;s default value is same as protobuf.\n interger: 0 float: 0.0 bool: false string: \u0026quot;\u0026quot; bytes: \u0026quot;\u0026quot; in-cell message: each field\u0026rsquo;s default value is same as protobuf in-cell list: element\u0026rsquo;s default value is same as protobuf in-cell map: both key and value\u0026rsquo;s default value are same as protobuf message: all fields have default values  Empty #  scalar: default value same as protobuf. message: empty message will not be spawned if all fields are empty. list: empty list will not be spawned if list\u0026rsquo;s size is 0. list: empty message will not be appended if list\u0026rsquo;s element(message type) is empty. map: empty map will not be spawned if map\u0026rsquo;s size is 0. map: empty message will not be inserted if map\u0026rsquo;s value(message type) is empty. nesting: recursively empty.  Merge #  merge multiple workbooks merge multiple worksheets  Workbook meta # workbook meta sheet @TABLEAU:\n specify which sheets to be parsed specify parser options for each sheet     Sheet Alias Nameline Typeline     Sheet1 ExchangeInfo 2 2    Datetime #  Understanding about RFC 3339 for Datetime and Timezone Formatting in Software Engineering\n2019-10-12T07:20:50.52Z # This is acceptable in ISO 8601 and RFC 3339 (with T) 2019-10-12 07:20:50.52Z # This is only accepted in RFC 3339 (without T)\n \u0026ldquo;Z\u0026rdquo; stands for Zero timezone or Zulu timezone UTC+0, and equal to +00:00 in the RFC 3339. RFC 3339 follows the ISO 8601 DateTime format. The only difference is RFC allows us to replace \u0026ldquo;T\u0026rdquo; with \u0026ldquo;space\u0026rdquo;.   Use RFC 3339 , which is following ISO 8601.\n Timestamp: based on google.protobuf.Timestamp, see JSON mapping Timezone: see ParseInLocation DST: Daylight Savings Time. There is no plan to handle this boring stuff. Datetime: excel format: yyyy-MM-dd HH:mm:ss, e.g.: 2020-01-01 05:10:00 Date: excel format: yyyy-MM-dd or yyMMdd, e.g.: 2020-01-01 or 20200101 Time: excel format: HH:mm:ss or HHmmss, e.g.: 05:10:00 or 051000 Duration: based ongoogle.protobuf.Duration , see JSON mapping Duration: excel format: form \u0026quot;72h3m0.5s\u0026quot;, see golang duration string form  Transpose #  Interchange the rows and columns of a worksheet.  Validation #  unique: check map key uniqueness. range: [left, right]. refer: XXXConf.ID. To be supported by tableauio/loader.  Error Message #  Report clear and precise error messages when converter failed, please refer to the programming language compiler Use golang template to define error message template Multiple languages support, focused on English and Simplified Chinese  Performace #  Stress test Each goroutine process one worksheet Mutiple process model  "}).add({id:8,href:"/docs/design/metadata/",title:"Metadata",description:"We create an IDL called Protoconf to describe Excel's structure(metadata), based on Protobuf (proto3).",content:"Notation # The syntax is specified using Extended Backus-Naur Form (EBNF).\nWorkbook -\u0026gt; Protoconf # Basic # workbook: (AliasTest)DemoTest, worksheet: (AliasActivity)DemoActivity\n protoconf file name is alias_test.proto. If with no (), name will be demo_test.proto configuration message name is AliasActivity. If with no (), name will be DemoActivity list: [ELEM-TYPE]COLUMN-TYPE, COLUMN-TYPE is column type, ELEM-TYPE is message name and list prefix (must not conflict with the protobuf keyword). map: map\u0026lt;KEY-TYPE,VALUE-TYPE\u0026gt;, KEY-TYPE must be scalar types, and VALUE-TYPE is message name and map prefix (must not conflict with build-in scalar type). import message types: .TYPE, e.g.: .Item represents the message Item already defined in the same protobuf package, and should not redefine it. well-known types  Timestamp: google.protobuf.Timestamp Duration: google.protobuf.Duration    Activity.xlsx\u0026nbsp; Activity  @TABLEAU      ActivityID ActivityName ActivityBeginTime ActivityDuration ChapterID ChapterName SectionID SectionName SectionItem1Id SectionItem1Num SectionItem2Id SectionItem2Num     map\u0026lt;uint32,Activity\u0026gt; string timestamp duration map\u0026lt;uint32,Chapter\u0026gt; string [Section]uint32 int32 [.Item]int32 int32 int32 int32   1 activity1 2020-01-01 05:00:00 72h 1 chapter1 1 section1 1001 1 1002 2   1 activity1 2020-01-01 05:00:00 72h 1 chapter1 2 section2 1001 1 1002 2   1 activity1 2020-01-01 05:00:00 72h 2 chapter2 1 section1 1001 1 1002 2   2 activity2 2020-01-01 05:00:00 72h3m0.5s 1 chapter1 1 section1 1001 1 1002 2                                    // common.proto message Item { int32 id = 1 [(tableau.field).name = \u0026quot;Id\u0026quot;]; int32 num= 2 [(tableau.field).name = \u0026quot;Num\u0026quot;]; }  Output without prefix # // demo_test.proto import \u0026quot;common.proto\u0026quot; message DemoActivity{ map\u0026lt;uint32, Activity\u0026gt; activity_map = 1 [(key) = \u0026quot;ActivityID\u0026quot;]; message Activity { uint32 id= 1 [(tableau.field).name = \u0026quot;ActivityID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;ActivityName\u0026quot;]; map\u0026lt;uint32, Chapter\u0026gt; chapter_map = 3 [(tableau.field).key = \u0026quot;ChapterID\u0026quot;]; } message Chapter { uint32 id= 1 [(tableau.field).name = \u0026quot;ChapterID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;ChapterName\u0026quot;]; repeated Section section_list = 3 [(tableau.field).layout = LAYOUT_VERTICAL]; } message Section { uint32 id= 1 [(tableau.field).name = \u0026quot;SectionID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;SectionName\u0026quot;]; repeated Item item_list = 3 [(tableau.field).name = \u0026quot;SectionItem\u0026quot;]; } }  Output with prefix # // demo_test.proto message DemoActivity{ map\u0026lt;uint32, Activity\u0026gt; activity_map = 1 [(key) = \u0026quot;ActivityID\u0026quot;]; message Activity { uint32 activity_id= 1 [(tableau.field).name = \u0026quot;ActivityID\u0026quot;]; string activity_name = 2 [(tableau.field).name = \u0026quot;ActivityName\u0026quot;]; map\u0026lt;uint32, Chapter\u0026gt; chapter_map = 3 [(tableau.field).key = \u0026quot;ChapterID\u0026quot;]; } message Chapter { uint32 chapter_id= 1 [(tableau.field).name = \u0026quot;ChapterID\u0026quot;]; string chapter_name = 2 [(tableau.field).name = \u0026quot;ChapterName\u0026quot;]; repeated Section section_list = 3 [(tableau.field).layout = LAYOUT_VERTICAL]; } message Section { uint32 section_id= 1 [(tableau.field).name = \u0026quot;SectionID\u0026quot;]; string section_name = 2 [(tableau.field).name = \u0026quot;SectionName\u0026quot;]; repeated Item section_item_list = 3 [(tableau.field).name = \u0026quot;SectionItem\u0026quot;]; } }  Incell # workbook: (AliasTest)DemoTest, worksheet: (Env)Environment\n   ID Name IncellMessage IncellList IncellMap IncellMessageList IncellMessageMap     uint32 string {int32 id,string desc,int32 value}Msg []int32 map\u0026lt;int32,string\u0026gt; []{int32 id,string desc}Elem map\u0026lt;int32,Value{int32 id,string desc}\u0026gt;   1 Earth 1,desc,100 1,2,3 1:hello,2:world {1,hello},{2,world} 1:{1,hello},2:{2,world}     --break-me-here--\nIncellMessage # Syntax: TODO: EBNF Type: message type Value: comma seperated field values, e.g.: 1,desc,100 Rules:\n   Default Type Value     int32 can be parsed as number   string cannot be parsed as number    IncellList # Syntax: []Type Type: any scalar type Value: comma seperated list items, e.g.: 1,2,3\nIncellMap # Syntax: map\u0026lt;Type,Type\u0026gt; Type: any scalar type Value: comma seperated key-value pairs, and key-value is seperated by colon. e.g.: 1:hello,2:world\nIncellMessageList # TODO\u0026hellip;\nIncellMessageMap # TODO\u0026hellip;\nOutput # // demo_test.proto message Env { uint32 ID = 1 [(tableau.field).name = \u0026quot;ID\u0026quot;]; string name = 2 [(tableau.field).name = \u0026quot;Name\u0026quot;]; Msg incell_message= 3 [(tableau.field).name = \u0026quot;IncellMessage\u0026quot;]; repeated int32 incell_list= 4 [(tableau.field).name = \u0026quot;IncellList\u0026quot;]; map\u0026lt;int32, string\u0026gt; incell_map = 5 [(tableau.field).name = \u0026quot;IncellMap\u0026quot;]; repeated Elem incell_message_list= 6 [(tableau.field).name = \u0026quot;IncellMessageList\u0026quot;]; map\u0026lt;int32, Value\u0026gt; incell_message_map = 7 [(tableau.field).name = \u0026quot;IncellMessageMap\u0026quot;]; // defaut name: field + \u0026lt;tagid\u0026gt; message Msg { int32 id = 1; string desc= 2; int32 value= 3; } message Elem { int32 id = 1; string desc= 2; } message Value { int32 id = 1; string desc= 2; } }   Incell message: comma seperated sequence: {TYPE [NAME],TYPE [NAME]}, NAME is optional, and will be auto generated as field + \u0026lt;tagid\u0026gt; if not specified. Incell list: []TYPE, TYPE must be scalar type. Incell map: map[KEY]VALUE, KEY and VALUE must be scalar types. Incell message list: []TYPE, TYPE must be message type. Incell message map: map[KEY]VALUE, KEY is scalar, and VALUE must be message type.  Protoconf -\u0026gt; Workbook # TODO\u0026hellip;\n"}).add({id:9,href:"/docs/api/",title:"API",description:"API guide.",content:""}).add({id:10,href:"/docs/api/tableau/",title:"Tableau",description:"Tableau guide.",content:""}).add({id:11,href:"/docs/api/tableau/guide/",title:"Guide",description:"This guide gets you started with Tableau in Go with a simple working example.",content:"Prerequisites #  Go, any one of the three latest major releases of Go.  For installation instructions, see Go’s Getting Started guide.   Protocol buffer compiler, protoc, version 3.  For installation instructions, see Protocol Buffer Compiler Installation.   Go plugins for the protocol compiler:   Install the protocol compiler plugins for Go using the following commands:\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26    Update your PATH so that the protoc compiler can find the plugins:\nexport PATH=\u0026quot;$PATH:$(go env GOPATH)/bin\u0026quot;      Get the example code # The example code is part of the tableau/demo repo.\n  Download the repo as a zip file and unzip it, or clone the repo:\ngit clone https://github.com/tableauio/demo    Change to the quick start example directory:\ncd demo/examples/helloworld    Run the example # From the examples/helloworld directory:\n  Change dir to excel2proto, compile and execute:\ngo run main.go  Then proto files will be generated to examples/helloworld/proto.\n  Change dir to excel2conf, generate *.pb.go and then compile and execute:\nbash gen.sh go run main.go  Then *.pb.go files will be generated to examples/helloworld/protoconf, and JSON files will be generated to examples/helloworld/excel2conf/_out.\n  Congratulations! You’ve just run a modern configuration converter application with Tableau.\n"}).add({id:12,href:"/docs/api/loader/",title:"Loader",description:"Loader guide.",content:""}).add({id:13,href:"/docs/api/loader/c++/",title:"C++",description:"C++ loader guide.",content:"Overview # TODO: refer Tableau loader.\n"}).add({id:14,href:"/docs/api/loader/go/",title:"Go",description:"Go loader guide.",content:"Overview # TODO: refer Tableau loader.\n"}).add({id:15,href:"/docs/xml/",title:"XML",description:"XML guide.",content:""}).add({id:16,href:"/docs/xml/struct/",title:"Struct",description:"XML struct guide.",content:"Cross-cell struct # Any node in XML (with or without attributes) will be converted to a struct in protobuf.\nIn-cell struct # 👉  Not supported yet.   Input # A worksheet ServerConf in Server.xml:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU --\u0026gt; \u0026lt;ServerConf Author=\u0026quot;David\u0026quot; LastBuildTime=\u0026quot;2022-08-07 11:21:00\u0026quot;\u0026gt; \u0026lt;GameServer BinPath=\u0026quot;/home/server/bin\u0026quot; Cmd=\u0026quot;./gamesvr --id='1.0.1.1'\u0026quot; Desc=\u0026quot;game server\u0026quot; /\u0026gt; \u0026lt;/ServerConf\u0026gt;  The GameServer node\u0026rsquo;s type is cross-cell struct {string BinPath,string Cmd,string Desc}GameServer.\nOutput # Generated protoconf is server_conf.proto:\nserver_conf.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;server/AutoConfig2/Server.xml\u0026quot;}; message ServerConf { option (tableau.worksheet) = {name:\u0026quot;ServerConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nameline:1 typeline:1 nested:true}; string author = 1 [(tableau.field) = {name:\u0026quot;Author\u0026quot;}]; string last_build_time = 2 [(tableau.field) = {name:\u0026quot;LastBuildTime\u0026quot;}]; GameServer game_server = 3 [(tableau.field) = {name:\u0026quot;GameServer\u0026quot;}]; message GameServer { string bin_path = 1 [(tableau.field) = {name:\u0026quot;BinPath\u0026quot;}]; string cmd = 2 [(tableau.field) = {name:\u0026quot;Cmd\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } }    server_conf.json { \u0026quot;author\u0026quot;: \u0026quot;David\u0026quot;, \u0026quot;lastBuildTime\u0026quot;: \u0026quot;2022-08-07 11:21:00\u0026quot;, \u0026quot;gameServer\u0026quot;: { \u0026quot;binPath\u0026quot;: \u0026quot;/home/server/bin\u0026quot;, \u0026quot;cmd\u0026quot;: \u0026quot;./gamesvr --id='1.0.1.1'\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;game server\u0026quot; } }   "}).add({id:17,href:"/docs/xml/list/",title:"List",description:"XML list guide.",content:"Cross-cell list # Input # A worksheet RankConf in Rank.xml:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU \u0026lt;RankConf\u0026gt; \u0026lt;RankItem Score=\u0026quot;[RankItem]int32\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt; --\u0026gt; \u0026lt;RankConf\u0026gt; \u0026lt;RankItem Score=\u0026quot;100\u0026quot; Name=\u0026quot;Tony\u0026quot;/\u0026gt; \u0026lt;RankItem Score=\u0026quot;99\u0026quot; Name=\u0026quot;Eric\u0026quot;/\u0026gt; \u0026lt;RankItem Score=\u0026quot;98\u0026quot; Name=\u0026quot;David\u0026quot;/\u0026gt; \u0026lt;RankItem Score=\u0026quot;98\u0026quot; Name=\u0026quot;Jenny\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt;  Output # Generated protoconf is rank_conf.proto:\nrank_conf.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;server/AutoConfig2/Server.xml\u0026quot;}; message RankConf { option (tableau.worksheet) = {name:\u0026quot;RankConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nameline:1 typeline:1 nested:true}; repeated RankItem rank_item_list = 1 [(tableau.field) = {name:\u0026quot;RankItem\u0026quot; layout:LAYOUT_VERTICAL}]; message RankItem { int32 score = 1 [(tableau.field) = {name:\u0026quot;Score\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    rank_conf.json { \u0026quot;rankItemList\u0026quot;: [ { \u0026quot;score\u0026quot;: 100, \u0026quot;name\u0026quot;: \u0026quot;Tony\u0026quot; }, { \u0026quot;score\u0026quot;: 99, \u0026quot;name\u0026quot;: \u0026quot;Eric\u0026quot; }, { \u0026quot;score\u0026quot;: 98, \u0026quot;name\u0026quot;: \u0026quot;David\u0026quot; }, { \u0026quot;score\u0026quot;: 98, \u0026quot;name\u0026quot;: \u0026quot;Jenny\u0026quot; } ] }   NOTE: Duplicate key column data will be merged into one (only the first value taken). If you want duplicate values occurred, you should just use list instead of keyed list.\nIn-cell list # There are two kinds of in-cell list:\n in-cell scalar list, as list value type is scalar. E.g: []int32. in-cell struct list, as list value type is struct. E.g: [Item]int32.  In-cell scalar list # Input # A worksheet ServerConf in Server.xml:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU \u0026lt;ServerConf\u0026gt; \u0026lt;GameServer IP=\u0026quot;[]string\u0026quot; /\u0026gt; \u0026lt;/ServerConf\u0026gt; --\u0026gt; \u0026lt;ServerConf Author=\u0026quot;David\u0026quot; LastBuildTime=\u0026quot;2022-08-07 11:21:00\u0026quot;\u0026gt; \u0026lt;GameServer BinPath=\u0026quot;/home/server/bin\u0026quot; Cmd=\u0026quot;./gamesvr --id='1.0.1.1'\u0026quot; IP=\u0026quot;9.12.125.11,9.43.124.32,9.125.32.14\u0026quot; Desc=\u0026quot;game server\u0026quot; /\u0026gt; \u0026lt;/ServerConf\u0026gt;  The IP attribute\u0026rsquo;s type is in-cell list []string, as the list element is scalar type string.\nOutput # Generated protoconf is server_conf.proto:\nserver_conf.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;server/AutoConfig2/Server.xml\u0026quot;}; message ServerConf { option (tableau.worksheet) = {name:\u0026quot;ServerConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nameline:1 typeline:1 nested:true}; string author = 1 [(tableau.field) = {name:\u0026quot;Author\u0026quot;}]; string last_build_time = 2 [(tableau.field) = {name:\u0026quot;LastBuildTime\u0026quot;}]; GameServer game_server = 3 [(tableau.field) = {name:\u0026quot;GameServer\u0026quot;}]; message GameServer { repeated string ip_list = 1 [(tableau.field) = {name:\u0026quot;IP\u0026quot; key:\u0026quot;IP\u0026quot; layout:LAYOUT_INCELL}]; string bin_path = 2 [(tableau.field) = {name:\u0026quot;BinPath\u0026quot;}]; string cmd = 3 [(tableau.field) = {name:\u0026quot;Cmd\u0026quot;}]; string desc = 4 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } }    server_conf.json { \u0026quot;author\u0026quot;: \u0026quot;David\u0026quot;, \u0026quot;lastBuildTime\u0026quot;: \u0026quot;2022-08-07 11:21:00\u0026quot;, \u0026quot;gameServer\u0026quot;: { \u0026quot;ipList\u0026quot;: [ \u0026quot;9.12.125.11\u0026quot;, \u0026quot;9.43.124.32\u0026quot;, \u0026quot;9.125.32.14\u0026quot; ], \u0026quot;binPath\u0026quot;: \u0026quot;/home/server/bin\u0026quot;, \u0026quot;cmd\u0026quot;: \u0026quot;./gamesvr --id='1.0.1.1'\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;game server\u0026quot; } }   in-cell struct list # 👉  Not supported yet.   Keyed list # Keyed list is same as normal list, except the first field of list struct is treated as like the map key.\nPattern: [Item]\u0026lt;int32\u0026gt;\nInput # A worksheet RankConf in Rank.xml:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU \u0026lt;RankConf\u0026gt; \u0026lt;RankItem Score=\u0026quot;[RankItem]\u0026lt;int32\u0026gt;\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt; --\u0026gt; \u0026lt;RankConf\u0026gt; \u0026lt;RankItem Score=\u0026quot;100\u0026quot; Name=\u0026quot;Tony\u0026quot;/\u0026gt; \u0026lt;RankItem Score=\u0026quot;99\u0026quot; Name=\u0026quot;Eric\u0026quot;/\u0026gt; \u0026lt;RankItem Score=\u0026quot;98\u0026quot; Name=\u0026quot;David\u0026quot;/\u0026gt; \u0026lt;RankItem Score=\u0026quot;98\u0026quot; Name=\u0026quot;Jenny\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt;  Output # Generated protoconf is rank_conf.proto:\nrank_conf.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;server/AutoConfig2/Server.xml\u0026quot;}; message RankConf { option (tableau.worksheet) = {name:\u0026quot;RankConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nameline:1 typeline:1 nested:true}; repeated RankItem rank_item_list = 1 [(tableau.field) = {name:\u0026quot;RankItem\u0026quot; key:\u0026quot;Score\u0026quot; layout:LAYOUT_VERTICAL}]; message RankItem { int32 score = 1 [(tableau.field) = {name:\u0026quot;Score\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    rank_conf.json { \u0026quot;rankItemList\u0026quot;: [ { \u0026quot;score\u0026quot;: 100, \u0026quot;name\u0026quot;: \u0026quot;Tony\u0026quot; }, { \u0026quot;score\u0026quot;: 99, \u0026quot;name\u0026quot;: \u0026quot;Eric\u0026quot; }, { \u0026quot;score\u0026quot;: 98, \u0026quot;name\u0026quot;: \u0026quot;David\u0026quot; } ] }   NOTE: Duplicate key column data will be merged into one (only the first value taken). If you want duplicate values occurred, you should just use list instead of keyed list.\n"}).add({id:18,href:"/docs/xml/map/",title:"Map",description:"XML map guide.",content:"Cross-cell map # Input # A worksheet RankConf in Rank.xml:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU \u0026lt;RankConf\u0026gt; \u0026lt;RankItem ID=\u0026quot;map\u0026lt;uint32, RankItem\u0026gt;\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt; --\u0026gt; \u0026lt;RankConf\u0026gt; \u0026lt;RankItem ID=\u0026quot;1\u0026quot; Score=\u0026quot;100\u0026quot; Name=\u0026quot;Tony\u0026quot;/\u0026gt; \u0026lt;RankItem ID=\u0026quot;2\u0026quot; Score=\u0026quot;99\u0026quot; Name=\u0026quot;Eric\u0026quot;/\u0026gt; \u0026lt;RankItem ID=\u0026quot;3\u0026quot; Score=\u0026quot;98\u0026quot; Name=\u0026quot;David\u0026quot;/\u0026gt; \u0026lt;RankItem ID=\u0026quot;4\u0026quot; Score=\u0026quot;98\u0026quot; Name=\u0026quot;Jenny\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt;  Output # Generated protoconf is rank_conf.proto:\nrank_conf.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;server/AutoConfig2/Server.xml\u0026quot;}; message RankConf { option (tableau.worksheet) = {name:\u0026quot;RankConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nameline:1 typeline:1 nested:true}; map\u0026lt;uint32, RankItem\u0026gt; rank_item_map = 1 [(tableau.field) = {name:\u0026quot;RankItem\u0026quot; key:\u0026quot;Id\u0026quot; layout:LAYOUT_VERTICAL}]; message RankItem { uint32 id = 1 [(tableau.field) = {name:\u0026quot;Id\u0026quot;}]; int32 score = 2 [(tableau.field) = {name:\u0026quot;Score\u0026quot;}]; string name = 3 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    rank_conf.json { \u0026quot;rankItemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;score\u0026quot;: 100, \u0026quot;name\u0026quot;: \u0026quot;Tony\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;score\u0026quot;: 99, \u0026quot;name\u0026quot;: \u0026quot;Eric\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;score\u0026quot;: 98, \u0026quot;name\u0026quot;: \u0026quot;David\u0026quot; }, \u0026quot;4\u0026quot;: { \u0026quot;id\u0026quot;: 4, \u0026quot;score\u0026quot;: 98, \u0026quot;name\u0026quot;: \u0026quot;Jenny\u0026quot; } } }   In-cell map # There are two kinds of in-cell map:\n in-cell scalar map, as map value type is scalar. E.g: map\u0026lt;uint32, int32\u0026gt;. in-cell struct map, as map value type is struct. E.g: map\u0026lt;uint32, Item\u0026gt;.  In-cell scalar map # Input # A worksheet RankConf in Rank.xml:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU \u0026lt;RankConf\u0026gt; \u0026lt;RankItem ID=\u0026quot;map\u0026lt;uint32, RankItem\u0026gt;\u0026quot; Subject=\u0026quot;map\u0026lt;string, int32\u0026gt;\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt; --\u0026gt; \u0026lt;RankConf\u0026gt; \u0026lt;RankItem ID=\u0026quot;1\u0026quot; Score=\u0026quot;100\u0026quot; Name=\u0026quot;Tony\u0026quot; Subject=\u0026quot;Math:80,English:20\u0026quot;/\u0026gt; \u0026lt;RankItem ID=\u0026quot;2\u0026quot; Score=\u0026quot;99\u0026quot; Name=\u0026quot;Eric\u0026quot; Subject=\u0026quot;Math:80,English:19\u0026quot;/\u0026gt; \u0026lt;RankItem ID=\u0026quot;3\u0026quot; Score=\u0026quot;98\u0026quot; Name=\u0026quot;David\u0026quot; Subject=\u0026quot;Math:80,English:18\u0026quot;/\u0026gt; \u0026lt;RankItem ID=\u0026quot;4\u0026quot; Score=\u0026quot;98\u0026quot; Name=\u0026quot;Jenny\u0026quot; Subject=\u0026quot;Math:80,English:18\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt;  The Subject attribute\u0026rsquo;s type is in-cell map map\u0026lt;string, int32\u0026gt;, as the map value-type is scalar type.\nOutput # Generated protoconf is rank_conf.proto:\nrank_conf.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;server/AutoConfig2/Server.xml\u0026quot;}; message RankConf { option (tableau.worksheet) = {name:\u0026quot;RankConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nameline:1 typeline:1 nested:true}; map\u0026lt;uint32, RankItem\u0026gt; rank_item_map = 1 [(tableau.field) = {name:\u0026quot;RankItem\u0026quot; key:\u0026quot;Id\u0026quot; layout:LAYOUT_VERTICAL}]; message RankItem { uint32 id = 1 [(tableau.field) = {name:\u0026quot;Id\u0026quot;}]; map\u0026lt;string, int32\u0026gt; subject_map = 2 [(tableau.field) = {name:\u0026quot;Subject\u0026quot; layout:LAYOUT_INCELL}]; int32 score = 3 [(tableau.field) = {name:\u0026quot;Score\u0026quot;}]; string name = 4 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    rank_conf.json { \u0026quot;rankItemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;subjectMap\u0026quot;: { \u0026quot;English\u0026quot;: 20, \u0026quot;Math\u0026quot;: 80 }, \u0026quot;score\u0026quot;: 100, \u0026quot;name\u0026quot;: \u0026quot;Tony\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;subjectMap\u0026quot;: { \u0026quot;English\u0026quot;: 19, \u0026quot;Math\u0026quot;: 80 }, \u0026quot;score\u0026quot;: 99, \u0026quot;name\u0026quot;: \u0026quot;Eric\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;subjectMap\u0026quot;: { \u0026quot;English\u0026quot;: 18, \u0026quot;Math\u0026quot;: 80 }, \u0026quot;score\u0026quot;: 98, \u0026quot;name\u0026quot;: \u0026quot;David\u0026quot; }, \u0026quot;4\u0026quot;: { \u0026quot;id\u0026quot;: 4, \u0026quot;subjectMap\u0026quot;: { \u0026quot;English\u0026quot;: 18, \u0026quot;Math\u0026quot;: 80 }, \u0026quot;score\u0026quot;: 98, \u0026quot;name\u0026quot;: \u0026quot;Jenny\u0026quot; } } }   in-cell struct list # 👉  Not supported yet.   "}).add({id:19,href:"/docs/xml/metasheet/",title:"Metasheet",description:"XML metasheet @TABLEAU guide.",content:"What is a metasheet in XML? # A metasheet is a comment block normally written at the beginning of an XML file, which must begin with keyword @TABLEAU and define types of attributes of nodes in the following lines. e.g.:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU \u0026lt;RankConf\u0026gt; \u0026lt;RankItem Score=\u0026quot;[RankItem]int32\u0026quot;/\u0026gt; \u0026lt;/RankConf\u0026gt; --\u0026gt;  Without metasheet # If one XML file has no metasheet (In other words, has no comment block beginning with @TABLEAU), no protobuf and json will be generated.\nEmpty metasheet # An empty Metasheet is like that:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- @TABLEAU --\u0026gt;  If a XML file has an empty metasheet, then types of all attributes of all nodes in the file will be automatically inferred (e.g.: int32 for 128, int64 for 1.8e15, and string for \u0026ldquo;123fdt53g\u0026rdquo; etc.).\n"}).add({id:20,href:"/docs/csv/",title:"CSV",description:"CSV guide.",content:""}).add({id:21,href:"/docs/csv/overview/",title:"Overview",description:"CSV overview.",content:"Concepts # As Tableau recognizes the pattern \u0026lt;BookName\u0026gt;#\u0026lt;SheetName\u0026gt;.csv, so a CSV workbook (Glob Pattern) \u0026lt;BookName\u0026gt;#*.csv is composed of multiple CSV worksheets (files) in the same directory.\nE.g.:\nA CSV workbook HelloWorld#*.csv is composed of three CSV worksheets:\n Worksheet Item: HelloWorld#Item.csv Worksheet Activity: HelloWorld#Activity.csv Worksheet @TABLEAU: HelloWorld#@TABLEAU.csv  Guide # As the CSV worksheet is same as the Excel worksheet, so just read Excel Guide →\n"}).add({id:22,href:"/docs/excel/",title:"Excel",description:"Excel guide.",content:""}).add({id:23,href:"/docs/excel/scalar/",title:"Scalar",description:"Scalar features.",content:"Scalar # A worksheet Apple in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; Apple  @TABLEAU      ID Name Desc     uint32 string string   Item\u0026rsquo;s ID Item\u0026rsquo;s Name Item\u0026rsquo;s Description   1 Apple A kind of delicious fruit.          In this worksheet, three scalar fields are defined:\n ID: uint32 Name: string Desc: string  Generated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message Apple { option (tableau.worksheet) = {name:\u0026quot;Apple\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; }    Apple.json { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of delicious fruit.\u0026quot; }   Note # Scalar type is usually used to define fields of struct type. Struct →\n"}).add({id:24,href:"/docs/excel/struct/",title:"Struct",description:"Struct features.",content:"Cross-cell struct # Each column name should be prefixed with a common struct variable name: \u0026lt;StructName\u0026gt;FieldName.\nA worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      PropertyID PropertyName PropertyDesc     {Property}int32 string string   Property\u0026rsquo;s ID Property\u0026rsquo;s Name Property\u0026rsquo;s Description   1 Orange A kind of sour fruit.          Note that each column name in ItemConf is prefixed with struct variable name Property which is same as struct type name.\nGenerated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; Property property = 1 [(tableau.field) = {name:\u0026quot;Property\u0026quot;}]; message Property { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } }    ItemConf.json { \u0026quot;property\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of sour fruit.\u0026quot; } }   Note # Cross-cell struct is usually used together with:\n cross-cell horizontal/vertical map, as map value type. Map → cross-cell horizontal/vertical list, as list element type. List →  Incell struct # Each field type of the struct should be scalar type.\nA worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Prop     map\u0026lt;int32, Item\u0026gt; {int32 ID,string Name,string Desc}Property   Item\u0026rsquo;s ID Item\u0026rsquo;s property.   1 1,Orange,A good fruit.   2 2,Apple   3 3          The Property column\u0026rsquo;s type is in-cell struct {int32 ID,string Name,string Desc}Property.\nGenerated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; Property prop = 2 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; span:SPAN_INNER_CELL}]; message Property { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of delicious fruit.\u0026quot; } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;\u0026quot; } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;\u0026quot; } } } }   Predefined incell struct # Each field type of the predefined struct should be scalar type.\nFor example, Property in common.proto is predefined as:\nmessage Property { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Prop     map\u0026lt;uint32, Item\u0026gt; {.Property}   Item\u0026rsquo;s ID Item\u0026rsquo;s property.   1 1,Orange,A good fruit.   2 2,Apple   3 3          The Prop column\u0026rsquo;s type is a predefined struct Property.\nGenerated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; protoconf.Property prop = 2 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; span:SPAN_INNER_CELL}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of delicious fruit.\u0026quot; } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;\u0026quot; } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;\u0026quot; } } } }   Custom named struct # By default, struct variable name is same as struct type name, but you can specify a different struct variable name. Custom named struct is mainly used to identify name prefix of continuous cells in name row, when the tableau (protogen) can\u0026rsquo;t auto-recognize the variable name.\nSyntax: just after struct type name, use parentheses () to specify struct variable name: VariableType(VariableName).\nFor example, Item is predefined:\nmessage Item { int32 id = 1 [(tableau.field).name = \u0026quot;ID\u0026quot;]; int32 num = 2 [(tableau.field).name = \u0026quot;Num\u0026quot;]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      RewardItemID RewardItemNum CostItemID CostItemNum PredefinedItemID PredefinedItemNum     {Item(RewardItem)}int32 int32 {Item(CostItem)}int32 int32 {.Item(PredefinedItem)}int32 int32   Item\u0026rsquo;s ID Item\u0026rsquo;s ID Cost\u0026rsquo;s ID Cost\u0026rsquo;s ID Predefined item\u0026rsquo;s ID Predefined item\u0026rsquo;s ID   1 100 2 200 10 20          Details: In type cell {Item(RewardItem)}int32, RewardItem is the custom variable name of new defined struct Item. And in type cell {Item(CostItem)}int32, CostItem is the custom variable name of just already defined struct Item in the same scope. Finally, in type cell {.Item(PredefinedItem)}int32, PredefinedItem is the custom variable name of predefined struct Item at global (at the same protobuf package).\nGenerated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; Item reward_item = 1 [(tableau.field) = {name:\u0026quot;RewardItem\u0026quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } Item cost_item = 2 [(tableau.field) = {name:\u0026quot;CostItem\u0026quot;}]; protoconf.Item predefined_item = 3 [(tableau.field) = {name:\u0026quot;PredefinedItem\u0026quot;}]; }    ItemConf.json { \u0026quot;rewardItem\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, \u0026quot;costItem\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, \u0026quot;predefinedItem\u0026quot;: { \u0026quot;id\u0026quot;: 10, \u0026quot;num\u0026quot;: 20 } }   Advanced predefined incell struct # In some situations, you may want to configure any complex struct in a cell, so tableau support two kinds of protobuf serialized formats: text format, and JSON format.\nSyntax: in field prop, specify form option as FORM_TEXT or FORM_JSON.\nFor example, Transform is predefined as:\nmessage Transform { Vector3 position = 1; Vector3 rotation = 2; Vector3 scale = 3; } message Vector3 { float x = 1; float y = 2; float z = 3; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Transform1 Transform2     {.Transform}|{form:FORM_TEXT} {.Transform}|{form:FORM_JSON}   Box\u0026rsquo;s transform1 Box\u0026rsquo;s transform2   position:{x:1 y:2 z:3} rotation:{x:4 y:5 z:6} scale:{x:7 y:8 z:9} {\u0026ldquo;position\u0026rdquo;:{\u0026ldquo;x\u0026rdquo;:1, \u0026ldquo;y\u0026rdquo;:2, \u0026ldquo;z\u0026rdquo;:3}, \u0026ldquo;rotation\u0026rdquo;:{\u0026ldquo;x\u0026rdquo;:4, \u0026ldquo;y\u0026rdquo;:5, \u0026ldquo;z\u0026rdquo;:6}, \u0026ldquo;scale\u0026rdquo;:{\u0026ldquo;x\u0026rdquo;:7, \u0026ldquo;y\u0026rdquo;:8, \u0026ldquo;z\u0026rdquo;:9}}          Generated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; protoconf.Transform transform_1 = 1 [(tableau.field) = {name:\u0026quot;Transform1\u0026quot; span:SPAN_INNER_CELL prop{form:FORM_TEXT}}]; protoconf.Transform transform_2 = 2 [(tableau.field) = {name:\u0026quot;Transform2\u0026quot; span:SPAN_INNER_CELL prop:{form:FORM_JSON}}]; }    ItemConf.json { \u0026quot;transform1\u0026quot;: { \u0026quot;position\u0026quot;: { \u0026quot;x\u0026quot;: 1, \u0026quot;y\u0026quot;: 2, \u0026quot;z\u0026quot;: 3 }, \u0026quot;rotation\u0026quot;: { \u0026quot;x\u0026quot;: 4, \u0026quot;y\u0026quot;: 5, \u0026quot;z\u0026quot;: 6 }, \u0026quot;scale\u0026quot;: { \u0026quot;x\u0026quot;: 7, \u0026quot;y\u0026quot;: 8, \u0026quot;z\u0026quot;: 9 } }, \u0026quot;transform2\u0026quot;: { \u0026quot;position\u0026quot;: { \u0026quot;x\u0026quot;: 1, \u0026quot;y\u0026quot;: 2, \u0026quot;z\u0026quot;: 3 }, \u0026quot;rotation\u0026quot;: { \u0026quot;x\u0026quot;: 4, \u0026quot;y\u0026quot;: 5, \u0026quot;z\u0026quot;: 6 }, \u0026quot;scale\u0026quot;: { \u0026quot;x\u0026quot;: 7, \u0026quot;y\u0026quot;: 8, \u0026quot;z\u0026quot;: 9 } } }   "}).add({id:25,href:"/docs/excel/union/",title:"Union",description:"Union type features.",content:"Theory # In protoconf, union type means the tagged union: a data structure used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a tag field explicitly indicates which one is in use. More details can be learned from wikipedia Tagged union.\nTagged union in different programming languages:\n C++: std::variant Rust: Defining an Enum  Tableau use protobuf message to bundle enum type and oneof type together to implement tagged union. By default, each enum value (\u0026gt;0) is binded to a field with the same tag number of oneof type.\nPredefined union in map # For example, union type Target in common.proto is predefined as:\n// Predefined union type. message Target { option (tableau.union) = true; Type type = 9999 [(tableau.field) = { name: \u0026quot;Type\u0026quot; }]; oneof value { option (tableau.oneof) = { field: \u0026quot;Field\u0026quot; }; Pvp pvp = 1; // Binded to enum value 1: TYPE_PVP. Pve pve = 2; // Binded to enum value 2: TYPE_PVP. Story story = 3; // Binded to enum value 3: TYPE_STORY. Skill skill = 4; // Binded to enum value 4: TYPE_SKILL. } enum Type { TYPE_NIL = 0; TYPE_PVP = 1 [(tableau.evalue) = { name: \u0026quot;PVP\u0026quot; }]; TYPE_PVE = 2 [(tableau.evalue) = { name: \u0026quot;PVE\u0026quot; }]; TYPE_STORY = 3 [(tableau.evalue) = { name: \u0026quot;Story\u0026quot; }]; TYPE_SKILL = 4 [(tableau.evalue) = { name: \u0026quot;Skill\u0026quot; }]; } message Pvp { int32 type = 1; // scalar int64 damage = 2; // scalar repeated protoconf.FruitType types = 3; // incell enum list } message Pve { Mission mission = 1; // incell struct repeated int32 heros = 2; // incell list map\u0026lt;int32, int64\u0026gt; dungeons = 3; // incell map message Mission { int32 id = 1; uint32 level = 2; int64 damage = 3; } } message Story { protoconf.Item cost = 1; // incell predefined struct map\u0026lt;int32, protoconf.FruitType\u0026gt; fruits = 2; // incell map with value as enum type map\u0026lt;int32, Flavor\u0026gt; flavors = 3; // incell map with key as enum type message Flavor { protoconf.FruitFlavor key = 1 [(tableau.field) = { name: \u0026quot;Key\u0026quot; }]; int32 value = 2 [(tableau.field) = { name: \u0026quot;Value\u0026quot; }]; } } message Skill { int32 id = 1; // scalar int64 damage = 2; // scalar // no field tag 3 } }  A worksheet TaskConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; Apple  @TABLEAU      ID TargetType TargetField1 TargetField2 TargetField3 Progress     map\u0026lt;int32, Task\u0026gt; {.Target}enum\u0026lt;.Target.Type\u0026gt; union union union int32   ID Target\u0026rsquo;s type Target\u0026rsquo;s field1 Target\u0026rsquo;s field2 Target\u0026rsquo;s field3 Progress   1 PVP 1 10 Apple,Orange,Banana 3   2 PVE 1,100,999 1,2,3 1:10,2:20,3:30 10   3 Story 1001,10 1:Apple,2:Orange Fragrant:1,Sour:2 10   4 Skill 1 2  8          Generated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message TaskConf { option (tableau.worksheet) = {name:\u0026quot;TaskConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Task\u0026gt; task_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Task { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; protoconf.Target target = 2 [(tableau.field) = {name:\u0026quot;Target\u0026quot;}]; int32 progress = 3 [(tableau.field) = {name:\u0026quot;Progress\u0026quot;}]; } }    TaskConf.json { \u0026quot;taskMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;target\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;TYPE_PVP\u0026quot;, \u0026quot;pvp\u0026quot;: { \u0026quot;type\u0026quot;: 1, \u0026quot;damage\u0026quot;: \u0026quot;10\u0026quot;, \u0026quot;types\u0026quot;: [ \u0026quot;FRUIT_TYPE_APPLE\u0026quot;, \u0026quot;FRUIT_TYPE_ORANGE\u0026quot;, \u0026quot;FRUIT_TYPE_BANANA\u0026quot; ] } }, \u0026quot;progress\u0026quot;: 3 }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;target\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;TYPE_PVE\u0026quot;, \u0026quot;pve\u0026quot;: { \u0026quot;mission\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;level\u0026quot;: 100, \u0026quot;damage\u0026quot;: \u0026quot;999\u0026quot; }, \u0026quot;heros\u0026quot;: [ 1, 2, 3 ], \u0026quot;dungeons\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;10\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;20\u0026quot;, \u0026quot;3\u0026quot;: \u0026quot;30\u0026quot; } } }, \u0026quot;progress\u0026quot;: 10 }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;target\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;TYPE_STORY\u0026quot;, \u0026quot;story\u0026quot;: { \u0026quot;cost\u0026quot;: { \u0026quot;id\u0026quot;: 1001, \u0026quot;num\u0026quot;: 10 }, \u0026quot;fruits\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;FRUIT_TYPE_APPLE\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;FRUIT_TYPE_ORANGE\u0026quot; }, \u0026quot;flavors\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;key\u0026quot;: \u0026quot;FRUIT_FLAVOR_FRAGRANT\u0026quot;, \u0026quot;value\u0026quot;: 1 }, \u0026quot;2\u0026quot;: { \u0026quot;key\u0026quot;: \u0026quot;FRUIT_FLAVOR_SOUR\u0026quot;, \u0026quot;value\u0026quot;: 2 } } } }, \u0026quot;progress\u0026quot;: 10 }, \u0026quot;4\u0026quot;: { \u0026quot;id\u0026quot;: 4, \u0026quot;target\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;TYPE_SKILL\u0026quot;, \u0026quot;skill\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;damage\u0026quot;: \u0026quot;2\u0026quot; } }, \u0026quot;progress\u0026quot;: 8 } } }   "}).add({id:26,href:"/docs/excel/list/",title:"List",description:"List features.",content:"Horizontal list # There are three kinds of horizontal list:\n Horizontal scalar/enum list, as element type is scalar. E.g: []int32. Horizontal incell struct list, as element type is incell struct. E.g: []{int32 ID, string Name}Item. Horizontal struct list, as element type is struct. E.g: [Item]int32.  Horizontal scalar list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Param1 Param2 Param3     []int32 int32 int32   Param1\u0026rsquo;s value Param2\u0026rsquo;s value Param3\u0026rsquo;s value   1 2 3          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated int32 param_list = 1 [(tableau.field) = {name:\u0026quot;Param\u0026quot; layout:LAYOUT_HORIZONTAL}]; }    ItemConf.json { \u0026quot;paramList\u0026quot;: [ 1, 2, 3 ] }   Horizontal enum list # FruitType in common.proto is predefined as:\nenum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = \u0026quot;Apple\u0026quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = \u0026quot;Orange\u0026quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = \u0026quot;Banana\u0026quot;]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Param1 Param2 Param3     []enum\u0026lt;.FruitType\u0026gt; enum\u0026lt;.FruitType\u0026gt; enum\u0026lt;.FruitType\u0026gt;   Param1\u0026rsquo;s value Param2\u0026rsquo;s value Param3\u0026rsquo;s value   1 FRUIT_TYPE_ORANGE Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated protoconf.FruitType param_list = 1 [(tableau.field) = {name:\u0026quot;Param\u0026quot; layout:LAYOUT_HORIZONTAL}]; }    ItemConf.json { \u0026quot;paramList\u0026quot;: [ \u0026quot;FRUIT_TYPE_APPLE\u0026quot;, \u0026quot;FRUIT_TYPE_ORANGE\u0026quot;, \u0026quot;FRUIT_TYPE_BANANA\u0026quot; ] }   Horizontal struct list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name     [Item]uint32 string uint32 string uint32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s name Item2\u0026rsquo;s ID Item2\u0026rsquo;s name Item3\u0026rsquo;s ID Item3\u0026rsquo;s name   1 Apple 2 Orange 3 Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot; }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot; }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot; } ] }   Horizontal predefined-struct list # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Num Item2ID Item2Num Item3ID Item3Num     [.Item]int32 int32 int32 int32 int32 int32   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Item2\u0026rsquo;s ID Item3\u0026rsquo;s num Item3\u0026rsquo;s ID Item3\u0026rsquo;s num   1 100 2 200 3 300          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated protoconf.Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL}]; }    ItemConf.json { \u0026quot;ItemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, { \u0026quot;id\u0026quot;: 3, \u0026quot;num\u0026quot;: 300 } ] }   Horizontal incell-struct list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1 Item2 Item3     []{int32 ID, string Name}Item Item Item   Item1\u0026rsquo;s info Item2\u0026rsquo;s info Item3\u0026rsquo;s info   1,Apple 2,Orange 3,Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot; }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot; }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot; } ] }   Horizontal incell-predefined-struct list # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1 Item2 Item3     []{.Item} .Item .Item   Item1\u0026rsquo;s info Item2\u0026rsquo;s info Item3\u0026rsquo;s info   1,100 2,200 3,300          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated protoconf.Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL span:SPAN_INNER_CELL}]; }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, { \u0026quot;id\u0026quot;: 3, \u0026quot;num\u0026quot;: 300 } ] }   Vertical list # There are two kinds of vertical list:\n Vertical scalar list, as list element type is scalar. E.g: []int32. Vertical struct list, as list element type is struct. E.g: [Item]int32.  Vertical scalar list # No need to support, use [Item]SCALAR instead:\n [Item]int32 [Item]enum\u0026lt;.FruitType\u0026gt;  Vertical struct list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name Desc     [Item]uint32 string string   Item\u0026rsquo;s ID Item\u0026rsquo;s name Item\u0026rsquo;s desc   1 Apple A kind of delicious fruit.   2 Orange A kind of sour fruit.   3 Banana A kind of calorie-rich fruit.          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of delicious fruit.\u0026quot; }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of sour fruit.\u0026quot; }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of calorie-rich fruit.\u0026quot; } ] }   Vertical predefined-struct list # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Num     [.Item]int32 int32   Item\u0026rsquo;s ID Item\u0026rsquo;s num   1 100   2 200   3 300          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated protoconf.Item _item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; }    ItemConf.json { \u0026quot;ItemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, { \u0026quot;id\u0026quot;: 3, \u0026quot;num\u0026quot;: 300 } ] }   Vertical incell-struct list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item     []{int32 ID,int32 Num}Item   Item\u0026rsquo;s info   1,100   2,200   3,300          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_VERTICAL span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, { \u0026quot;id\u0026quot;: 3, \u0026quot;num\u0026quot;: 300 } ] }   Vertical incell-predefined-struct list # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item     []{.Item}   Item\u0026rsquo;s info   1,100   2,200   3,300          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated protoconf.Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_VERTICAL span:SPAN_INNER_CELL}]; }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, { \u0026quot;id\u0026quot;: 3, \u0026quot;num\u0026quot;: 300 } ] }   Incell list # There are two kinds of in-cell list:\n Incell scalar list, as list value type is scalar. E.g: []int32. Incell struct list, as list value type is struct. E.g: [Item]int32.  Incell scalar list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Param     []int32   Param list   1,2,3   4,5   6          The Param column\u0026rsquo;s type is incell list []int32, as the list element is scalar type int32.\nGenerated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated int32 param_list = 1 [(tableau.field) = {name:\u0026quot;Param\u0026quot; layout:LAYOUT_INCELL}]; }    ItemConf.json { \u0026quot;paramList\u0026quot;: [ 1, 2, 3, 4, 5, 6 ] }   Incell struct list # No need to support.\nHorizontal list size # Dynamic size # By default, all lists are Dynamically Sized Types. List elements should be present continuously, otherwise an error is reported if an empty element is existed in between.\nFixed size # Implicit fixed size # The list size is auto resolved by the max present list elements in name row.\nIn this example below, though the second element Item2 is empty, it is legal as the field property fixed is set true. Besides, Item2 will also be generated as an empty element. You can see it in the generated file ItemConf.json.\nA worksheet ItemConf in HelloWorld.xlsx.\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name     [Item]uint32|{fixed:true} string uint32 string uint32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s name Item2\u0026rsquo;s ID Item2\u0026rsquo;s name Item3\u0026rsquo;s ID Item3\u0026rsquo;s name   1 Apple   3 Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL prop:{fixed:true}}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }   ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot; }, { \u0026quot;id\u0026quot;: 0, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot; }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot; } ] }   Explicit fixed size # The list size is explicitly set by field property size.\nIn this example below, field property size is set as 2, then list elements after the second element Item2 will all be truncated. Besides, Item2 will also be generated as an empty element. You can see it in the generated file ItemConf.json.\nA worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name     [Item]uint32|{size:2} string uint32 string uint32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s name Item2\u0026rsquo;s ID Item2\u0026rsquo;s name Item3\u0026rsquo;s ID Item3\u0026rsquo;s name   1 Apple   3 Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL prop:{size:2}}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }   ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot; }, { \u0026quot;id\u0026quot;: 0, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot; } ] }   Advanced features # Horizontal column-skipped list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      D Prop1ID  Prop1Value Prop2ID  Prop2Value     map\u0026lt;uint32, Item\u0026gt; [Prop]int32  int32 int32  int32   Item\u0026rsquo;s ID Prop1’s ID Prop1’s name Prop1’s value Prop2’s ID Prop2’s name Prop2’s value   1 1 Apple 100 2 Orange 200   2 3 Banana 300 4 Pomelo 400   3 5 Watermelon 500             Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; repeated Prop prop_list = 2 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    HeroConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: 100 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: 200 } ] }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 3, \u0026quot;value\u0026quot;: 300 }, { \u0026quot;id\u0026quot;: 4, \u0026quot;value\u0026quot;: 400 } ] }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 5, \u0026quot;value\u0026quot;: 500 } ] } } }   Keyed list # Keyed list is same as normal list, except that ColumnType (first field type) is surrounded by angle brackets \u0026lt;\u0026gt;, and is treated as map key.\nSyntax: [ElemType]\u0026lt;ColumnType\u0026gt;\nVertical struct keyed-list # For example, a worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID PropID PropName     [Item]\u0026lt;uint32\u0026gt; map\u0026lt;int32, Prop\u0026gt; string   Item\u0026rsquo;s ID Prop\u0026rsquo;s ID Prop\u0026rsquo;s name   1 1 sweet   2 1 sweet   2 2 delicious          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 2 [(tableau.field) = {key:\u0026quot;PropID\u0026quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; string prop_name = 2 [(tableau.field) = {name:\u0026quot;PropName\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propName\u0026quot;: \u0026quot;sweet\u0026quot; } } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propName\u0026quot;: \u0026quot;sweet\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;propId\u0026quot;: 2, \u0026quot;propName\u0026quot;: \u0026quot;delicious\u0026quot; } } } ] }   Scalar keyed-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Param     []\u0026lt;int32\u0026gt;   Param list   1,2,2,3          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated int32 param_list = 1 [(tableau.field) = {name:\u0026quot;Param\u0026quot; key:\u0026quot;Param\u0026quot; layout:LAYOUT_INCELL}]; }    ItemConf.json { \u0026quot;paramList\u0026quot;: [ 1, 2, 3 ] }   "}).add({id:27,href:"/docs/excel/map/",title:"Map",description:"Map features.",content:"Horizontal map # There are some kinds of horizontal map:\n Horizontal scalar map, as map value type is scalar. E.g: map\u0026lt;int32, int32\u0026gt;. Horizontal struct map, as map value type is struct. E.g: map\u0026lt;int32, Item\u0026gt;. Horizontal predefined-struct map, as map value type is predefined struct. E.g: map\u0026lt;int32, .Item\u0026gt;.  Horizontal scalar map # No need to support, use this instead: map\u0026lt;int32, Item\u0026gt;.\nHorizontal struct map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name     map\u0026lt;uint32, Item\u0026gt; string uint32 string uint32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s name Item2\u0026rsquo;s ID Item2\u0026rsquo;s name Item3\u0026rsquo;s ID Item3\u0026rsquo;s name   1 Apple 2 Orange 3 Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot; } } }   Horizontal predefined-struct map # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Num Item2ID Item2Num Item3ID Item3Num     map\u0026lt;int32, .Item\u0026gt; int32 int32 int32 int32 int32   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Item2\u0026rsquo;s ID Item3\u0026rsquo;s num Item3\u0026rsquo;s ID Item3\u0026rsquo;s num   1 100 2 200 3 300          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, protoconf.Item\u0026gt; item_map = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;num\u0026quot;: 300 } } }   Vertical map # There are some kinds of vertical map:\n Vertical scalar map, as map value type is scalar. E.g: map\u0026lt;int32, int32\u0026gt;. Vertical struct map, as map value type is struct. E.g: map\u0026lt;int32, Item\u0026gt;. Vertical predefined-struct map, as map value type is predefined struct. E.g: map\u0026lt;int32, .Item\u0026gt;.  Vertical scalar map # No need to support, use map\u0026lt;int32, Item\u0026gt; instead.\nVertical struct map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name Desc     map\u0026lt;uint32, Item\u0026gt; string string   Item’s ID Item’s name Item’s desc   1 Apple A kind of delicious fruit.   2 Orange A kind of sour fruit.   3 Banana A kind of calorie-rich fruit.          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of delicious fruit.\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of sour fruit.\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of calorie-rich fruit.\u0026quot; } } }   Vertical predefined-struct map # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Num     map\u0026lt;int32, .Item\u0026gt; int32   Item\u0026rsquo;s ID Item\u0026rsquo;s num   1 100   2 200   3 300          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, protoconf.Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;num\u0026quot;: 300 } } }   Incell map # There are some kinds of in-cell map:\n in-cell scalar map, as map value type is scalar. E.g: map\u0026lt;int32, int32\u0026gt;. in-cell struct map, as map value type is struct. E.g: map\u0026lt;int32, Item\u0026gt;.  Incell scalar map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Items     map\u0026lt;uint32, string\u0026gt;   Items   1:Apple,2:Orange,3:Banana          The Items column\u0026rsquo;s type is in-cell map map\u0026lt;uint32, string\u0026gt;, as the map value is scalar type string.\nGenerated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, string\u0026gt; items_map = 1 [(tableau.field) = {name:\u0026quot;Items\u0026quot; layout:LAYOUT_INCELL}]; }    ItemConf.json { \u0026quot;itemsMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;3\u0026quot;: \u0026quot;Banana\u0026quot; } }   Incell enum map # The key and value of incell map can be enum types.\nFor example, predefined enum types FruitType and FruitFlavor in common.proto are:\nenum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = \u0026quot;Apple\u0026quot;]; FRUIT_TYPE_ORANGE = 2 [(tableau.evalue).name = \u0026quot;Orange\u0026quot;]; FRUIT_TYPE_BANANA = 3 [(tableau.evalue).name = \u0026quot;Banana\u0026quot;]; } enum FruitFlavor { FRUIT_FLAVOR_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; FRUIT_FLAVOR_FRAGRANT = 1 [(tableau.evalue).name = \u0026quot;Fragrant\u0026quot;]; FRUIT_FLAVOR_SOUR = 2 [(tableau.evalue).name = \u0026quot;Sour\u0026quot;]; FRUIT_FLAVOR_SWEET = 3 [(tableau.evalue).name = \u0026quot;Sweet\u0026quot;]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Fruit Flavor Item     map\u0026lt;enum\u0026lt;.FruitType\u0026gt;, int64\u0026gt; map\u0026lt;int64, enum\u0026lt;.FruitFlavor\u0026raquo; map\u0026lt;enum\u0026lt;.FruitType\u0026gt;, enum\u0026lt;.FruitFlavor\u0026raquo;   Fruits Flavors Items   Apple:1,Orange:2 1:Fragrant,2:Sweet Apple:Fragrant,Orange:Sour          Generated:\n hello_world.proto // --snip-- import \u0026quot;common.proto\u0026quot;; option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Fruit\u0026gt; fruit_map = 1 [(tableau.field) = {name:\u0026quot;Fruit\u0026quot; key:\u0026quot;Key\u0026quot; layout:LAYOUT_INCELL}]; message Fruit { protoconf.FruitType key = 1 [(tableau.field) = {name:\u0026quot;Key\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } map\u0026lt;int64, protoconf.FruitFlavor\u0026gt; flavor_map = 2 [(tableau.field) = {name:\u0026quot;Flavor\u0026quot; layout:LAYOUT_INCELL}]; map\u0026lt;int32, Item\u0026gt; item_map = 3 [(tableau.field) = {name:\u0026quot;Item\u0026quot; key:\u0026quot;Key\u0026quot; layout:LAYOUT_INCELL}]; message Item { protoconf.FruitType key = 1 [(tableau.field) = {name:\u0026quot;Key\u0026quot;}]; protoconf.FruitFlavor value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } }    ItemConf.json { \u0026quot;fruitMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;key\u0026quot;: \u0026quot;FRUIT_TYPE_APPLE\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;1\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;key\u0026quot;: \u0026quot;FRUIT_TYPE_ORANGE\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;2\u0026quot; } }, \u0026quot;flavorMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;FRUIT_FLAVOR_FRAGRANT\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;FRUIT_FLAVOR_SWEET\u0026quot; }, \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;key\u0026quot;: \u0026quot;FRUIT_TYPE_APPLE\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;FRUIT_FLAVOR_FRAGRANT\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;key\u0026quot;: \u0026quot;FRUIT_TYPE_ORANGE\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;FRUIT_FLAVOR_SOUR\u0026quot; } } }   Empty key map # If map key is not configured, then it will be treated as default value of map key type. Default value is illustrated at Scalar types →.\nA worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Desc     map\u0026lt;uint32, Item\u0026gt; string   Item\u0026rsquo;s ID Item\u0026rsquo;s name   1 Apple    Orange   3 Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string desc = 2 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;0\u0026quot;: { \u0026quot;id\u0026quot;: 0, \u0026quot;desc\u0026quot;: \u0026quot;Orange\u0026quot; }, \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;desc\u0026quot;: \u0026quot;Apple\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;desc\u0026quot;: \u0026quot;Banana\u0026quot; } } }   Enum key map # As the protobuf documents the restrictions of map key type:\n \u0026hellip; the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). Note that enum is not a valid key_type.\n However, key type as enum is very useful in some situations. So we support it in a simple way:\n enum type is treated as int32 as map key type， enum type is keeped in map value type (struct).  For example, FruitType in common.proto is predefined as:\nenum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = \u0026quot;Apple\u0026quot;]; FRUIT_TYPE_ORANGE = 3 [(tableau.evalue).name = \u0026quot;Orange\u0026quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = \u0026quot;Banana\u0026quot;]; }  then map\u0026lt;enum\u0026lt;.FruitType\u0026gt;, ValueType\u0026gt; will be converted to map\u0026lt;int32, ValueType\u0026gt;, and FruitType is keeped in ValueType:\nmessage ValueType { FruitType key = 1; ... }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Type Price     map\u0026lt;enum\u0026lt;.FruitType\u0026gt;, Item\u0026gt; int32   Item\u0026rsquo;s type Item\u0026rsquo;s price   Apple 100   Orange 200   Banana 300          Generated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { protoconf.FruitType type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; int32 price = 2 [(tableau.field) = {name:\u0026quot;Price\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;FRUIT_TYPE_APPLE\u0026quot;, \u0026quot;price\u0026quot;: 100 }, \u0026quot;3\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;FRUIT_TYPE_ORANGE\u0026quot;, \u0026quot;price\u0026quot;: 200 }, \u0026quot;4\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;FRUIT_TYPE_BANANA\u0026quot;, \u0026quot;price\u0026quot;: 300 } } }   Horizontal map size # Dynamic size # By default, all maps are Dynamically Sized Types. Map items should be present continuously, otherwise an error is reported if an empty item is existed in between.\nFixed size # Implicit fixed size # The map size is auto resolved by the max map items present in name row.\nIn this example below, though the second map item Item2 is empty, it is legal as the field property fixed is set true. Besides, Item2 will also be generated as an empty map item. You can see it in the generated file ItemConf.json.\n👉  If more than one empty map items are inserted into map, then only one empty map item is really generated. Because all the empty map items's keys are same. This is different from list, you should pay special attention to it.   A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name     map\u0026lt;uint32, Item\u0026gt;|{fixed:true} string uint32 string uint32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s name Item2\u0026rsquo;s ID Item2\u0026rsquo;s name Item3\u0026rsquo;s ID Item3\u0026rsquo;s name   1 Apple   3 Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL prop:{fixed:true}}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }   ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;0\u0026quot;: { \u0026quot;id\u0026quot;: 0, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot; }, \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot; } } }   Explicit fixed size # The map size is explicitly set by field property size.\nIn this example below, field property size is set as 2, then map items after the second item Item2 will all be truncated. Besides, Item2 will also be generated as an empty map item. You can see it in the generated file ItemConf.json.\n👉  If more than one empty map items are inserted into map, then only one empty map item is really generated. Because all the empty map items's keys are same. This is different from list, you should pay special attention to it.   A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Item1ID Item1Name Item2ID Item2Name Item3ID Item3Name     map\u0026lt;uint32, Item\u0026gt;|{size:2} string uint32 string uint32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s name Item2\u0026rsquo;s ID Item2\u0026rsquo;s name Item3\u0026rsquo;s ID Item3\u0026rsquo;s name   1 Apple   3 Banana          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL prop:{size:2}}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }   ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;0\u0026quot;: { \u0026quot;id\u0026quot;: 0, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot; }, \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot; } } }   Advanced features # Horizontal column-skipped map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      D Prop1ID  Prop1Value Prop2ID  Prop2Value     map\u0026lt;uint32, Item\u0026gt; map\u0026lt;int32, Prop\u0026gt;  int32 int32  int32   Item\u0026rsquo;s ID Prop1’s ID Prop1’s name Prop1’s value Prop2’s ID Prop2’s name Prop2’s value   1 1 Apple 100 2 Orange 200   2 3 Banana 300 4 Pomelo 400   3 5 Watermelon 500             Generated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 2 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    HeroConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;desc\u0026quot;: \u0026quot;item1\u0026quot;, \u0026quot;propertyMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;10\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: \u0026quot;20\u0026quot; } } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;desc\u0026quot;: \u0026quot;item2\u0026quot;, \u0026quot;propertyMap\u0026quot;: { \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;value\u0026quot;: \u0026quot;30\u0026quot; }, \u0026quot;4\u0026quot;: { \u0026quot;id\u0026quot;: 4, \u0026quot;value\u0026quot;: \u0026quot;40\u0026quot; } } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;desc\u0026quot;: \u0026quot;item3\u0026quot;, \u0026quot;propertyMap\u0026quot;: { \u0026quot;5\u0026quot;: { \u0026quot;id\u0026quot;: 5, \u0026quot;value\u0026quot;: \u0026quot;50\u0026quot; } } } } }   Ordered-map # In the metasheet @TABLEAU, set the OrderedMap option to true, then ordered map accessers will be generated. This feature is powered by tableauio/loader. Currently supported programming languages are:\n C++ Golang C#  Example # If we want ItemConf to generate ordered map accessers, then set OrderedMap option to true of metasheet @TABLEAU:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name     map\u0026lt;uint32, Item\u0026gt; string   Item\u0026rsquo;s ID Item\u0026rsquo;s Name   1 Apple   2 Orange   3 Banana         Sheet OrderedMap     ItemConf true        More useful options are illustrated at metasheet chapter. Metasheet @TABLEAU →\n"}).add({id:28,href:"/docs/excel/struct-in-struct/",title:"Struct in struct",description:"The nesting specification of struct in struct.",content:"Struct in struct # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      RewardID RewardItemID RewardItemNum     {Reward}int32 {Item}int32 int32   Reward\u0026rsquo;s ID Item\u0026rsquo;s ID Item\u0026rsquo;s num   1 1 10          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; Reward reward = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot;}]; message Reward { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; Item item = 2 [(tableau.field) = {name:\u0026quot;Item\u0026quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } } }    ItemConf.json { \u0026quot;reward\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 } } }   Predefined-struct in struct # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      RewardID RewardItemID RewardItemNum     {Reward}int32 {.Item}int32 int32   Reward\u0026rsquo;s ID Item\u0026rsquo;s ID Item\u0026rsquo;s num   1 1 10          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; Reward reward = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot;}]; message Reward { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; protoconf.Item item = 2 [(tableau.field) = {name:\u0026quot;Item\u0026quot;}]; } }    ItemConf.json { \u0026quot;reward\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 } } }   Incell-struct in struct # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      RewardID RewardItem     {Reward}int32 {int32 ID, int32 Num}Item   Reward\u0026rsquo;s ID Reward\u0026rsquo;s item   1 1,100    2,200          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; Reward reward = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot;}]; message Reward { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; Item item = 2 [(tableau.field) = {name:\u0026quot;Item\u0026quot; span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } } }    ItemConf.json { \u0026quot;reward\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 } } }   "}).add({id:29,href:"/docs/excel/struct-in-list/",title:"Struct in list",description:"The nesting specification of struct in list.",content:"Nested in vertical-list # Struct in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name PropID PropValue     [Item]uint32 string {Prop}int32 int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop\u0026rsquo;s ID Prop\u0026rsquo;s value   1 Apple 1 10   2 Orange 2 20   3 Banana            Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; Prop prop = 3 [(tableau.field) = {name:\u0026quot;Prop\u0026quot;}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;10\u0026quot; } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;prop\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: \u0026quot;20\u0026quot; } }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;prop\u0026quot;: null } ] }   Incell-struct in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name PropID     [Item]uint32 string {int32 ID,int64 Value}Prop   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop\u0026rsquo;s ID   1 Apple 1,100   2 Orange 2,200   3 Banana           Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; Prop prop_id = 3 [(tableau.field) = {name:\u0026quot;PropID\u0026quot; span:SPAN_INNER_CELL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propId\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;100\u0026quot; } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propId\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: \u0026quot;200\u0026quot; } }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;propId\u0026quot;: null } ] }   First-field in horizontal-list # Struct in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Reward1ItemID Reward1ItemNum Reward1Name Reward2ItemID Reward2ItemNum Reward2Name     [Reward]{Item}int32 int32 string int32 int32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name   1 10 Lotto 10 100 Super Lotto          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Reward reward_list = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Reward { Item item = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;rewardList\u0026quot;: [ { \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 }, \u0026quot;name\u0026quot;: \u0026quot;Lotto\u0026quot; }, { \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 10, \u0026quot;num\u0026quot;: 100 }, \u0026quot;name\u0026quot;: \u0026quot;Super Lotto\u0026quot; } ] }   Predefined-struct in horizontal-list # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Reward1ItemID Reward1ItemNum Reward1Name Reward2ItemID Reward2ItemNum Reward2Name     [Reward]{.Item}int32 int32 string int32 int32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name   1 10 Lotto 10 100 Super Lotto          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Reward reward_list = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Reward { protoconf.Item item = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;rewardList\u0026quot;: [ { \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 }, \u0026quot;name\u0026quot;: \u0026quot;Lotto\u0026quot; }, { \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 10, \u0026quot;num\u0026quot;: 100 }, \u0026quot;name\u0026quot;: \u0026quot;Super Lotto\u0026quot; } ] }   Incell-struct in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Reward1Item Reward1Name Reward2Item Reward2Name     [Reward]{int32 ID, int32 Num}Item string Item string   Reward1\u0026rsquo;s item Reward\u0026rsquo;s name Reward2\u0026rsquo;s item Reward\u0026rsquo;s name   1,10 Lotto 2,20 Super Lotto          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; Prop prop_id = 3 [(tableau.field) = {name:\u0026quot;PropID\u0026quot; span:SPAN_INNER_CELL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    ItemConf.json { \u0026quot;rewardList\u0026quot;: [ { \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 }, \u0026quot;name\u0026quot;: \u0026quot;Lotto\u0026quot; }, { \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 20 }, \u0026quot;name\u0026quot;: \u0026quot;Super Lotto\u0026quot; } ] }   "}).add({id:30,href:"/docs/excel/struct-in-map/",title:"Struct in map",description:"The nesting specification of struct in map.",content:"Nested in vertical-map # Struct in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID ItemID ItemNum     map\u0026lt;int32, Reward\u0026gt; {Item}int32 int32   Reward\u0026rsquo;s ID Item\u0026rsquo;s ID Item\u0026rsquo;s Num   1 1 10   2 2 20   3            Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Reward\u0026gt; reward_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Reward { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; Item item = 2 [(tableau.field) = {name:\u0026quot;Item\u0026quot;}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } } }    ItemConf.json { \u0026quot;rewardMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 20 } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;item\u0026quot;: null } } }   Predefined-struct in vertical-map # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID ItemID ItemNum     map\u0026lt;int32, Reward\u0026gt; {.Item}int32 int32   Reward\u0026rsquo;s ID Item\u0026rsquo;s ID Item\u0026rsquo;s Num   1 1 10   2 2 20   3            Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Reward\u0026gt; reward_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Reward { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; protoconf.Item item = 2 [(tableau.field) = {name:\u0026quot;Item\u0026quot;}]; } }    ItemConf.json { \u0026quot;rewardMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 20 } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;item\u0026quot;: null } } }   Incell-struct in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Item     map\u0026lt;int32, Reward\u0026gt; {int32 ID, int32 Num}Item   Reward\u0026rsquo;s ID Item\u0026rsquo;s info   1 1,100   2 2,200   3           Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Reward\u0026gt; reward_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Reward { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; Item item = 2 [(tableau.field) = {name:\u0026quot;Item\u0026quot; span:SPAN_INNER_CELL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } } }    ItemConf.json { \u0026quot;rewardMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 100 } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;item\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 200 } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;item\u0026quot;: null } } }   "}).add({id:31,href:"/docs/excel/list-in-list/",title:"List in list",description:"The nesting specification of list in list.",content:"Nested in vertical-list # Horizontal-list in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name Prop1ID Prop1Value Prop2ID Prop2Value     [Item]uint32 string [Prop]int32 int64 int32 int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop1\u0026rsquo;s ID Prop1\u0026rsquo;s value Prop2\u0026rsquo;s ID Prop2\u0026rsquo;s value   1 Apple 1 10 2 20   2 Orange 3 30     3 Banana              Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;10\u0026quot; }, { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: \u0026quot;20\u0026quot; } ] }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 3, \u0026quot;value\u0026quot;: \u0026quot;30\u0026quot; } ] }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;propList\u0026quot;: [] } ] }   Vertical-list in vertical-keyed-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name PropID PropValue     [Item]\u0026lt;uint32\u0026gt; string [Prop]int32 int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop\u0026rsquo;s ID Prop\u0026rsquo;s value   1 Apple 1 10   2 Orange 1 20   2 Banana 2 30          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;10\u0026quot; } ] }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;20\u0026quot; }, { \u0026quot;propId\u0026quot;: 2, \u0026quot;propValue\u0026quot;: \u0026quot;30\u0026quot; } ] } ] }   Incell-list in vertical-keyed-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Prop     [Item]uint32 []int32   Item\u0026rsquo;s ID Item\u0026rsquo;s props   1 10,20,30   2 10,20   3 10          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; repeated int32 prop_list = 2 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_INCELL}]; } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;propList\u0026quot;: [ 10, 20, 30 ] }, { \u0026quot;id\u0026quot;: 2, \u0026quot;propList\u0026quot;: [ 10, 20 ] }, { \u0026quot;id\u0026quot;: 3, \u0026quot;propList\u0026quot;: [ 10 ] } ] }   First-field in horizontal-list # Horizontal-list in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name     [Reward][Item]int32 int32 int32 int32 string int32 int32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Item2\u0026rsquo;s ID Item2\u0026rsquo;s num Reward\u0026rsquo;s name Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name   1 10 2 20 Lotto 10 100 Super Lotto          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Reward reward_list = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Reward { repeated Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;rewardList\u0026quot;: [ { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 20 } ], \u0026quot;name\u0026quot;: \u0026quot;Lotto\u0026quot; }, { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 10, \u0026quot;num\u0026quot;: 100 } ], \u0026quot;name\u0026quot;: \u0026quot;Super Lotto\u0026quot; } ] }   Predefined-struct-list in horizontal-list # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name     [Reward][.Item]int32 int32 int32 int32 string int32 int32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Item2\u0026rsquo;s ID Item2\u0026rsquo;s num Reward\u0026rsquo;s name Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name   1 10 2 20 Lotto 10 100 Super Lotto          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Reward reward_list = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Reward { repeated protoconf.Item item_list = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; layout:LAYOUT_HORIZONTAL}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;rewardList\u0026quot;: [ { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 20 } ], \u0026quot;name\u0026quot;: \u0026quot;Lotto\u0026quot; }, { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 10, \u0026quot;num\u0026quot;: 100 } ], \u0026quot;name\u0026quot;: \u0026quot;Super Lotto\u0026quot; } ] }   "}).add({id:32,href:"/docs/excel/list-in-map/",title:"List in map",description:"The nesting specification of list in map.",content:"Nested in vertical-map # Horizontal-list in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name Prop1ID Prop1Value Prop2ID Prop2Value     map\u0026lt;uint32, Item\u0026gt; string [Prop]int32 int64 int32 int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop1\u0026rsquo;s ID Prop1\u0026rsquo;s value Prop2\u0026rsquo;s ID Prop2\u0026rsquo;s value   1 Apple 1 10 2 20   2 Orange 3 30     3 Banana              Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;10\u0026quot; }, { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: \u0026quot;20\u0026quot; } ] }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 3, \u0026quot;value\u0026quot;: \u0026quot;30\u0026quot; } ] }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;propList\u0026quot;: [] } } }   Vertical-list in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name PropID PropValue     map\u0026lt;uint32, Item\u0026gt; string [Prop]int32 int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop\u0026rsquo;s ID Prop\u0026rsquo;s value   1 Apple 1 10   2 Orange 1 20   2 Banana 2 30          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; repeated Prop prop_list = 3 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;10\u0026quot; } ] }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propList\u0026quot;: [ { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;20\u0026quot; }, { \u0026quot;propId\u0026quot;: 2, \u0026quot;propValue\u0026quot;: \u0026quot;30\u0026quot; } ] } } }   Incell-list in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Prop     map\u0026lt;uint32, Item\u0026gt; []int32   Item\u0026rsquo;s ID Item\u0026rsquo;s props   1 10,20,30   2 10,20   3 10          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; repeated int32 prop_list = 2 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_INCELL}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;propList\u0026quot;: [ 10, 20, 30 ] }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;propList\u0026quot;: [ 10, 20 ] }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;propList\u0026quot;: [ 10 ] } } }   "}).add({id:33,href:"/docs/excel/map-in-list/",title:"Map in list",description:"The nesting specification of map in list.",content:"Nested in vertical-list # Horizontal-map in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name Prop1ID Prop1Value Prop2ID Prop2Value     [Item]uint32 string map\u0026lt;int32, Prop\u0026gt; int64 int32 int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop1\u0026rsquo;s ID Prop1\u0026rsquo;s value Prop2\u0026rsquo;s ID Prop2\u0026rsquo;s value   1 Apple 1 10 2 20   2 Orange 3 30     3 Banana              Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 3 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;10\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: \u0026quot;20\u0026quot; } } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;value\u0026quot;: \u0026quot;30\u0026quot; } } }, { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;propMap\u0026quot;: {} } ] }   Vertical-map in vertical-keyed-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name PropID PropValue     [Item]\u0026lt;uint32\u0026gt; string map\u0026lt;int32, Prop\u0026gt; int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop\u0026rsquo;s ID Prop\u0026rsquo;s value   1 Apple 1 10   2 Orange 1 20   2 Banana 2 30          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 3 [(tableau.field) = {key:\u0026quot;PropID\u0026quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;10\u0026quot; } } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;20\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;propId\u0026quot;: 2, \u0026quot;propValue\u0026quot;: \u0026quot;30\u0026quot; } } } ] }   Incell-map in vertical-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Props     [Item]uint32 map\u0026lt;int32, string\u0026gt;   Item\u0026rsquo;s ID Item\u0026rsquo;s props   1 1:sour,2:sweet,3:delicious   2 1:sour,2:sweet   3 1:sour          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Item item_list = 1 [(tableau.field) = {layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; map\u0026lt;int32, string\u0026gt; props_map = 2 [(tableau.field) = {name:\u0026quot;Props\u0026quot; layout:LAYOUT_INCELL}]; } }    ItemConf.json { \u0026quot;itemList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;propsMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;sour\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;sweet\u0026quot;, \u0026quot;3\u0026quot;: \u0026quot;delicious\u0026quot; } }, { \u0026quot;id\u0026quot;: 2, \u0026quot;propsMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;sour\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;sweet\u0026quot; } }, { \u0026quot;id\u0026quot;: 3, \u0026quot;propsMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;sour\u0026quot; } } ] }   First-field in horizontal-list # Horizontal-map in horizontal-list # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name     [Reward]map\u0026lt;int32, Item\u0026gt; int32 int32 int32 string int32 int32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Item2\u0026rsquo;s ID Item2\u0026rsquo;s num Reward\u0026rsquo;s name Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name   1 10 2 20 Lotto 10 100 Super Lotto          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Reward reward_list = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Reward { map\u0026lt;int32, Item\u0026gt; item_map = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; } string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;rewardList\u0026quot;: [ { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 20 } }, \u0026quot;name\u0026quot;: \u0026quot;Lotto\u0026quot; }, { \u0026quot;itemMap\u0026quot;: { \u0026quot;10\u0026quot;: { \u0026quot;id\u0026quot;: 10, \u0026quot;num\u0026quot;: 100 } }, \u0026quot;name\u0026quot;: \u0026quot;Super Lotto\u0026quot; } ] }   Predefined-struct-map in horizontal-list # Item in common.proto is predefined as:\nmessage Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int32 num = 2 [(tableau.field) = {name:\u0026quot;Num\u0026quot;}]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      Reward1Item1ID Reward1Item1Num Reward1Item2ID Reward1Item2Num Reward1Name Reward2Item1ID Reward2Item1Num Reward2Name     [Reward]map\u0026lt;int32, .Item\u0026gt; int32 int32 int32 string int32 int32 string   Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Item2\u0026rsquo;s ID Item2\u0026rsquo;s num Reward\u0026rsquo;s name Item1\u0026rsquo;s ID Item1\u0026rsquo;s num Reward\u0026rsquo;s name   1 10 2 20 Lotto 10 100 Super Lotto          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; repeated Reward reward_list = 1 [(tableau.field) = {name:\u0026quot;Reward\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Reward { map\u0026lt;int32, protoconf.Item\u0026gt; item_map = 1 [(tableau.field) = {name:\u0026quot;Item\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; } }    ItemConf.json { \u0026quot;rewardList\u0026quot;: [ { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;num\u0026quot;: 10 }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;num\u0026quot;: 20 } }, \u0026quot;name\u0026quot;: \u0026quot;Lotto\u0026quot; }, { \u0026quot;itemMap\u0026quot;: { \u0026quot;10\u0026quot;: { \u0026quot;id\u0026quot;: 10, \u0026quot;num\u0026quot;: 100 } }, \u0026quot;name\u0026quot;: \u0026quot;Super Lotto\u0026quot; } ] }   "}).add({id:34,href:"/docs/excel/map-in-map/",title:"Map in map",description:"The nesting specification of map in map.",content:"Nested in vertical-map # Horizontal-map in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name Prop1ID Prop1Value Prop2ID Prop2Value     map\u0026lt;uint32, Item\u0026gt; string map\u0026lt;int32, Prop\u0026gt; int64 int32 int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop1\u0026rsquo;s ID Prop1\u0026rsquo;s value Prop2\u0026rsquo;s ID Prop2\u0026rsquo;s value   1 Apple 1 10 2 20   2 Orange 3 30     3 Banana              Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 3 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; key:\u0026quot;ID\u0026quot; layout:LAYOUT_HORIZONTAL}]; message Prop { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; int64 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;10\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: \u0026quot;20\u0026quot; } } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;value\u0026quot;: \u0026quot;30\u0026quot; } } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;propMap\u0026quot;: {} } } }   Vertical-map in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Name PropID PropValue     map\u0026lt;uint32, Item\u0026gt; string map\u0026lt;int32, Prop\u0026gt; int64   Item\u0026rsquo;s ID Item\u0026rsquo;s name Prop\u0026rsquo;s ID Prop\u0026rsquo;s value   1 Apple 1 10   2 Orange 1 20   2 Orange 2 30          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; map\u0026lt;int32, Prop\u0026gt; prop_map = 3 [(tableau.field) = {key:\u0026quot;PropID\u0026quot; layout:LAYOUT_VERTICAL}]; message Prop { int32 prop_id = 1 [(tableau.field) = {name:\u0026quot;PropID\u0026quot;}]; int64 prop_value = 2 [(tableau.field) = {name:\u0026quot;PropValue\u0026quot;}]; } } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;10\u0026quot; } } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;propMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;propId\u0026quot;: 1, \u0026quot;propValue\u0026quot;: \u0026quot;20\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;propId\u0026quot;: 2, \u0026quot;propValue\u0026quot;: \u0026quot;30\u0026quot; } } } } }   Incell-map in vertical-map # A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Props     map\u0026lt;uint32, Item\u0026gt; map\u0026lt;int32, string\u0026gt;   Item\u0026rsquo;s ID Item\u0026rsquo;s props   1 1:sour,2:sweet,3:delicious   2 1:sour,2:sweet   3 1:sour          Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; map\u0026lt;int32, string\u0026gt; props_map = 2 [(tableau.field) = {name:\u0026quot;Props\u0026quot; layout:LAYOUT_INCELL}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;propsMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;sour\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;sweet\u0026quot;, \u0026quot;3\u0026quot;: \u0026quot;delicious\u0026quot; } }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;propsMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;sour\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;sweet\u0026quot; } }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;propsMap\u0026quot;: { \u0026quot;1\u0026quot;: \u0026quot;sour\u0026quot; } } } }   "}).add({id:35,href:"/docs/excel/infinite-nesting/",title:"Infinite nesting",description:"Infinite nesting.",content:"Overview # Now, the horizontal/vertical list element\u0026rsquo;s first field can be any type, even as struct, list, and map.\n List element\u0026rsquo;s first field is struct: [Reward]{Icon}int32 List element\u0026rsquo;s first field is predefined struct: [Cost]{.Item}uint32 List element\u0026rsquo;s first field is in-cell struct: [Magic]{int32 Id, int32 Num}Ability List element\u0026rsquo;s first field is list: [Reward][Item]uint32 List element\u0026rsquo;s first field is list with element as predefined struct: [Power][.Item]uint32 List element\u0026rsquo;s first field is map: [Superpower]map\u0026lt;uint32, Ability\u0026gt;   TODO: some clear examples.\n Nested naming # Predefined types in \u0026ldquo;common.proto\u0026rdquo;:\n// --snip-- enum ConfType { CONF_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; CONF_TYPE_CLOUD = 1 [(tableau.evalue).name = \u0026quot;Cloud\u0026quot;]; CONF_TYPE_LOCAL = 2 [(tableau.evalue).name = \u0026quot;Local\u0026quot;]; CONF_TYPE_REMOTE = 3 [(tableau.evalue).name = \u0026quot;Remote\u0026quot;]; } enum ServerType { SERVER_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; SERVER_TYPE_GAME = 1 [(tableau.evalue).name = \u0026quot;GameServer\u0026quot;]; SERVER_TYPE_ACTIVITY = 2 [(tableau.evalue).name = \u0026quot;ActivityServer\u0026quot;]; SERVER_TYPE_MATCH = 3 [(tableau.evalue).name = \u0026quot;MatchServer\u0026quot;]; }  HelloWorld.xlsx\u0026nbsp; LoaderConf  @TABLEAU      ServerType ServerConfType ServerConfConditionType ServerConfConditionValue     map\u0026lt;enum\u0026lt;.ServerType\u0026gt;, Server\u0026gt; [Conf]\u0026lt;enum\u0026lt;.ConfType\u0026raquo; [Condition] int32   Server name Sheet name Condition type Condition value         SERVER_TYPE_GAME CONF_TYPE_CLOUD 0 113     0 134   SERVER_TYPE_ACTIVITY CONF_TYPE_CLOUD      1      CONF_TYPE_LOCAL 9 34    CONF_TYPE_LOCAL 9 12    CONF_TYPE_LOCAL      Remote     MatchServer CONF_TYPE_UNKNOWN           Sheet Nested     LoaderConf true        Generated:\n hello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message LoaderConf { option (tableau.worksheet) = {name:\u0026quot;LoaderConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 nested:true}; map\u0026lt;int32, Server\u0026gt; server_map = 1 [(tableau.field) = {name:\u0026quot;Server\u0026quot; key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Server { ServerType type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; repeated Conf conf_list = 2 [(tableau.field) = {name:\u0026quot;Conf\u0026quot; key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Conf { ConfType type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; repeated Condition condition_list = 2 [(tableau.field) = {name:\u0026quot;Condition\u0026quot; key:\u0026quot;Type\u0026quot; layout:LAYOUT_VERTICAL}]; message Condition { int32 type = 1 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; int32 value = 2 [(tableau.field) = {name:\u0026quot;Value\u0026quot;}]; } } } }    loader_conf.json { \u0026quot;serverMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;SERVER_TYPE_GAME\u0026quot;, \u0026quot;confList\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_CLOUD\u0026quot;, \u0026quot;conditionList\u0026quot;: [ { \u0026quot;type\u0026quot;: 0, \u0026quot;value\u0026quot;: 113 } ] } ] }, \u0026quot;2\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;SERVER_TYPE_ACTIVITY\u0026quot;, \u0026quot;confList\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_CLOUD\u0026quot;, \u0026quot;conditionList\u0026quot;: [] }, { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_LOCAL\u0026quot;, \u0026quot;conditionList\u0026quot;: [ { \u0026quot;type\u0026quot;: 9, \u0026quot;value\u0026quot;: 34 } ] }, { \u0026quot;type\u0026quot;: \u0026quot;CONF_TYPE_REMOTE\u0026quot;, \u0026quot;conditionList\u0026quot;: [] } ] }, \u0026quot;3\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;SERVER_TYPE_MATCH\u0026quot;, \u0026quot;confList\u0026quot;: [] } } }   "}).add({id:36,href:"/docs/excel/field-property/",title:"Field property",description:"Different properties of tableau field.",content:"Overview #    Option Type Description     unique bool Check map key uniqueness.   range string Format: \u0026quot;left, right\u0026quot;. E.g.: \u0026quot;1,10\u0026quot;, \u0026quot;1,~\u0026quot;, \u0026quot;~,10\u0026quot;. Different interpretations of range: - number: value range. - string: count of utf-8 code point.   refer string Format: \u0026quot;SheetName(SheetAlias).ColumnName\u0026quot;.\nEnsure this field is in another sheet\u0026rsquo;s column value space (aka message\u0026rsquo;s field value space). E.g.:\n- \u0026quot;ItemConf.ID\u0026quot;: sheet name is unique.\n- \u0026quot;Item(ItemConf).ID\u0026quot;: different workbooks have the same sheet name, but sheet alias is unique inherently.   sequence int64 Ensure this field\u0026rsquo;s value is a sequence and begins with this value.   default string Use this default value if cell is empty.   fixed bool Auto-detected fixed size of horizontal list/map. Default: false.   size uint32 Specified fixed size of horizontal list/map.   form Form Specify cell data form of incell struct.\n- FORM_TEXT\n- FORM_JSON    Option unique # Option unique can be specified as true in the map field property. Then the tableauc will report an error if a duplicate key is appeared.\nOption range #  TODO\n Option refer #  TODO\n Option sequence #  TODO\n Option default #  TODO\n Option fixed #  List: implicit fixed size → Map: implicit fixed size →  Option size #  List: explicit fixed size → Map: explicit fixed size →  Option form # Option form is used to specify cell data form of incell struct.\nTwo kinds of form can be specified:\n FORM_TEXT: protobuf text format. FORM_JSON: protobuf JSON format.  "}).add({id:37,href:"/docs/excel/metasheet/",title:"Metasheet",description:'The metasheet is a worksheet named "@TABLEAU" to specify tableau parser options.',content:"Overview # Options below can be specified in the metasheet @TABLEAU to affect the corresponding worksheet\u0026rsquo;s layout, ability, loader and so on.\n  Option Type Description     Sheet string The worksheet name needed to be processed.   Alias string Rename worksheet to be used as the generated protoconf message name.   Namerow int32 Exact row number of column name definition at a worksheet.\nDefault: 1.   Typerow int32 Exact row number of column type definition at a worksheet.\nDefault: 2.   Noterow int32 Exact row number of column note definition at a worksheet.\nDefault: 3.   Datarow int32 Start row number of data at a worksheet.\nDefault: 4.   Nameline int32 The line number of column name definition in a cell. 0 means the whole cell.\nDefault: 0.   Typeline int32 The line number of column type definition in a cell. 0 means the whole cell.\nDefault: 0.   Transpose bool Interchanging the rows and columns of a given sheet.   Nested bool Nested naming of the namerow.\nDefault: false.   Sep string Separator for:\n1. separating in-cell list elements. 2. separating in-cell map items.\nDefault: ,.   Subsep string Subseparator for separating in-cell map Key-Value pair.\nDefault: :.   Merger []string Merge multiple workbook sheets (comma-separated) into this one with the same structure.\nE.g.: Item1.xlsx,Item2.xlsx.   AdjacentKey bool Merge adjacent rows with the same key. If the key cell is not set, it will be treated the same as the nearest key above the same column.\nDefault:false.   FieldPresence bool In order to track field presence of basic types (numeric, string, bytes, and enums), the generated field will be labeled optional.\nDefault:false.   OrderedMap bool Generate OrderedMap accessers or not.\nDefault: false.\nSupported: C++.   Index []string Generate index accessers, and multiple indexes are comma-separated. - Single-column index is in the forma: \u0026lt;ColumnName\u0026gt;[@IndexName], if IndexName is not set, it will be this column\u0026rsquo;s parent struct type name.\n- Multi-column index (or composite index) is in the form: ([column1, column2, column3,...])[@IndexName]\nE.g.: - ID\n- ID@Item\n- (ID,Type)\n- (ID,Type)@Item\n- ID, (ID,Type)@Item\nSupported: C++.    Empty @TABLEAU # If metasheet @TABLEAU is empty, then all other worksheets in the same workbook will be processed.\nA simple example # There is a worksheet Sheet1 in HelloWorld.xlsx, we want to rename sheet to ItemConf, define custom seperator as |, and generate ordered map accessers.\nSo the metasheet @TABLEAU in HelloWorld.xlsx should be configured as:\nHelloWorld.xlsx\u0026nbsp; Sheet1  @TABLEAU      ID Name     map\u0026lt;uint32, Item\u0026gt; string   Item\u0026rsquo;s ID Item\u0026rsquo;s Name   1 Apple   2 Orange   3 Banana         Sheet Alias Sep OrderedMap     Sheet1 ItemConf | true        Option Transpose # Option Transpose is specified as true in the metasheet @TABLEAU.\nA worksheet HeroConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; HeroConf  @TABLEAU      ID int32 Hero\u0026rsquo;s ID 123     Name string Hero\u0026rsquo;s name Robin   Desc string Hero\u0026rsquo;s description A big hero!   Skill []int32 Hero\u0026rsquo;s skills 100,101,102         Sheet Transpose     HeroConf true        Generated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message HeroConf { option (tableau.worksheet) = {name:\u0026quot;HeroConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 transpose:true}; int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; repeated int32 skill_list = 4 [(tableau.field) = {name:\u0026quot;Skill\u0026quot; layout:LAYOUT_INCELL}]; }    HeroConf.json { \u0026quot;id\u0026quot;: 123, \u0026quot;name\u0026quot;: \u0026quot;Robin\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A big hero!\u0026quot;, \u0026quot;skillList\u0026quot;: [ 100, 101, 102 ] }   Option Index # Option Index can be specified to generate index accessers, and multiple indexes are comma-separated. There are two kinds of indexes in tableau: one is single-column index, and another is multi-column index (aka composite index).\nEach column type can be:\n scalar: numbers, booleans, strings, and bytes. enum: e.g.: enum\u0026lt;.FruiteType\u0026gt; incell scalar list: e.g: []int32 incell enum list: e.g: []enum\u0026lt;.FruiteType\u0026gt;  Example: two worksheets ItemConf and ShopConf in HelloWorld.xlsx:\n ItemConf: index on columns of the same struct as map value. ShopConf: index on columns of the same struct as list element.  HelloWorld.xlsx\u0026nbsp; ItemConf  ShopConf  @TABLEAU      ID Name Desc     map\u0026lt;int32, Item\u0026gt; string string   Item\u0026rsquo;s ID Item\u0026rsquo;s name Item\u0026rsquo;s desc   1 Apple A kind of delicious fruit.   2 Orange A kind of sour fruit.   3 Banana A kind of calorie-rich fruit.         ID Type Desc     [Shop]int32 int32 string   Shop\u0026rsquo;s ID Shop\u0026rsquo;s type Shop\u0026rsquo;s desc   1 1 Shoes shop.   2 1 T-Shirt shop.   3 2 Fruite shop.         Sheet Index      ItemConf ID@Item, Name@AwardItem, (ID,Name)@SpecialItem    ShopConf ID@Shop, Type@ThemeShop, (ID,Type)@SpecialShop         Single-column index # Format: \u0026lt;ColumnName\u0026gt;[@IndexName].\nThe sign @ is the separator between column name and index name. if IndexName is not set, it will be this column’s parent struct type name. One or more indexes can be specified by comma-separated rule.\nExamples:\n ID ID@Item ID, Name@AwardItem ID@Item, Name@AwardItem  Multi-column index # Format: ([ColumnName1, ColumnName2, ColumnName3,...])[@IndexName].\nMulti-column index (or composite index) is composed of multiple columns in the same struct (in list or map) to increase query speed.\nThe sign @ is the separator between enclosed column names by parentheses and index name. if IndexName is not set, it will be this column’s parent struct type name. One or more indexes can be specified by comma-separated rule.\nExamples:\n (ID,Name) (ID,Name)@AwardItem ID@Item, (ID,Name)@AwardItem: one single-column index and one multi-column index.  Option Merger # Option Merger is used to merge multiple sheets (comma-separated) with same schema to one.\nEach element can be:\n just a workbook file path or Glob path (relative to this workbook): \u0026lt;Workbook\u0026gt;, then the sheet name is the same as this sheet. a workbook file path (relative to this workbook) with a worksheet name: \u0026lt;Workbook\u0026gt;#\u0026lt;Worksheet\u0026gt;.  For example:\nThe first (main) workbook: a worksheet ZoneConf in MergerMain.xlsx (with @TABLEAU):\nMergerMain.xlsx\u0026nbsp; ZoneConf  @TABLEAU      ID Name Difficulty     map\u0026lt;uint32, Zone\u0026gt; string int32   Zone’s ID Zone’s name Zone’s difficulty   1 Infinity 100         Sheet Merger     ZoneConf Merger*.xlsx        The second (sub) workbook: a worksheet ZoneConf in Merger2.xlsx (without @TABLEAU):\nMerger2.xlsx\u0026nbsp; ZoneConf      ID Name Difficulty     map\u0026lt;uint32, Zone\u0026gt; string int32   Zone’s ID Zone’s name Zone’s difficulty   2 Desert 200        The third (sub) workbook: a worksheet ZoneConf in Merger3.xlsx (without @TABLEAU):\nMerger3.xlsx\u0026nbsp; ZoneConf      ID Name Difficulty     map\u0026lt;uint32, Zone\u0026gt; string int32   Zone’s ID Zone’s name Zone’s difficulty   3 Snowfield 300        Generated:\nmerger_main.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ZoneConf { option (tableau.worksheet) = {name:\u0026quot;ZoneConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 merger:\u0026quot;Merger*.xlsx\u0026quot;}; map\u0026lt;uint32, Zone\u0026gt; zone_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Zone { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; int32 difficulty = 3 [(tableau.field) = {name:\u0026quot;Difficulty\u0026quot;}]; } }    HeroConf.json { \u0026quot;zoneMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Infinity\u0026quot;, \u0026quot;difficulty\u0026quot;: 100 }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Desert\u0026quot;, \u0026quot;difficulty\u0026quot;: 200 }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Snowfield\u0026quot;, \u0026quot;difficulty\u0026quot;: 300 } } }   Option Scatter # Option Scatter is used to scatter multiple sheets (comma-separated) with same schema to different generated config files.\nEach element can be:\n just a workbook file path or Glob path (relative to this workbook): \u0026lt;Workbook\u0026gt;, then the sheet name is the same as this sheet. a workbook file path (relative to this workbook) with a worksheet name: \u0026lt;Workbook\u0026gt;#\u0026lt;Worksheet\u0026gt;.  For example, there are three workbooks (each with same sheet schema, and Scatter1.xlsx is the main workbook):\n Scatter1.xlsx Scatter2.xlsx Scatter3.xlsx  The first (main) workbook: a worksheet ZoneConf in Scatter1.xlsx (with @TABLEAU):\nScatter1.xlsx\u0026nbsp; ZoneConf  @TABLEAU      ID Name Difficulty     map\u0026lt;uint32, Zone\u0026gt; string int32   Zone’s ID Zone’s name Zone’s difficulty   1 Infinity 100         Sheet Scatter     ZoneConf Scatter*.xlsx        The second (sub) workbook: a worksheet ZoneConf in Scatter2.xlsx (without @TABLEAU):\nScatter2.xlsx\u0026nbsp; ZoneConf      ID Name Difficulty     map\u0026lt;uint32, Zone\u0026gt; string int32   Zone’s ID Zone’s name Zone’s difficulty   2 Desert 200        The third (sub) workbook: a worksheet ZoneConf in Scatter3.xlsx (without @TABLEAU):\nScatter3.xlsx\u0026nbsp; ZoneConf      ID Name Difficulty     map\u0026lt;uint32, Zone\u0026gt; string int32   Zone’s ID Zone’s name Zone’s difficulty   3 Snowfield 300        Generated protoconf:\nscatter_1.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ZoneConf { option (tableau.worksheet) = {name:\u0026quot;ZoneConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4 scatter:\u0026quot;Scatter*.xlsx\u0026quot;}; map\u0026lt;uint32, Zone\u0026gt; zone_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Zone { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; int32 difficulty = 3 [(tableau.field) = {name:\u0026quot;Difficulty\u0026quot;}]; } }   It is supposed to generate three different config files (name pattern: \u0026lt;BookName\u0026gt;_\u0026lt;SheetName\u0026gt;):\n Scatter1_ZoneConf.json { \u0026quot;zoneMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Infinity\u0026quot;, \u0026quot;difficulty\u0026quot;: 100 } } }    Scatter2_ZoneConf.json { \u0026quot;zoneMap\u0026quot;: { \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Desert\u0026quot;, \u0026quot;difficulty\u0026quot;: 200 } } }    Scatter3_ZoneConf.json { \u0026quot;zoneMap\u0026quot;: { \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Snowfield\u0026quot;, \u0026quot;difficulty\u0026quot;: 300 } } }   "}).add({id:38,href:"/docs/basics/",title:"Basics",description:"Basics of Tableau.",content:""}).add({id:39,href:"/docs/basics/concepts/",title:"Concepts",description:"Core concepts of Tableau.",content:"Terminology # Basics #   Term Definition     Workbook An excel file.\nA XML file.\nA bundle of CSV files named with the same prefix seperated by #.   Worksheet A sheet in a excel file.\nA root node of a XML file.\nA CSV file.   Metasheet A worksheet named @TABLEAU to specify tableau parser options.   Row The row in a sheet.   Column The column in a sheet.   Cell The intersection of a row and a column.   In-cell The inner-side of a cell.   Cross-cell Continuous cells of a row or a column.    Worksheet #   Term Definition     Namerow Exact row number of column name definition at a worksheet.\n⚠️ NOTE: each column name must be unique in a worksheet!\nDefault: 1.   Typerow Exact row number of column type definition at a worksheet.\nDefault: 2.   Noterow Exact row number of column note at a worksheet.\nDefault: 3.   Datarow Start row number of data at a worksheet.\nDefault: 4.   Nameline The line number of column name definition in a cell. 0 means the whole cell.\nDefault: 0.   Typeline The line number of column type definition in a cell. 0 means the whole cell.\nDefault: 0.   Sep Separator for:\n1. separating in-cell list elements. 2. separating in-cell map items.\nDefault: ,.   Subsep Subseparator for separating in-cell map Key-Value pair.\nDefault: :.   Nested Nested naming of the namerow.\nDefault: false.   Layout Incell, vertical(cross-cell) or horizontal(cross-cell).   Transpose Interchanging the rows and columns of a given sheet.    Mappings to Protoconf #    Term Protoconf     Workbook One protoconf(.proto) file.   Worksheet One top-level message in a protoconf file, except the tableau metasheet named @TABLEAU.   column One field in a message    A simple mapping example # Input: an excel file # A workbook(HelloWorld.xlsx) with two data worksheets(ItemConf and ActivityConf) and an empty tableau metasheet(@TABLEAU).\nHelloWorld.xlsx\u0026nbsp; ItemConf  ActivityConf  @TABLEAU      ID Name Type     map\u0026lt;uint32, Item\u0026gt; string int32   Item\u0026rsquo;s ID. Item\u0026rsquo;s name. Item\u0026rsquo;s type.   1 item1 100   2 item2 200   3 item3 300         ID Name Open     map\u0026lt;uint32, Activity\u0026gt; string bool   Activity\u0026rsquo;s ID. Activity\u0026rsquo;s name. Activity is open?   1 activity1 true   2 activity2 false   3 activity3                                     Output: a protoconf file # A protoconf file(hello_world.proto) with two top-level messages(ItemConf and ActivityConf).\nhello_world.proto // Generated by tableauc 0.2.1. DO NOT EDIT. syntax = \u0026quot;proto3\u0026quot;; package protoconf; option go_package = \u0026quot;github.com/tableauio/demo/examples/helloworld/protoconf\u0026quot;; import \u0026quot;tableau/protobuf/tableau.proto\u0026quot;; option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; int32 type = 3 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; } } message ActivityConf { option (tableau.worksheet) = {name:\u0026quot;ActivityConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Activity\u0026gt; activity_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Activity { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; bool open = 3 [(tableau.field) = {name:\u0026quot;Open\u0026quot;}]; } }   Naming convention # All names of workbook, worksheet, column, and struct(message), should use the CamelCase style naming convention. So the tableau parser can keep the worksheet name as protoconf message name, and exactly convert CamelCase to snake_case for protoconf field name and filename, which is suggested by Protocol Buffers Style Guide.\n"}).add({id:40,href:"/docs/basics/grammar-and-types/",title:"Grammar and types",description:"Grammar and types.",content:"Overview # Tableau borrows most of its syntax and types from Protocol Buffers (proto3) and Golang.\nScalar types #  Details disccused at Protocol Buffers Proto3 Scalar.\n    Kind Types Default     Numbers int32, uint32\nint64, uint64\nfloat, double 0\n0\n0.0   Booleans bool false   Strings string \u0026quot;\u0026quot;   Bytes bytes \u0026quot;\u0026quot;    Well-known types # Datetime #   Type Default Description     datetime 0000-00-00 00:00:00 Format: yyyy-MM-dd HH:mm:ss. e.g.: 2020-01-01 05:10:00.   date 0000-00-00 Format: yyyy-MM-dd or yyyyMMdd. e.g.: 2020-01-01 or 20200101.   time 00:00:00 Format: HH:mm:ss or HHmmss, HH:mm or HHmm. e.g.: 05:10:00 or 051000, 05:10 or 0510.    Tips #  datetime and date are based on google.protobuf.Timestamp, see JSON mapping. time is based on google.protobuf.Duration, see JSON mapping.  Duration #   Type Default Description     duration 0s Format like: \u0026quot;72h3m0.5s\u0026quot;. Refer golang duration string form.    Tips #  duration is based on google.protobuf.Duration, see JSON mapping.  Composite types #    Type Description     struct A struct is mapped to a protobuf message.   list A list is mapped to a protobuf repeated field.   map A map is mapped to a protobuf map field.    struct #   Feature Description     Horizontal layout Each scalar field located in one cell.   Simple incell struct Each field must be scalar type. It is a comma-separated list of fields. E.g.: 1,test,3.0. If the data list\u0026rsquo;s size is not same as struct\u0026rsquo;s fields, then fields will be filled in order. Fields not configured will be filled with default values due to its scalar type.    list #   Feature Description     Horizontal layout This is list\u0026rsquo;s default layout. Element type can be struct or scalar.   Vertical layout List\u0026rsquo;s element type should be struct.   Simple incell list Element type must be scalar. It is a comma-separated list of elements. E.g.: 1,2,3.   Scalable Scalable or dynamic list size.   Ignore empty element Smart recognition of empty element at any position.    map #   Feature Description     Horizontal layout    Vertical layout This is map\u0026rsquo;s default layout.   Hash map Implemented as unordered map or hash map.   Ordered map Supported by tableauio/loader.\n- C++   Simple incell map Both key and value must be scalar type. It is a comma-separated list of key:value pairs. E.g.: 1:10,2:20,3:30.   Scalable Scalable or dynamic map size.   Ignore empty item Smart recognition of empty item at any position.    Enumeration #   Feature Description     Three forms of enum value 1. Enum value number.\n2. Enum value name.\n3. Enum value alias name (with EnumValueOptions specified).   Validation Auto-check legality of enum values.    Empty value #   Type Description     scalar Empty scalar will be emplaced with scalar type\u0026rsquo;s default value.   struct Empty struct will not be spawned if all fields are empty.   list Empty list will not be spawned if list\u0026rsquo;s size is 0.\nEmpty struct will not be appended if list\u0026rsquo;s element(struct type) is empty.   map Empty map will not be spawned if map\u0026rsquo;s size is 0. Empty struct will not be inserted if map\u0026rsquo;s value(struct type) is empty.   nesting Recursively empty.    "}).add({id:41,href:"/docs/basics/enum/",title:"Enum",description:"Enum features.",content:"Enum value # The tableau parser accepts three enum value forms:\n enum value name. enum value number. enum value alias. It is another name in English, Chinese, or any other language, which can be specified by tableau.evalue by extending google.protobuf.EnumValueOptions.  For example, enum type FruitType in common.proto is defined as:\nenum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = \u0026quot;Apple\u0026quot;]; FRUIT_TYPE_ORANGE = 2 [(tableau.evalue).name = \u0026quot;Orange\u0026quot;]; FRUIT_TYPE_BANANA = 3 [(tableau.evalue).name = \u0026quot;Banana\u0026quot;]; }  Then the three forms of enum value are all accepted:\n   Enum value number Enum value name Enum value alias     0 FRUIT_TYPE_UNKNOWN Unknown   1 FRUIT_TYPE_APPLE Apple   2 FRUIT_TYPE_ORANGE Orange   3 FRUIT_TYPE_BANANA Banana     NOTE: Enum type must be predefined.\n Go to read details about predefiend Enum type. Predefined types →\nValidation # As enum type is predefined, so the tableau parser will auto validate the enum value.\n"}).add({id:42,href:"/docs/basics/predefined-types/",title:"Predefined types",description:"Predefined types.",content:"Overview # You can define enum or struct types in a protoconf file (such as common.proto) ahead. It means you create predefined types, and then can use them to specify the column type or cross-cell struct type of a worksheet.\nUsage #  Syntax: prepend a dot . to predefined CustomType (a.k.a. .CustomType) when you use it in a worksheet. Import: specify the importedProtoFiles option of tableauc config to import the common proto files, where predefined enum or struct types are defined. Refer: Tableau Options.  Enum # The basic enum guide, please go to read Enum →\nFor example, enum type FruitType in common.proto is defined as:\nenum FruitType { FRUIT_TYPE_UNKNOWN = 0 [(tableau.evalue).name = \u0026quot;Unknown\u0026quot;]; FRUIT_TYPE_APPLE = 1 [(tableau.evalue).name = \u0026quot;Apple\u0026quot;]; FRUIT_TYPE_ORANGE = 2 [(tableau.evalue).name = \u0026quot;Orange\u0026quot;]; FRUIT_TYPE_BANANA = 4 [(tableau.evalue).name = \u0026quot;Banana\u0026quot;]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Type     map\u0026lt;uint32, Item\u0026gt; enum\u0026lt;.FruitType\u0026gt;   Item\u0026rsquo;s ID Fruit\u0026rsquo;s type   1 1   2 Orange   3 FRUIT_TYPE_BANANA                                    Generated:\nhello_world.proto // --snip-- import \u0026quot;common.proto\u0026quot;; option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; FruitType type = 2 [(tableau.field) = {name:\u0026quot;Type\u0026quot;}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;type\u0026quot;: \u0026quot;FRUIT_TYPE_APPLE\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;type\u0026quot;: \u0026quot;FRUIT_TYPE_ORANGE\u0026quot; } \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;type\u0026quot;: \u0026quot;FRUIT_TYPE_BANANA\u0026quot; }, } }   Struct # For example, struct type Prop in common.proto is defined as:\nmessage Prop { int32 id = 1 [(tableau.field).name = \u0026quot;ID\u0026quot;]; int32 value = 2 [(tableau.field).name = \u0026quot;Value\u0026quot;]; }  A worksheet ItemConf in HelloWorld.xlsx:\nHelloWorld.xlsx\u0026nbsp; ItemConf  @TABLEAU      ID Prop1ID Prop1Value Prop2ID Prop2Value     map\u0026lt;uint32, Item\u0026gt; [.Prop]int32 int32 int32 int32   Item\u0026rsquo;s ID Prop1\u0026rsquo;s ID Prop1\u0026rsquo;s value Prop2\u0026rsquo;s ID Prop2\u0026rsquo;s value   1 1 100 2 200   2 3 300 4 400   3 5 500                                      Generated:\nhello_world.proto // --snip-- import \u0026quot;common.proto\u0026quot;; option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message ItemConf { option (tableau.worksheet) = {name:\u0026quot;ItemConf\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;uint32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; repeated Prop prop_list = 2 [(tableau.field) = {name:\u0026quot;Prop\u0026quot; layout:LAYOUT_HORIZONTAL}]; } }    ItemConf.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 1, \u0026quot;value\u0026quot;: 100 }, { \u0026quot;id\u0026quot;: 2, \u0026quot;value\u0026quot;: 200 } ] }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 3, \u0026quot;value\u0026quot;: 300 }, { \u0026quot;id\u0026quot;: 4, \u0026quot;value\u0026quot;: 400 } ] }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;propList\u0026quot;: [ { \u0026quot;id\u0026quot;: 5, \u0026quot;value\u0026quot;: 500 } ] } } }   Variable naming # In horizontal map or horizontal list, you can define custom variable name with the predefined struct.\n"}).add({id:43,href:"/docs/tutorial/",title:"Tutorial",description:"Tutorial of Tableau",content:""}).add({id:44,href:"/docs/tutorial/overview/",title:"Overview",description:"Overview",content:"1. Download tableauc # Select the appropriate tableauc (a.k.a. Tableau Compiler) to download:\n   Platform Tableauc     Windows x64 .st0{fill:#0071BC}Download   Linux x64 .st0{fill:#0071BC}Download   macOS .st0{fill:#0071BC}Download     More platforms are available on tableau releases.\n 2. Configure tableauc # Create a file named config.yaml, and copy configurations below to it:\n# locale BCP 47 language tags: en, zh. lang: en # Location represents the collection of time offsets in use in a geographical area. # - If the name is \u0026quot;\u0026quot; or \u0026quot;UTC\u0026quot;, LoadLocation returns UTC. # - If the name is \u0026quot;Local\u0026quot;, LoadLocation returns Local. # - Otherwise, the name is taken to be a location name corresponding to a file in the # IANA Time Zone database, such as \u0026quot;America/New_York\u0026quot;, \u0026quot;Asia/Shanghai\u0026quot;, and so on. # # See https://go.dev/src/time/zoneinfo_abbrs_windows.go. locationName: Local # Log options. log: # Log mode: SIMPLE, FULL. mode: SIMPLE # Log level: DEBUG, INFO, WARN, ERROR. level: INFO # Log filename: set this if you want to write log messages to files. filename: \u0026quot;\u0026quot; # Log sink: CONSOLE, FILE, and MULTI. sink: CONSOLE # Options for generating proto files. proto: input: # Header options of worksheet. header: # Exact row number of column name definition at a worksheet. # Default: 1. namerow: 1 # Exact row number of column type definition at a worksheet. # Default: 2. typerow: 2 # Exact row number of column note at a worksheet. # Default: 3. noterow: 3 # Start row number of data at a worksheet. # Default: 4. datarow: 4 # The line number of column name definition in a cell. # Value 0 means the whole cell. # Default: 0. nameline: 0 # The line number of column type definition in a cell. # Value 0 means the whole cell. # Default: 0. typeline: 0 # The proto paths are used to search for dependencies that are referenced in import # statements in proto source files. If no import paths are provided then # \u0026quot;.\u0026quot; (current directory) is assumed to be the only import path. # Default: nil. protoPaths: [.] # The enums and messages in protoFiles can be used in Excel/CSV/XML as # common types. # Default: nil. protoFiles: [] # Specify input file formats. # Note: recognize all formats (Excel/CSV/XML) if not set (value is nil). # Default: nil. formats: [] # Specify only these subdirs (relative to input dir) to be processed. # Default: nil. subdirs: [] # Specify rewrite subdir path (relative to input dir). # Default: nil. subdirRewrites: {} # Follow the symbolic links when traversing directories recursively. # WARN: be careful to use this option, it may lead to infinite loop. # Default: false. followSymlink: false output: # Specify subdir (relative to output dir) for generated proto files. # Default: \u0026quot;\u0026quot;. subdir: \u0026quot;\u0026quot; # Dir separator `/` or `\\` in filename is replaced by \u0026quot;__\u0026quot;. # Default: false. filenameWithSubdirPrefix: false # Append suffix to each generated proto filename. # Default: \u0026quot;\u0026quot;. filenameSuffix: \u0026quot;\u0026quot; # Specify proto file options. # Example: go_package, csharp_namespace... # # Default: nil. fileOptions: {} # Options for generating conf files. conf: input: # The proto paths are used to search for dependencies that are referenced in import # statements in proto source files. If no import paths are provided then # \u0026quot;.\u0026quot; (current directory) is assumed to be the only import path. # # Default: nil. protoPaths: [.] # The files to be parsed to generate configurations. # # NOTE: # - Recognize \u0026quot;*.proto\u0026quot; pattern if not set (value is nil). # - Glob patterns is supported, which can specify sets # of filenames with wildcard characters. # # Default: nil. protoFiles: [\u0026quot;*.proto\u0026quot;] # The files not to be parsed to generate configurations. # # NOTE: Glob patterns is supported, which can specify sets # of filenames with wildcard characters. # # Default: nil. excludedProtoFiles: [] # Specify input file formats to be parsed. # Note: recognize all formats (Excel/CSV/XML) if not set (value is nil). # # Default: nil. formats: [] # Specify only these subdirs (relative to workbook name option in proto file). # # Default: nil. subdirs: [] # Specify rewrite subdir path (relative to workbook name option in proto file). # # Default: nil. subdirRewrites: {} output: # Specify subdir (relative to output dir) for generated configuration files. # Default: \u0026quot;\u0026quot;. subdir: \u0026quot;\u0026quot; # Specify generated conf file formats. If not set, it will generate all # formats (JSON/Text/Bin). # # Default: nil. formats: [json] # Output pretty format of JSON, with multiline and indent. # Default: false. pretty: true # EmitUnpopulated specifies whether to emit unpopulated fields. It does not # emit unpopulated oneof fields or unpopulated extension fields. # The JSON value emitted for unpopulated fields are as follows: # ╔═══════╤════════════════════════════╗ # ║ JSON │ Protobuf field ║ # ╠═══════╪════════════════════════════╣ # ║ false │ proto3 boolean fields ║ # ║ 0 │ proto3 numeric fields ║ # ║ \u0026quot;\u0026quot; │ proto3 string/bytes fields ║ # ║ null │ proto2 scalar fields ║ # ║ null │ message fields ║ # ║ [] │ list fields ║ # ║ {} │ map fields ║ # ╚═══════╧════════════════════════════╝ # # NOTE: worksheet with FieldPresence set as true ignore this option. # # Refer: https://github.com/protocolbuffers/protobuf/blob/main/docs/field_presence.md # # Default: false. emitUnpopulated: false  3. Add a workbook # A worksheet ItemConf in HelloWorld.xlsx:\n   ID Name Desc     uint32 string string   Item\u0026rsquo;s ID Item\u0026rsquo;s name Item\u0026rsquo;s description   1 Apple A kind of delicious fruit.     --break-me-here--\n4. Run tableauc # Run ./tableauc -c config.yaml\nGenerated:\nhello_world.proto // --snip-- option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message Apple { option (tableau.worksheet) = {name:\u0026quot;Apple\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; uint32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; }    Apple.json { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of delicious fruit.\u0026quot; }   Congratulations! You’ve just run the tableauc to convert a workbook to proto and JSON files.\n"}).add({id:45,href:"/docs/prologue/",title:"Prologue",description:"Prologue of Tableau",content:""}).add({id:46,href:"/docs/prologue/introduction/",title:"Introduction",description:"Intro to Tableau.",content:"tableauc # tableauc is the Tableau Compiler with protogen and confgen inside.\nprotogen # protogen convert Excel/CSV/XML files to Protoconf files. Protoconf is a dialect of Protocol Buffers (proto3) extended with tableau options, aimed to define the structure of Excel/CSV/XML.\nflowchart LR subgraph Input direction RL I1(Excel) I2(CSV) I3(XML) end Input --\u0026gt; B B((protogen)):::orangecalss --\u0026gt; C(Protoconf) classDef orangecalss fill:#f96;  confgen # confgen convert Excel/CSV/XML with Protoconf files to JSON/Text/Bin files.\nflowchart LR subgraph Input direction RL I1(Excel) I2(CSV) I3(XML) end Input --\u0026gt; B A(Protoconf) --\u0026gt; B B((confgen)):::orangecalss --\u0026gt; Output classDef orangecalss fill:#f96; subgraph Output direction RL O1(\u0026quot;JSON\u0026quot;) O2(\u0026quot;Text\u0026quot;) O3(\u0026quot;Bin\u0026quot;) end  "}).add({id:47,href:"/docs/prologue/quick-start/",title:"Quick Start",description:"Quick Start",content:"1. Download tableauc # Select the appropriate tableauc (aka Tableau Compiler) to download:\n  Windows x64   Windows x86     Linux x64   Linux x86     macOS     More platforms are available on tableau releases →.\n 2. Add a workbook # Add HelloWorld.xlsx with two sheets:\n Item: Copy data below to this worksheet. @TABLEAU: Just leave it empty now. It is the tableau metasheet → for specifying parser options.  HelloWorld.xlsx\u0026nbsp; Item  @TABLEAU      ID Name Desc     map\u0026lt;int32, Item\u0026gt; string string   Item’s ID Item’s name Item’s description   1 Apple A kind of delicious fruit.   2 Orange A kind of sour fruit.   3 Banana A kind of calorie-rich fruit.          3. Run tableauc # Run command: ./tableauc HelloWorld.xlsx\nThen hello_world.proto and Item.json are generated:\nhello_world.proto // Code generated by tableau (protogen v0.4.2). DO NOT EDIT. syntax = \u0026quot;proto3\u0026quot;; package protoconf; import \u0026quot;tableau/protobuf/tableau.proto\u0026quot;; option (tableau.workbook) = {name:\u0026quot;HelloWorld.xlsx\u0026quot;}; message Item { option (tableau.worksheet) = {name:\u0026quot;Item\u0026quot; namerow:1 typerow:2 noterow:3 datarow:4}; map\u0026lt;int32, Item\u0026gt; item_map = 1 [(tableau.field) = {key:\u0026quot;ID\u0026quot; layout:LAYOUT_VERTICAL}]; message Item { int32 id = 1 [(tableau.field) = {name:\u0026quot;ID\u0026quot;}]; string name = 2 [(tableau.field) = {name:\u0026quot;Name\u0026quot;}]; string desc = 3 [(tableau.field) = {name:\u0026quot;Desc\u0026quot;}]; } }   Item.json { \u0026quot;itemMap\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Apple\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of delicious fruit.\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;Orange\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of sour fruit.\u0026quot; }, \u0026quot;3\u0026quot;: { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: \u0026quot;Banana\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;A kind of calorie-rich fruit.\u0026quot; } } }   Congratulations! You’ve just run the tableauc to convert a workbook to proto and JSON files.\n"}).add({id:48,href:"/docs/",title:"Docs",description:"Docs Tableau.",content:""}),search.addEventListener('input',b,!0);function b(){var b,e;const d=5;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[h,g]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href=h,b.appendChild(a);const e=document.createElement('span');e.textContent=g.title,e.classList.add("suggestion__title"),a.appendChild(e);const f=document.createElement('span');if(f.textContent=g.description,f.classList.add("suggestion__description"),a.appendChild(f),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()